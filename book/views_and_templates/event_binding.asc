=== Event binding

A big part of writing snappy rich client applications is building models and
views that update in real-time with respect to one another. With Backbone.js
you accomplish this with events.

Client-side applications are asynchronous by nature. At the heart of a backbone
application lie events binding and triggering. Your application is written
using event-driven programming where components emit and handle events,
achieving non-blocking UIs.

With Backbone.js, it's very easy to write such applications. Backbone provides
the +Backbone.Events+ mixin, which can be included in any other class:

Here's a quick example of a very simple game engine, where things happen in the
system, they notify the game, which in turn invokes any event handlers that
are bound to that event.

[javascript]
source~~~~
var gameEngine = {};
_.extend(gameEngine, Backbone.Events);

gameEngine.bind("user_registered", function(user) {
  user.points += 10
});

gameEngine.trigger("user_registered", User.new({ points: 0 }));
source~~~~

+Backbone.Events+ is included on +Backbone.Views+, +Backbone.Model+ and
+Backbone.Collection+. Backbone itself will trigger events for you at
certain points. The flow of a user interface  will usually react to
certain well known events, and therefore they are so common that it
just makes sense for it to do so. For example, when a model's attributes are
changed, Backbone models conveniently trigger the +change+ event. It is
up to you to bind a handler on those events. More on that later.

As you can see from the example though, it is possible to bind and trigger
arbitrary events on any object that extendes +Backbone.Events+. Additionally,
if an event handler should always trigger regardless of which event got fired,
you can bind to the special +all+ event.

There are three primary kinds of events that your views will bind to:

* DOM events within the view's +this.el+ element
* Backbone events triggered by the view's model or collection
* Custom view events

TODO: This three-point breakdown is the wrong way to slice this.  Instead of
"DOM, model/collection, custom" it should be "DOM, events I observe, events I
publish".  Events that your view observes need to be cleaned up upon disposing
the view, regardless of where those events are triggered (models, collections,
or other views, or other arbitrary objects).  Events that your view publishes
need to be handled in a different way.

TODO: Consider promoting events and binding/unbinding to its own top-level
section; this isn't view-specific, although the view layer is where you'll be
doing most of your binding.

==== Binding to DOM events within the view element

The primary function of a view class is to provide behavior for its markup's DOM elements. You can attach event listeners by hand if you like:

[xml]
source~~~~
<!-- templates/soundboard.jst -->
<a class="sound">Honk</a>
<a class="sound">Beep</a>
source~~~~

[javascript]
source~~~~
var SoundBoard = Backbone.View.extend({
  render: function() {
    $(this.el).html(JST['soundboard']());
    this.$("a.sound").bind("click", this.playSound);
  },

  playSound: function() {
    // play sound for this element
  }
});
source~~~~

But Backbone provides an easier and more declarative approach with the +events+ hash:

[javascript]
source~~~~
var SoundBoard = Backbone.View.extend({
  events: {
    "click a.sound": "playSound"
  },

  render: function() {
    $(this.el).html(JST['soundboard']());
  },

  playSound: function() {
    // play sound for this element
  }
});
source~~~~

Backbone will bind the events with the
http://documentcloud.github.com/backbone/#View-delegateEvents[Backbone.View.prototype.delegateEvents()]
function.  It binds DOM events with +$.delegate()+, whether you're using the
http://api.jquery.com/delegate/[jQuery] or
https://github.com/madrobby/zepto/blob/v0.7/src/event.js#L96-108[Zepto]
+.delegate()+ function.

It also takes care of binding the event handlers' +this+ to the view instance using +_.bind()+.

==== Binding to events triggered by +this.model+ or +this.collection+

In almost every view you write, the view will be bound to a +Backbone.Model+ or
a +Backbone.Collection+, most often with the convenience properties +this.model+
or +this.collection+.

Consider a view that displays a collection of +Task+ models. It will re-render
itself when any model in the collection is changed or removed, or when a new
model is added:

[javascript]
source~~~~
include::tasks_index_view_class.js[]
source~~~~

Note how we bind to the collection's +change+, +add+ and +remove+ events.
The +add+ and +remove+ events are triggered when you either +add()+ or +remove()+
a model from that collection as expected. The +change+ event requires special
mention; it will trigger when any of the underlying models' +change+ event triggers.
Backbone just bubbles up that event to the containing collection for convenience.

==== Binding to custom events

With sufficiently complex views, you may encounter a situation where you want
one view to change in response to another.

Consider a simple example with a table of users and a toggle control that
filters the users to a particular gender:

[javascript]
source~~~~
GenderFilter = Backbone.View.extend({
  render: {
    // render template
  },
  events: {
    "click .show-male":   "showMale",
    "click .show-female": "showFemale",
    "click .show-both":   "showBoth"
  },

  showMale: function()   { this.trigger("changed", "male");   },
  showFemale: function() { this.trigger("changed", "female"); },
  showBoth: function()   { this.trigger("changed", "both");   }
});

UsersTable = Backbone.View.extend({
  initialize: function() {
    this.genderView = new GenderFilter();
    this.genderView.bind("changed", this.filterByGender);
    this.filteredCollection = this.collection;
    this.render();
  },

  render: {
    this.genderView.render();
    $(this.el).html(JST['users']({ users: this.filteredCollection }));
  }

  filterByGender: function(gender) {
    this.filteredCollection = this.collection.byGender(gender);
    this.render();
  }
});
source~~~~

In the above snippet, the +GenderFilter+ view is responsible for the filter
control. When a the appropriate elements are clicked, a custom +changed+ event
is triggered on itself. Note how it is also possible to pass arbitrary
parameters to the +trigger()+ function.

On the other hand, we have a +UserTable+ view which renders is responsible for
rendering a collection of users. It also observes this event via the call to
+bind()+, where it invokes the +filterByGender+ function.

While your views will generally bind to events on models and collections, a
situation like the above may arise where it is handy to trigger and bind to
custom events at the view layer. However, it's always a good idea to step
back and think through whether you should instead be binding to events on the
underlying components.
