=== Cleaning up: understanding binding and unbinding

Imagine you're writing a todo app. Consider two views: an index view which
contains all the tasks, and a detail view that shows detail on one task. The
interface switches between the two views, and both views can modify existing
tasks (say, to indicate that the task is complete or incomplete.)

image::views_and_templates/tasks-index.png[title="Tasks index view"]

image::views_and_templates/tasks-detail.png[title="Tasks detail view"]

The view classes for these pages could be written as follows:

[js]
source~~~~
include::tasks_index_view_class.js[]
source~~~~

[js]
source~~~~
include::task_detail_view_class.js[]
source~~~~

Each task on the index page links to the detail view for itself. When a user
follows one of these links and navigates from the index page to the detail
page, then interacts with the detail view to change a model, the +change+ event
on the +TaskApp.tasks+ collection is fired. One consequence of this is that
the index view, which is still bound and observing the +change+ event, will
re-render itself.

This is both a functional bug and a memory leak: not only will the index view
re-render and disrupt the detail display momentarily, but navigating back and
forth between the views without disposing of the previous view will keep
creating more views and binding more events on the associated models or
collections.

These can be extremely tricky to track down on a production application, 
especially if you are rendering children views, much like how Rails can render 
a partial for each member of a collection. Sadly, there's no "garbage 
collection" for views in Backbone, so your application needs to manage this 
itself.

The solution is to make sure you unbind events and remove views when you leave
them. Our approach to this is to use a convention in +Router+ instances, and reuse
this as a +Router+ subclass, +SwappingRouter+.
