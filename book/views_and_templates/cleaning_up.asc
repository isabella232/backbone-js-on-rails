=== Cleaning Up: Unbinding

Imagine you're writing a todo app. Consider two views: an index view which
contains all the tasks:

image::views_and_templates/tasks-index.png[title="Tasks index view"]

and a detail view that shows detail on one task:

image::views_and_templates/tasks-detail.png[title="Tasks detail view"]

The interface switches between the two views.

The view classes for these pages could be written as follows:

[js]
source~~~~
include::tasks_index_view_class.js[]
source~~~~

[js]
source~~~~
include::task_detail_view_class.js[]
source~~~~

Each task on the index page links to the detail view for itself. When a user
follows one of these links and navigates from the index page to the detail
page, then interacts with the detail view to change a model, the +change+ event
on the +TaskApp.tasks+ collection is fired. One consequence of this is that
the index view, which is still bound and observing the +change+ event, will
re-render itself.

This is both a functional bug and a memory leak: not only will the index view
re-render and disrupt the detail display momentarily, but navigating back and
forth between the views without disposing of the previous view will keep
creating more views and binding more events on the associated models or
collections.

These can be extremely tricky to track down on a production application, 
especially if you are rendering children views, much like how Rails can render 
a partial for each member of a collection. Sadly, there's no "garbage 
collection" for views in Backbone, so your application needs to manage this 
itself.

The solution is to make sure you unbind events and remove views when you leave
them. Our approach to this is two-fold: write a set of reusable functions that
manage cleaning up a view's bindings, and use these functions where ever views
are instantiated: in +Router+ instances, and in composite views.


TODO: Discuss different kinds of binding cleanup (this.remove(), this.model.unbind(), and this.unbind()) and then later when introducing CompositeView, just be making them reusable/conventino
TODO: how to reusably address this with +CompositeView.prototype.leave()+
