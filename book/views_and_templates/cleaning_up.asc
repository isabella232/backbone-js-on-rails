=== Cleaning up: understanding binding and unbinding (in progress)

Imagine you're writing a todo app.  Consider two views: an index view which
contains all the tasks, and a detail view that shows detail on one task.  The
interface switches between the two views, and both views can modify existing
tasks (say, to indicate that the task is complete or incomplete).

image::views_and_templates/tasks-index.png[title="Tasks index view"]

image::views_and_templates/tasks-detail.png[title="Tasks detail view"]

The view classes look something like this:

[js]
source~~~~
include::tasks_index_and_detail_view_classes.js[]
source~~~~

Each task on the index page links to the detail view for itself.  When a user
follows one of these links and navigates from the index page to the detail
page, then interacts with the detail view to change a model, the +change+ event
on the +TaskApp.tasks+ collection is fired.  One consequence of this is that
the index view, which is still bound and observing the +change+ event, will
re-render itself.

This is both a functional bug and a memory leak: not only will the index view
re-render and disrupt the detail display, but navigating back and forth between
the views without disposing of the previous view will keep creating and binding
more views.

The solution is to make sure you unbind and remove views when you leave them.
Our approach to this is to use a convention in +Router+ instances, and reuse
this as a +Router+ subclass, +SwappingRouter+.
