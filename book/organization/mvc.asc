=== Backbone.js and MVC

Model–View–Controller (MVC) is an architectural pattern used in many
applications to isolate "domain logic" (the application logic for the user)
from the user interface (input and presentation).

.Model-view-controller concept
image::image/MVCDiagram.png[]

In the above diagram a solid line represents a direct association and a dashed
line represents an indirect association (for example, via an observer).

As a user of Rails, you're likely already familiar with the concept of MVC and
the benefits that the separation of concerns can give you. However, Rails itself
is not doing "traditional" MVC. A traditional MVC is event-based. This means
that the views trigger events which the controller figures out what to do with.
It can be argued that the requests generated by the browser are the "events" in
Rails; however, due to the single-threaded, request-response nature of the web,
the control flow between the different levels of MVC is much more
straightforward.

Given that Javascript has events, and that much of the interactions between the
different components of Backbone.js in the browser are not limited to
request/response, programming with Backbone.js is in a lot of ways more like
working with a traditional MVC architecture.

That said, technically speaking, Backbone.js is _not_ MVC, and the creators of
Backbone.js acknowledged this when they renamed Controllers to Routers in
version 0.5.0.

What is Backbone.js then, if not MVC? Technically speaking, it's just the
Models and the Views with a Router to handle flow between them. In Backbone.js
the views will handle many of the aspects that controllers would typically
handle, such as actually figuring out what to do next and what to render.

While you could do it, the benefit of actually introducing a Controller in your
application would be limited, and the more pragmatic approach is to realize the
great organization that Backbone.js gives you is much better than what you had
before. The fact that it doesn't have a nice name, or strict adherence to a
pattern, isn't worth worrying about.

=== What Goes Where

Part of the initial learning curve of Backbone.js can be figuring out what goes
where, and mapping it to your expectations set by working with Rails. In Rails
we have Models, Views, Controllers, and Routers. In Backbone.js, we have
Models, Collections, Views, Templates, and Routers.

The models in Backbone.js and Rails are analogous. Backbone.js collections are
just ordered sets of models.  Because it lacks controllers, Backbone.js routers
and views work together to pick up the functionality provided by Rails
controllers. Finally, in Rails, when we say views, we actually mean templates.
In Backbone.js, however, you have a separation between the view and templates.

Once you introduce Backbone.js into your stack, you grow the layers in your
stack by four levels. This can be daunting at first, and frankly, at times it
can be difficult to keep everything going on in your application straight.
Ultimately, the additional organization and functionality of Backbone.js
outweighs the costs, so let's break it down.

.Rails
* Model
* Controller
* View

.Backbone.js
* Model and Collection
* Router
* View
* Template

In a typical Rails and Backbone.js application, the initial interaction between
the layers will be as follows:

- A request from a user comes in the *Rails router* identifies what should
  handle the request based on the URL
- The *Rails controller action* to handle the request is called, some initial
  processing may be performed
- The *Rails view template* is rendered and returned to the user's browser
- The *Rails view template* will include *Backbone.js initialization*, usually
  this is populating some *Backbone collections* as sets of *Backbone models*
  with JSON data provided by the *Rails view*
- The *Backbone.js router* determines which of its methods should handle the
  display based on the URL
- The *Backbone.js router* method calls that method, some initial processing
  may be performed, and one or more *Backbone.js views* are rendered
- The *Backbone.js view* reads *templates* and uses *Backbone.js* models to
  render itself onto the page

At this point, the user will see a nice page in their browser and be able to
interact with it. The user interacting with elements on the page will trigger
actions to be taken at any level of the above sequence: *Backbone.js model*,
*Backbone.js views*, *Backbone.js router*, or requests to the remote server.

Requests to the remote server may be any one of the following:

- At the *Backbone.js model* or *Backbone.js collection* level, communicating
  with Rails via JSON.
- Normal Ajax requests, not using Backbone.js at all.
- Normal requests that don't hit Backbone.js and trigger a full page reload.

Which of the above remote server interactions you use will depend upon the
desired result, and the type of user interface. This book should help you
understand which interaction you'll want to choose for each portion of your
application.
