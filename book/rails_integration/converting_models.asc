=== Converting your Rails models to Backbone.js-friendly JSON (in progress)

By default Backbone.js communicates with your Rails application via JSON gets
and posts. If you've ever made a JSON api for your Rails app, then for the most
part this will be very similar.

If you haven't ever made a JSON api for your Rails application before, lucky
you, it's pretty straightforward.

==== Models

One important aspect to keep in mind as you plan out how your Backbone.js
interface will behave, and how it will use your Rails back-end is that there is
no need to have a one-to-one mapping between your Rails models and your
Backbone.js models.

The smaller an application is, the more likely that there will be a one-to-one
mapping between both Backbone.js and Rails models and controllers.

However, if you have a sufficiently complex application, its more likely that
you _won't_ have a one-to-one mapping due to the differences in the tools
Backbone.js gives you and the fact that you're building a user-interface, not a
back-end. Some of the reasons why you won't have a one to one mapping include:

* Because you're building a user interface, not a back-end, it's likely that
* some of your backbone models will aggregate information from multiple Rails
* models into one Backbone.js model. This Backbone.js model may or may not be
* named the same as one of your Rails models.  Backbone.js gives you a new type
* of object not present in Rails: Collections.  Backbone.js doesn't have the
* concept of relationships out of the box.

With that said, lets take the simple case first and look at how you might make a
Backbone.js version of a Rails model.

In our example application, we have a Task model. The simplest Backbone.js
representation of this model would be as shown below.

[js]
source~~~~
var Task = Backbone.Model.extend({ 
  urlRoot: '/tasks' 
});
source~~~~

The urlRoot property above indicates to Backbone.js that the server url for
instances of this model will be found at /tasks/:id.

In Rails, its possible to access individual Tasks, as well as all Tasks (and
query all tasks) through the same Task model. However, in Backbone.js models
only represent the singular representation of a Task. Backbone.js splits out the
plural representation of Tasks into what it calls Collections.

The simplex Backbone.js collection to represent our Tasks would be the
following.

[js]
source~~~~
var Tasks = Backbone.Collection.extend({
  model: Task 
});
source~~~~

If we specify the url for Tasks in our collection instead, then models within
the collection will use the collection's url to construct their own urls, and
the urlRoot no longer needs to be specified in the model. If we make that
change, then our collection and models will be as follows.

[js]
source~~~~
var Tasks = Backbone.Collection.extend({ 
  model: Task, 
  url: '/tasks'
});

var Task = Backbone.Model.extend({}); 
source~~~~

Notice in the above model definitions that there is no specification of the
attributes on the model. Like ActiveRecord, Backbone.js models get their
attributes from the schema and data given to them. In the case of Backbonejs,
this schema and data are the JSON from the server.

The default JSON representation of an ActiveRecord model is a Hash that includes
all the model's attributes. It does not include the data for any related models
or any methods on the model, but it does include the ids of any related models
as those are stories in a relation name _id attribute on the model.

The JSON representation of your ActiveRecord models will be retrieved by calling
to_json on them. You customize the output of to_json by overriding the as_json
method in your model.

The most common things you'll do in your Rails app when working with Backbone.js
are the following.

Its likely that you'll wan to switch from including all attributes by default to
excluding some attributes. This can be done by specifying explicitly only the
attributes that are to be included, or specifying the attributes that should be
included. Which one you choose will depend on how many attributes your model has
and how paranoid you are about something important appearing in the JSON when it
shouldn't be there. If your concerned about sensitive data unintentionally being
included in the json when it shouldn't be then you'll want to switch to
everything being explicitly included in the json. Otherwise, its a matter of
preference and you can do what feels best for you an your app.

To explicitly specify the attributes to be included in the json, use the :only
option, as shown in the following as_json implementation.

[ruby]
source~~~~
def as_json(options = {}) 
  super(options.merge(:only => [ :id, :title ]))
end
source~~~~

The above as_json override will make it so that the json will _only_ include the
id and title attributes, even if there are many other attributes on the model.

If instead you want to include all attributes by default and just exclude a few,
you accomplish this with the :except option, as shown below.

[ruby]
source~~~~
def as_json(options = {})
  super(options.merge(:except => [ :encrypted_password ]))
end
source~~~~

Another common customization you will want to do in the json is include the
output of methods on your model. This is accomplished with the :methods option,
as shown in the following example.

[ruby]
source~~~~
def as_json(options = {})
  super(options.merge(:methods => [ :calculated_value ]))
end
source~~~~

The final thing you'll most commonly do with your JSON is include related
objects. If our Tasks have_many Comments, to include all of the JSON for
comments on a Task in the JSON for a Task. You do this with the :include option,
as shown in the following example.

[ruby]
source~~~~
def as_json(options = {})
  super(options.merge(:include => [ :comments ]))
end
source~~~~

As you probably suspect, you can then customize the JSON for the comments by
overriding the as_json method on the Comment model.

TODO: talk about include_root_in_json in Rails 3.1 and Rails 3.0

While these are the most common as_json options you'll use when working with
Backbone.js, it certainly isn't all of them. The official, complete,
documentation for the as_json method can be found here:
http://apidock.com/rails/ActiveModel/Serializers/JSON/as_json

==== Controllers

The Backbone models and collections will talk to your Rails controllers. While
your models may not have a one-to-one mapping with their Rails counterparts, it
is likely that you'll have at least one controller corresponding to every
Backbone.js model.

TODO: pretty much entire controller section
