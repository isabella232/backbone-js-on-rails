=== Model relationships

In any non-trivial application, you will have relationships in your domain model
that are valuable to express on the client side.  For example, consider a
contact management application where each person in your contact list has many
phone numbers, each of a different kind.

Or, consider a project planning application where there are Teams, Members, and
Projects as resources (models and collections).  There are relationships between
each of these primary resources, and those relationships in turn may be exposed
as first-class resources: a Membership to link a Team and a Member, or a
Permission to link a Team with a Project.  These relationships are often exposed
as first-class models so they can be created and destroyed the same way as other
models, and so that additional domain information about the relationship, such
as a duration, rate, or quantity, can be described.

These model relationships don't have to be persisted by a relational database.
In a chatroom application whose data is persisted in a key-value store, the data
could still be modeled as a Room which has many Messages, as well as Memberships
that link the Room to Users.  A content management application that stores its
data in a document database still has the notion of hierarchy, where a Site
contains many Pages, each of which is constitutes of zero or more Sections.

In a vanilla Rails application, the object model is described on the server side
with ActiveRecord subclasses, and exposed to the Backbone.js client through a
JSON HTTP API.  You have a few choices to make when designing this API, largely
focused on the inherent coupling of model relationships and data
-- when you handle a request for one resource, which of its associated resources
(if any) do you deliver, too?

Then, on the client side, you have a wide degree of choice in how to model the
relationships, when to eagerly pre-fetch associations and when to lazily defer
loading, and whether to employ a supporting library to help define your model
relationships.

==== Backbone-relational plugin

If your use cases are supported by it, Paul Uithol's
https://github.com/PaulUithol/Backbone-relational[Backbone-relational] is
arguably the most popular and actively maintained library for this.  It lets
you declare one-to-one, one-to-many, and many-to-one relations on your Backbone
models by extending a new base class, +Backbone.RelationalModel+.  It's good to
understand how this works under the hood, so we'll cover one way to implement a
relational object model in Backbone below, but we encourage you to check out
the +Backbone-relational+ plugin as a way to work at a higher level of
abstraction.

==== Relations in the Task App

In the example application, there are Users which have many Tasks.  Each Task
has many Comments and Attachments.

==== Deciding how to deliver data to the client

Before you decide how to model your JSON API or how to declare your client-side model
relationships, step back and consider the user experience of your application.
For TaskApp, we decided to have interactions as follows:

* A user signs up or logs in
* The user is directed to their dashboard
* The dashboard shows all tasks, but not the comments or attachments.
* When a user views the details of an individual task, the comments and
  attachments for that task are displayed.

This leads us to see that the Tasks for a user are used immediately
upon navigating to the dasboard, but the Comment and Attachment data for a Task
are not needed upon initial page load, and are possibly never needed at all.

Let's say that we are also planning for the user to have continuous network
access, but not to necessarily have a high speed connection.  Also, users tend
to view their list of tasks frequently, but rarely view the comments and
attachments.

Based on this, we will bootstrap the collections of Tasks inside the
dashboard, and defer loading of associated Comments and Attachments until after
the user clicks through to a task.

We could have selected from several other alternatives, including:

* Don't preload any information, and deliver only static assets (HTML, CSS, JS)
  on the dashboard request.  Fetch all resources over separate XHR calls.  This
  can provide for a faster initial page load, at the cost of a longer time to
  actual interactivity: although the byte size of the page plus data is roughly
  the same, the overhead of additional HTTP requests incurs the extra load time.
* Preload all the information, including Comments and Attachments.  This would
  work well if we expected users to frequently access the comments and
  attachments of many tasks, but incurs a longer initial page load.
* Use localStorage as the primary storage engine, and sync to the Rails server
  in the background.  This would be advantageous if we expected network access
  to be intermittent, although it incurs the additional complexity of having to
  resolve conflicts on the server if two clients submit conflicting updates.

==== Designing the HTTP JSON API

Now that we know we'll bootstrap the Tasks and defer the Comments and
Associations, we should decide how to deliver the deferred content, Comments
and Associations.  Our goal is to fetch to comments and attachments for an
individual task.  Let's discuss two options.

One way we could approach this is to issue separate API calls for each
nested resource:

[bash]
source~~~~
$ curl http://tasksapp.local:3000/tasks/78/comments.json | ppjson
[
  {
    "id": 208,
    "user_id": 3,
    "body": "What do you think of this mock? (See attachment)"
  },
  {
    "id": 209,
    "user_id": 1,
    "body": "Looks great!  I'll implement that."
  }
]

$ curl http://tasksapp.local:3000/tasks/78/attachments.json | ppjson
[
  {
    "id": "32",
    "file_url": "https://s3.amazonaws.com/tasksapp/uploads/32/mock.png"
  }
]
source~~~~

NOTE: We will authenticate API requests with cookies, just like normal user
login, so the actual curl request would need to include a cookie from a logged
in user.

This approach has the advantage of adhering more to convention, and requiring
less code in both the server-side JSON presentation and the client-side JSON
parsing.  Its disadvantage is performance: to fetch a task's associated data, we
need to send 2 HTTP requests.  When more kinds of associated resources are added
in the future, the number of requests will increase.

Another way we could approach this is to embed the comment and attachment data in
the JSON representation of an individual task, and deliver this data from the
+/tasks/:id+ endpoint:

[bash]
source~~~~
$ curl http://tasksapp.local:3000/tasks/78.json | ppjson
{
  /* some attributes left out for clarity */

  "id": 78,
  "user_id": 1,
  "title": "Clean up landing page",
  "comments": [
    {
      "id": 208,
      "user_id": 3,
      "body": "What do you think of this mock? (See attachment)"
    },
    {
      "id": 209,
      "user_id": 1,
      "body": "Looks great!  I'll implement that."
    }
  ],
  "attachments": [
    {
      "id": "32",
      "upload_url": "https://s3.amazonaws.com/tasksapp/uploads/32/mock.png"
    }
  ]
}
source~~~~

This approach involves additional code in both producing the JSON on the server
side and parsing the JSON on the client side.  We'll take this approach for the
example application, both because it requires fewer HTTP requests and because
it's a more interesting example and illustrates the technique of parsing nested
models in Backbone.js.

Since we're bootstraping the Tasks and deferring the Comments and
Attachments, we know that our HTTP JSON API should support at least the
following Rails route:

[ruby]
source~~~~
resources :tasks, :only => [:show, :create, :update, :delete]
source~~~~

TIP: In some applications, you choose to expose a user-facing API.  It's
valuable to "dogfood" this endpoint by making use of it from your own Backbone
code.  Often these APIs will be scoped under an "/api" namespace, possibly with
an API version namespace as well like "/api/v1".

==== Implementing the API: presenting the JSON

For building the JSON presentation, we have a few options. Rails already comes
with support for overriding the +Task#as_json+ method, which is probably
the easiest thing to do. However, logic regarding the JSON representation of
a model is not necessarily the model's concern. Furthermore, the +as_json+ approach
can become cumbersome when representing complex hierarchies. Other approaches
such as creating a separate presenter object, or writing a builder-like view are
all better approaches because additionally we don't pollute our models with
presentational logic.

The link:https://github.com/nesquena/rabl[RABL rubygem] is a good generalization
of the problem and can help with this particular aspect of your API implementation.

RABL allows you to create templates where you can easily specify the JSON
representation of your models. If you've worked with the +builder+
library to generate XML such as an RSS feed, you'll feel right at home.

To use it, first include the +rabl+ and +yajl-ruby+ gems in your Gemfile. Then
you can create a view ending with +.json.rabl+ to handle any particular request.
For example, a tasks#show action may look like this:

[ruby]
source~~~~
class TasksController < ApplicationController
  respond_to :json
  def show
    @task = Task.find(params[:id])
    respond_with @task
  end
end
source~~~~

Rails responders will first look for a template matching the controller/action
with the format in the file name, in this case +json+. If it doesn't find it,
it will invoke +to_json+ on the +@task+ model, but in this case we are providing
one in +app/views/tasks/show.json.rabl+, so it will render that instead:

[ruby]
source~~~~
object @task
attributes(:id, :title, :complete)
child(:user) { attributes(:id, :email) }
child(:attachments) { attributes(:id, :email) }
source~~~~

We'll illustrate the child associations with +attachments+, and leave +comments+
as an exercise for the reader.

Now it is much easier to extend and tweak the JSON generated on the server,
while still keeping the model free of presentational behavior. Do look at
the link:https://github.com/nesquena/rabl#readme[project's readme] for all the
bells and whistles.

==== Parsing the JSON and instantiating client-side models

Now that we are delivering the +task+ JSON to the client and including its
nested associations, we need to correctly handle this nested data in the
client-side model.  Instead of a nested hash of attributes on the parent
+task+ object, we want to instantiate a Backbone collection for the
attachments that contains a set of Backbone +Attachment+ models.

It's important to point out that the JSON for the attachments is initially
set on the Backbone +Task+ model as a Backbone attribute which can be
accessed with +get()+ and +set()+, and that we are replacing it with an
instance of a Backbone +Attachments+ collection and placing that as an
object property:

[javascript]
source~~~~
taskBeforeParsing.get('attachments')
// => [ { id: 1, upload_url: '...' }, { id: 2, upload_url: '...' } ]
taskBeforeParsing.attachments
// => undefined

/* parse attributes... */

taskAfterParsing.get('attachments')
// => undefined
taskAfterParsing.attachments
// => ExampleApp.Collection.Attachments(...)
source~~~~

One way to do this is to override the +parse+ function on the +Task+ model.

There are two +parse+ functions in Backbone: one on +Collection+ and another on
+Model+.  Backbone will invoke them whenever a model or collection is populated
with data from the server; that is, during +Model#fetch+, +Model#save+ (which
updates model attributes based on the server's response to the HTTP PUT/POST
request), and +Collection#fetch+.  It's also invoked when a new Model is
initialized and +options.parse+ is set to +true+.

It's important to note that +parse+ is not called by +Collection#reset+,
which should be called with an array of models as its first argument.  Backbone
does support calling +Collection#reset+ with just an array of bare attribute
hashes, but these will not be routed through +Model#parse+, the source of some
confusion.

Another way to intercept nested attributes and produce a full object graph
is to bind to the +change+ event for the association attribute - in this case,
+task.attachments+:

[javascript]
source~~~~
ExampleApp.Models.Task = Backbone.Model.extend({
  initialize: function() {
    this.on("change:attachments", this.parseAttachments);
    this.parseAttachments();
  },

  parseAttachments: function() {
    this.attachments = new ExampleApp.Collections.Attachments(this.get('attachments'));
    delete this.attachments;
  },

  // ...
source~~~~

This ensures that our custom parsing gets invoked any time the +attachments+
attribute is changed, and when new model instances are created.

==== When to fetch deferred data

Since a Backbone Task doesn't always have its associations filled, when you
move from TasksIndex to TasksShow, you need to invokep task.fetch() to pull all
the task attributes from `GET /tasks/:id` and populate the associations.  Whose
concern is that?

You could lazily populate this association by making the +task.attachments+
association a function instead of a property. Compare task.attachments.each to
task.attachments().each; in the latter, the accessing function encapsulates the
concern of lazily fetching and populating, but then you run into the issue that
fetch is asynchronous.  Passing a callback into +attachments()+ is kludgy; it
exposes the deferred nature of the association everywhere you need to access it.

We'll instead prefer to treat the deferred nature explicitly in the
+Routers.Tasks#show+ route, a natural application seam to the +TaskShow+ view.
This frees +TaskShow+ from having to know about the persistence details of
the model.

[javascript]
source~~~~
ExampleApp.Routers.Tasks = Support.SwappingRouter.extend({
  // ...

  show: function(taskId) {
    var task = this.collection.get(taskId);
    var tasksRouter = this;
    task.fetch({
      success: function() {
        var view = new ExampleApp.Views.TaskShow({ model: task });
        tasksRouter.swap(view);
      }
    });
  }
});
source~~~~

Now, we have successfully deferred the +Task#attachments+ association and
kept the concern clear of the view.
