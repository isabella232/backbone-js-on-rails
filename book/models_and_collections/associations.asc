=== Model associations

Backbone.js doesn't prescribe a way to define associations between models, so
we need to get creative and use the power of JavaScript to set up associations
in such a way that its usage is natural.


==== Belongs to associations

Setting up a +belongs_to+ association in Backbone is a two step process. Let's
discuss setting up the association that may occur between a task and a user.
The end result of the approach is a +Task+ instance having a property called
+user+ where we store the associated +User+ object.

To set this up, let's start by telling Rails to augment the task's JSON
representation to also send over the associated user attributes:

[ruby]
source~~~~
class Task < ActiveRecord::Base
  belongs_to :user

  def as_json(options = {})
    super(options.merge(include: { user: { only: [:name, :email] } }))
  end
end
source~~~~

This means that when Backbone calls +fetch()+ for a +Task+ model, it will
include the name and email of the associated user nested within the task JSON
representation. Something like this:

[javascript]
source~~~~
{
  "title": "Buy more Cheeseburgers",
  "due_date": "2011-03-04",
  "user": {
    "name": "Robert McGraffalon",
    "email": "bobby@themcgraffalons.com"
  }
}
source~~~~

Now that we receive user data with the task's JSON representation, let's tell
our Backbone User model to store the User object. We do that on the task's
initializer. Here's a first cut at that:

[javascript]
source~~~~
var Task = Backbone.Model.extend({
  initialize: function() {
    this.user = new User(this.get('user'));
  }
});
source~~~~

We can make a couple of improvements to the above. First, you'll soon realize
that you might be setting the user outside of the initialize as well. Second,
the initializer should check whether there is user data in the first place. To
address the first concern, let's create a setter for the object. Backbone
provides a handy function called +has+ that returns true or false depending on
whether the provided attribute is set for the object:

[javascript]
source~~~~
var Task = Backbone.Model.extend({
  initialize: function() {
    if (this.has('user')) {
      this.setUser(new User(this.get('user')));
    }
  },

  setUser: function(user) {
    this.user = user;
  }
});
source~~~~

The final setup allows for a nice clean interface to a task's user, by
accessing the task property of the user instance.

[javascript]
source~~~~
var task = Task.fetch(1);
console.log(task.get('title') + ' is being worked on by ' + task.user.get('name'));
source~~~~

==== Has many associations

You can take a similar approach to set up a +has_many+ association on the
client side models. This time, however, the object's property will be a
Backbone collection.

Following the example, say we need access to a user's tasks. Let's set up the
JSON representation on the Rails side first:

[ruby]
source~~~~
class User < ActiveRecord::Base
  has_many :tasks

  def as_json(options = {})
    super(options.merge(include: { tasks: { only: [:body, :due_date] } }))
  end
end
source~~~~

Now, on the Backbone +User+ model's initializer, let's call the +setTasks+
function:

[javascript]
source~~~~
var User = Backbone.Model.extend({
  initialize: function() {
    var tasks = new Tasks.reset(this.get('tasks'));
    this.setTasks(tasks);
  },

  setTasks: function(tasks) {
    this.tasks = tasks;
  }
});
source~~~~

Note that we are setting the relation to an instance of the +Tasks+ collection.

TODO: Let's exapnd upon this, as it isn't the most flexible solution.  (It is
a good start.) We are setting the JSON representation of the Rails models to
suit the Backbone.js concerns.  Additionally, the +Task#as_json+ method at the
top is concerned with the User JSON representation.  It should at least delegate
to User#as_json. Going further, the JSON presentation for consumption by
Backbone.js should be completely extracted into the JSON API endpoint controller
action, or even a separate presenter class.
