=== Duplicating business logic across the client and server

When you're building a multi-tier application where business logic is spread
across tiers, one big challenge you face is to avoid duplicating that logic
across tiers.  There is a tradeoff here, between duplication and performance.
It's desirable to have one and only one implementation of a partciular concern
in your domain, but it's also desirable for your application to perform
responsively.

==== An example: model validations

For example, let's say that a user must have an email address.

At one end of the scale, there is no duplication: all business logic is defined
in one tier, and other tiers access the logic by remote invocation.  Your Rails
`Member` model provides a validation:

[ruby]
source~~~~
class Member < ActiveRecord::Base
  validate :email, :presence => true
end
source~~~~

The Backbone view attempts to persist the Member as usual, binding to its
`error` event to handle the server side error:

[javascript]
source~~~~
var MemberFormView = Backbone.View.extend({
  events: {
    "submit form": "submit"
  },

  initialize: function() {
    _.bindAll(this, "error");
    this.bindTo(this.model, "error", this.error);
  },

  render: function() {
    // render form...
  },

  submit: function() {
    var attributes = new FormSerializer(this.$('form')).attributes();
    this.model.save(attributes);
  },

  error: function(model, errorResponse) {
    new ErrorView(errorResponse, this.$('form')).render();
  }
});
source~~~~

This assumes an `ErrorView` class which is able to parse the error hash returned
from Rails, which looks like this when served as JSON:

[javascript]
source~~~~
{
  "email": ["can't be blank"]
}
source~~~~

An implementation of `ErrorView` might look like this:

[javascript]
source~~~~
var ErrorView = function(errorResponse, form) {
  this.form = $(form);
  this.errors = JSON.parse(errorResponse.responseText);
};

_.extend(ErrorView.prototype, {
  render: function() {
    this.form.$(".error").removeClass("error");
    this.form.$("p.inline-errors").remove();
    this.errors.each(this.renderError);
  },

  renderError: function(errors, attribute) {
    var errorString = errors.join(", ");
    var field = this.form.fieldFor(attribute);
    var errorTag = $('<p>').addClass('inline-errors').text(errorString);
    field.append(errorTag);
    field.addClass("error");
  },

  fieldFor: function(attribute) {
    return this.form.find('[id*="_' + attribute + '_input"]').first();
  }
});
source~~~~

In the case of no duplication, your Backbone `Member` model does not declare
this validation.  An user fills out a form for a creating a new Member in your
application, submits the form, and, if they forgot to include an email address,
a validation message is displayed.  The application delegates the entire
validation concern to the server, as we saw in the [TODO: Reference needed for
remote validation] section.

However, round-tripping validation to the server can be too slow in some cases,
and we'd like to provide feedback to the end-user more quickly.  To do this, we
have to implement the validation concern on the client side as well.  Backbone
provides a facility for validating models during their persistence, so we could
write:

[javascript]
source~~~~
var Member = Backbone.Model.extend({
  validate: function() {
    var errors = {};
    if (_.isEmpty(this.get('email'))) {
      errors.email = ["can't be blank"];
    }
    return errors;
  }
});
source~~~~

Conveniently, we've structured the return value of the `validate()` function to
mirror the structure of the Rails error JSON we saw returned above.  Now, we
could augment the `ErrorView` class's constructor function to handle either
client-side or server-side errors:

[javascript]
source~~~~
var ErrorView = function(responseOrErrors, form) {
  this.form = $(form);

  if (responseOrErrors && responseOrErrors.responseText) {
    this.errors = JSON.parse(responseOrErrors.responseText);
  } else {
    this.errors = responseOrErrors;
  }
};
source~~~~



Let's take a look at what kinds of logic you might find
duplicated, and strategies for reducing duplication.

==== Kinds of logic you duplicate

In Rails applications, our model layer often contains three kinds of business logic:
validations, algorithms, and lifecycle effects (callbacks).


==== Why does this happen

==== Downsides of this duplication

==== Strategies for reducing duplication

1. Remote invocation
2. 
http://c2.com/cgi/wiki?HalfObjectPlusProtocol
http://c2.com/cgi/wiki?HoppPatternLanguage


TODO: The ErrorList/ErrorView implementation here isn't quite consistent with
those in the prior validations chapter.  Refactor for consistency or, if that's
inappropriate, do a better job explaining the changes.
