TODO: Complete this, link it into the main doc.

_ People want to hear about nested attributes.  This is used in a few ways:
  _ accepts_nested_attributes_for

  _ Composite presenters (Signup = Account + User + Project)
    nonpersisted composite + many persisted children

  _ Through models (Task has_many :assignees, through: :assignments)
    persisted parent, join, child

In applications without Ajax, as your domain model grows more complex you might
find that you want to deliver information about more than one model together in
a request - nested attribuets.  Rails provides a facility for conveniently
passing nested attributes through to ActiveRecord and sorting out the
relationships there, `accepts_nested_attributes_for`.

Two common patterns for dealing with nested attributes are through relationships
and composite model presenters.

==== Composite model presenters

Consider a signup form that allows a customer to quickly get started with a
project management application.

They fill out information for their individual user account, as well as
information about the team they represent (and will eventually invite others
users from) and perhaps some information about an initial project.  One way to
model this is to present a `signup` resource that handles creating the correct
User, Team, and Project records.  The implementation would involve a vanilla
`SignupsController` and a `Signup` class that delegates its nested attributes
to their respective models.

While this could be achieved with `accepts_nested_attributes_for`, These
presenter classes are also handy for adding any conditional logic in the
composition, such as a Signup creating a Billing entry for paid Plan levels.
Additionally, the presenter class should be easier to isolation test, compared
to testing the persistence outcomes of `accepts_nested_attributes_for`.  It's
also useful to note that the composite Signup class is not actually persisted;
it represents a convenient abstraction in the domain model.

In this case, it's straightforward to provide an HTTP API endpoint that exposes
the `signups` resource and to model this on the client side as a corresponding
Backbone model.  All of the attributes on the composite resource are at a single
level (not nested), so this is a familiar implementation.

This general pattern is preferable where possible.  It encapsulates the
composite nature of the resource, leaving the fact that it is persisted across
multiple tables as an implementation detail.  This keeps the presentation tier
simpler, unconcerned with the composite nature of the resource.

==== Through relationships

A common place for nested attributes to come up is in `has_many :through`
relationships.  For example, consider a workflow in which you assign multiple
people to a job.  The three domain models are `Job`, `Worker`, and
`Assignment`.

[ruby]
source~~~~
class Job < ActiveRecord::Base
  has_many :assignments
  has_many :workers, :though => :assignments
end

class Assignment < ActiveRecord::Base
  belongs_to :job
  belongs_to :worker
end

class Worker < ActiveRecord::Base
  has_many :assignments
  has_many :jobs, :through => :assignments
end
source~~~~

As we write more interactive web applications, one relevant change is that
pages often have several independently usable sections which update more
frequently and fluidly compared to the previous synchronous full page
submissions.  To support this more finely-grained interface, the client-side
implementation and the HTTP JSON API are often more finely grained to match,
resulting in fewer bulk submissions with composite data structures.

==== Bulk associations (accepts_nested_attributes_for)

However, it's still sometimes valuable to be able to model these.  Let's say
that we have a user interface where we create Jobs and bulk-assign several
workers to the new job all in one form.  We'll use Rails'
`accepts_nested_attributes_for`:

[ruby]
source~~~~
class Job < ActiveRecord::Base
  has_many :assignments
  has_many :workers, :though => :assignments
  accepts_nested_attributes_for :assignments
end
source~~~~

This allows us, in Ruby, to set `@job.assignments_attributes = [{}, {}, ...]`
with an Array of Hashes, each containing attributes for a new `Assignment`,
the join model.

The JSON going over the HTTP request will look like:

[javascript]
source~~~~
/* POST /api/v1/jobs */
{
  name: "Move cardboard boxes to new warehouse",
  description: "Move boxes from closet C3 to warehouse W2",
  assignmment_attributes: [
    { worker_id: 1 },
    { worker_id: 3 },
    { worker_id: 5 }
  ]
}
source~~~~

This is a simplified perspective of the relationship, a direct nesting of
`Worker`s inside the `Job`.  We can mostly ignore the `Assignment` join model
in Backbone, and can just model this nested association directly.  We'll use a
`Job` Backbone model containing an `Workers` collection:

[javascript]
source~~~~
MyApp = {};
MyApp.Models = {};
MyApp.Collections = {};

MyApp.Models.Worker = Backbone.Model.extend({
});

MyApp.Collections.Workers = Backbone.Collection.extend({ 
  model: ExampleApp.Models.Worker
});

MyApp.Models.Job = Backbone.Model.extend({
  urlRoot: '/api/v1/jobs',

  initialize: function() {
    this.workers = new MyApp.Collections.Workers();
  },

  toJSON: function() {
    var json = _.clone(this.attributes);
    json.assignment_attributes = this.workers.map(function(worker) {
      return { worker_id: worker.id };
    });
    return json;
  }
});
source~~~~

Now, you can add workers directly to the job:

[javascript]
source~~~~
var worker3 = new MyApp.Models.Worker({ id: 3 });
var worker5 = new MyApp.Models.Worker({ id: 5 });

var job = new MyApp.Models.Job();
job.set({ title: "Raise barn walls" });
job.workers.add(worker3);
job.workers.add(worker5);

JSON.stringify(job.toJSON()) // Results in:
                             //
                             // {
                             //   "title":  "Raise barn walls",
                             //   "assignment_attributes": [
                             //     {"worker_id":3},
                             //     {"worker_id":5}
                             //   ]
                             // }
source~~~~
