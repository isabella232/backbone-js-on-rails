=== Uploading attachments

While Ruby gems such as paperclip make the API for attaching files to models
very similar to the standard ActiveModel attribute persistence API, attaching
files to Backbone models is not quite as straightforward.  In this section,
we'll take a look at the general approach for attaching files, and then examine
the specific implementation used in the example application.

==== Saving files along with attributes

When you save a Backbone model, its attributes are sent to the server via
Backbone.sync.  It would be ideal to treat file uploads in the same fashion,
storing the files as attributes on the client-side Backbone model and uploading
them, along with all the other attributes, when then model is saved.

+Backbone.Model#save+ delegates to +Backbone.sync+ which, by default, transmits
data using +$.ajax+ with a +dataType+ of +json+.

We _could_ send files along here, too, using the HTML5 File API to read the
file data and send it serialized inside the JSON payload.  This would require
us to make server-side changes to parse the file from JSON, and there is no IE
support for the File API as of IE9.  (http://caniuse.com/fileapi)

A slightly more sophisticated approach could use the FormData API and
XMLHttpRequest Level 2 to serialize attributes instead, transmitting them to
the server as multipart/form-data, which already has a defined serialization
for files.  This would allow you to work without modifying your server, but
still leaves IE completely unsupported.

To support the broadest set of browsers, but still deliver file uploads in the
same request as attributes, you use a hidden iframe technique.  Probably the
most transparent approach is to take advantage of jQuery's
[AJAX Transport](http://api.jquery.com/extending-ajax/#Transports)
functionality with the
[jquery.iframe-transport.js](http://cmlenz.github.com/jquery-iframe-transport/)
plugin.  There is a caveat with this approach too, however, as we cannot get at
the response headers, breaking automatic content type detection and, more
importantly, breaking the use of HTTP response codes to indicate server-side
errors.  This approach would deliver the smoothest user experience, at the cost
of more integration code.

The [Remotipart gem](https://github.com/leppert/remotipart) provides some such
conventions for delivering response information back to the client-side,
although the use-case is slightly different and the library uses the
+jquery.form.js+ +ajaxSubmit()+ function to perform an iframe upload, instead
of the smaller +jquery.iframe-transport.js+ plugin.

TODO: A related concern is previewing images on the client-side before uploading,
nice-to-have to touch on this.

==== Separating file upload and model persistence

The general approach we'll take is to separate the file upload request from the
model persistence requests.  The server will respond to the upload with an
identifier, which we can use on the client side to populate an attribute on a
Backbone model, whether it is a new model or an existing one.

This does mean that you can have unclaimed attachments if the end user leaves
the page before saving the parent model, and these should be periodically swept
if disk usage is an issue.

When modeling this from the Rails side, you can choose to persist the file
upload identifier (e.g. the local path or S3 URL) on one of your models
directly, or you can break the attachment out into its own ActiveRecord model
and store a foreign key relation on your primary model.  For our example
we'll do the latter, adding an +Attachment+ model and resource to the app.

We'll use the HTML5 File API because it's a straightforward approach to illustrate.

==== Example, Step 1: Upload Interface

In our example task management app, we'd like for the owner of a task to attach
several images to each task.  We want uploads to happen in the task detail view,
and for the uploads to appear in-page as soon as they are uploaded.  We don't
need to display uploads on the index view.

First, let's write an acceptance test to drive the functionality:

[text]
source~~~~
include::../../example_app/features/users/attach_file_to_task.feature[]
source~~~~

The first failures we get are from the lack of upload UI.  We'll drop down to
unit tests to drive this out:

[javascript]
source~~~~
include::../../example_app/spec/javascripts/views/task_show_spec.js[]
source~~~~

Then, we'll add the upload form to the TaskShow view to the `tasks/show.jst.ejs`
template, so the UI elements are in place:

[html]
source~~~~
include::../../example_app/app/assets/templates/tasks/show.jst.ejs[]
source~~~~

Once our units pass, we run the acceptance tests again. The next failure we see
is that nothing happens upon upload.  We'll drop down to Jasmine here to write
a spec for uploading that asserts the correct upload request is issued:

[javascript]
source~~~~
it("uploads the file when the upload method is called", function() {
  view.upload();
  expect(this.requests.length).toEqual(1);
  expect(this.requests[0].requestBody.constructor).toEqual(FormData);
});

it("uploads an attachment for the current task", function() {
  view.upload();
  expect(this.requests[0].url).toEqual("/tasks/1/attachments.json");
});
source~~~~

And implement using the +uploader.js+ library:

[javascript]
source~~~~
render: function () {
  // ...
  this.attachUploader();
  return this;
},

// ...

attachUploader: function() {
  var uploadUrl = "/tasks/" + this.model.get('id') + '/attachments.json';

  this.uploader = new uploader(this.uploadInput(), {
    url:      uploadUrl,
    success:  this.uploadSuccess,
    prefix:   'upload'
  });
},
source~~~~

The acceptance tests still aren't passing, and a little digging will reveal
that we need to manually set the CSRF token on the upload request.  Normally,
this would be set by +jquery_ujs.js+ with a jQuery AJAX prefilter, but the
upload code we are using manually constructs an +XMLHttpRequest+ instead of
using +$.+ajax, so that it may bind to the +onprogress+ event.

We write a spec:

[javascript]
source~~~~
it("sets the CSRF token for the upload request", function() {
  view.upload();
  var expectedCsrfToken = $('meta[name="csrf-token"]').attr('content');
  expect(this.requests[0].requestHeaders['X-CSRF-Token']).toEqual(expectedCsrfToken);
});
source~~~~

And add the CSRF token implementation at the end of +attachUploader+:

[javascript]
source~~~~
attachUploader: function() {
  // ...

  this.uploader.prefilter = function() {
    var token = $('meta[name="csrf-token"]').attr('content');
    if (token) this.xhr.setRequestHeader('X-CSRF-Token', token);
  };
},
source~~~~

And the spec is green.

==== Example, Step 2: Accept and Persist Uploads in Rails

At this point, we are sending the upload request from the client, but the
server isn't responding, much less persisting the file.  This portion is
vanilla Rails and Paperclip.  We create an +Attachment+ model, route, and
controller, adding the [paperclip gem](http://rubygems.org/gems/paperclip) and
configuring it to support uploads.

TODO: Add links to "model", "route", "controller" to the example files
      How to do this?  With local document links? http://www.methods.co.nz/asciidoc/userguide.html#_linking_to_local_documents
      Or with full github links like https://github.com/thoughtbot/backbone-js-on-rails/tree/master/app/assets/javascripts/ ?

Now, the attachments are uploaded to the server.  The final step is to display
attachments to the user.

==== Example, Step 3: Display Uploaded Files

For structuring the attachments in Backbone, we want to be able to do something
like the following:

[html]
source~~~~
<% this.task.attachments.each(function(attachment) { %>
  Attached: <img src="<%= attachment.get('upload_url')" /> %>
<% }); %>
source~~~~

So, the Task model will have attachments property that is instantiates with an
AttachmentsCollection instance.

We're providing a JSON represenatation rooted at the Task model using
[Rabl](https://github.com/nesquena/rabl), which we discussed previously in
"Implementing the API: presenting the JSON".

TODO: How can I internally link that ^ ?

[ruby]
source~~~~
include::../../example_app/app/views/tasks/show.json.rabl[]
source~~~~

We also tell Rabl to suppress the root JSON node, much
like we did with `ActiveRecord::Base.include_root_in_json`:

[ruby]
source~~~~
# config/initializers/rabl_init.rb
Rabl.configure do |config|
  config.include_json_root = false
end
source~~~~

We can test drive the attachment display from Jasmine, see task_show_with_attachments_spec.js:

[javascript]
source~~~~
include::../../example_app/spec/javascripts/views/task_show_with_attachments_spec.js[]
source~~~~

We'll represent attachments as an associated collection on Task, so we'll need
a Backbone model and collection for attachments, too.  First, the Task model
should parse its JSON to populate the associated attachments.  Test drive that
in the ExampleApp.Models.Tasks Jasmine spec:

[javascript]
source~~~~
include::../../example_app/spec/javascripts/models/task_spec.js[]
source~~~~

The first failures reference the Backbone Attachment model and Attachments
collection, so we add those, driving the collection out with a spec.

TODO: Add links to internal example files for model and collection and
collection spec, above.

Now, we can implement the Task model's JSON parsing to populate its associated
attachments:

[javascript]
source~~~~
ExampleApp.Models.Task = Backbone.Model.extend({
  initialize: function() {
    this.bind("change:attachments", this.parseAttachments);
    this.parseAttachments();
  },

  parseAttachments: function() {
    this.attachments = new ExampleApp.Collections.Attachments(this.get('attachments'));
  },

  // ...

});
source~~~~

At this point, we return back to the acceptance test, and it's fully passing.
