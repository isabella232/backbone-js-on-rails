=== Uploading attachments

While Ruby gems such as paperclip make the API for attaching files to models
very similar to the standard ActiveModel attribute persistence API, attaching
files to Backbone models is not quite as straightforward.  In this section,
we'll take a look at the general approach for attaching files, and then examine
the specific implementation used in the example application.

==== Saving files along with attributes

When you save a Backbone model, its attributes are sent to the server via
Backbone.sync.  It would be ideal to treat file uploads in the same fashion,
storing the files as attributes on the client-side Backbone model and uploading
them, along with all the other attributes, when then model is saved.

+Backbone.Model#save+ delegates to +Backbone.sync+ which, by default, transmits
data using +$.ajax+ with a +dataType+ of +json+.

We _could_ send files along here, too, using the HTML5 File API to read the
file data and send it serialized inside the JSON payload.  This would require
us to make server-side changes to parse the file from JSON, and there is no IE
support for the File API as of IE9.  (http://caniuse.com/fileapi)

A slightly more sophisticated approach could use the FormData API and
XMLHttpRequest Level 2 to serialize attributes instead, transmitting them to
the server as multipart/form-data, which already has a defined serialization
for files.  This would allow you to work without modifying your server, but
still leaves IE completely unsupported.

To support the broadest set of browsers, but still deliver file uploads in the
same request as attributes, you use a hidden iframe technique.  Probably the
most transparent approach is to take advantage of jQuery's
[AJAX Transport](http://api.jquery.com/extending-ajax/#Transports)
functionality with the
[jquery.iframe-transport.js](http://cmlenz.github.com/jquery-iframe-transport/)
plugin.  There is a caveat with this approach too, however, as we cannot get at
the response headers, breaking automatic content type detection and, more
importantly, breaking the use of HTTP response codes to indicate server-side
errors.  This approach would deliver the smoothest user experience, at the cost
of more integration code.

TODO: I believe that integration code is largely provided by
https://github.com/leppert/remotipart/tree/master/lib/remotipart, which uses
jquery.form.js' ajaxSubmit to do async upload via iframe, and provides
Rails helpers.

TODO: A related concern is previewing images on the client-side before uploading,
nice-to-have to touch on this.

==== Separating file upload and model persistence

The general approach we'll take is to separate the file upload request from the
model persistence requests.  The server will respond to the upload with an
identifier, which we can use on the client side to populate an attribute on a
Backbone model, whether it is a new model or an existing one.

This does mean that you can have unclaimed attachments if the end user leaves
the page before saving the parent model, and these should be periodically swept
if the disk usage is an issue.

When modeling this from the Rails side, you can choose to persist the file
upload identifier (e.g. the local path or S3 URL) on one of your models
directly, or you can break the attachment out into its own ActiveRecord model
and store a foreign key relation on your primary model.  For our example
we'll do the latter, adding an +Attachmentment+ model and resource to the app.

We'll use the HTML5 File API because it's a straightforward approach to illustrate.

TODO: If there's time, revisit the upload section to provide better browser
compatibility.

==== Example: Attaching images to Tasks

In our example task management app, we'd like for the owner of a task to attach
several images to each task.  We want uploads to happen in the task detail view,
and for the uploads to appear in-page as soon as they are uploaded.  We don't
need to display uploads on the index view.

First, let's write an acceptance test to drive the functionality:

[text]
source~~~~
include::../../example_app/features/users/attach_file_to_task.feature[]
source~~~~

The first failures we get are from the lack of upload UI.  We'll drop down to
unit tests to drive this out:

[javascript]
source~~~~
include::../../example_app/spec/javascripts/views/task_show_spec.js[]
source~~~~

Then, we'll add the upload form to the TaskShow view to the `tasks/show.jst.ejs`
template, so the UI elements are in place:

[html]
source~~~~
include::../../example_app/app/assets/templates/tasks/show.jst.ejs[]
source~~~~

Once our units pass, we run the acceptance tests again. The next failure we see
is that nothing happens upon upload.  We'll drop down to Jasmine here to write
unit tests for the uploading:

[javascript]
source~~~~
include::../../example_app/spec/javascripts/views/task_show_uploading_spec.js[]
source~~~~

TODO: Finish outline:

* NB: You can't overwrite input.files (a FileList instance), so you'll have to
provide a point of fake injection; in our case, TaskShow#uploadInput().
* Make it pass by adding uploader.js and adding uploader logic to TaskShow view
* Now we are uploading, but the server isn't accepting/persisting
* Test-drive persistence on server side:
** Add paperclip gem
** Create Attachment model, route, controller.  Test-drive the units.
** NB on integration point: XHR requests from BB to Rails needs CSRF tokens, so inject
   as uploader.prefilter, analagous to $.ajaxPrefilter http://api.jquery.com/extending-ajax/
* Next, display existing attachments to the user.

For structuring the attachments in Backbone, we want to be able to do something
like the following:

[html]
source~~~~
<% this.task.attachments.each(function(attachment) { %>
  Attached: <img src="<%= attachment.get('upload_url')" /> %>
<% }); %>
source~~~~

So, the Task model will have attachments property that is instantiates with an
AttachmentsCollection instance.

NOTE: This is written assuming that the model_relationships.asc chapter came
first and discusses how to structure the JSON, which is bundling the comments
and attachments associations under the Task's JSON representation.  It should
introduce and discuss using Rabl, too. Depending on how in-depth that section
is, we may need to write more here to contextualize.

We're providing a JSON represenatation using Rabl, rooted at the Task:

[ruby]
source~~~~
include::../../example_app/app/views/tasks/show.json.rabl[]
source~~~~

Note that you have to have to tell Rabl to suppress the root JSON node, just
like we suppress the root JSON node in ActiveRecord with
`ActiveRecord::Base.include_root_in_json = false`:

[ruby]
source~~~~
# config/initializers/rabl_init.rb
Rabl.configure do |config|
  config.include_json_root = false
end
source~~~~

We can test drive the attachment display from Jasmine, see task_show_spec.js:

[javascript]
source~~~~
include::../../example_app/spec/javascripts/views/task_show_with_attachments_spec.js[]
source~~~~

This depends on parsing the JSON from the client side, so test drive that for
the ExampleApp.Models.Tasks Jasmine spec:

* Include spec/javascripts/models/task_spec.js
* Implement in task.js
* TDD Attachments collection and Attachment model
* Implement Attachments collection and Attachment model
* Green?
