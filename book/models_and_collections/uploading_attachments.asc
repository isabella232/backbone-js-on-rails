=== Uploading attachments (Chapter unstarted)

Notes:

If you upload to a backbone model, you can't do it in a typical async request.
As in, someBackboneModel.save() can't just send a file to the server like other
attributes. We save the attachment in a separate request, and then just swap in
an attachment id on the model. This does mean that you can have "unclaimed"
attachments if somebody bails before saving the parent model, but that's not
really an issue.


Implementation:



commit ca8363b782195f1a514b53c7b483f167c6835d7f
Author: Jason Morrison <jmorrison@thoughtbot.com>
Date:   Thu Nov 3 16:44:12 2011 -0400
    wip: StoryShow view has an upload input, and a button to send the upload.
* Add the TaskShow view that enables upload
* Include a file input as part of the template, app/assets/templates/tasks/show.jst.ejs
* Encapsulate the uploading (uploader.js)
* Drive out with cucumber features
* Drop down to Jasmine specs, spec the view, and use sinon fake XHR to verify the upload.
  * NB: You can't overwrite input.files (a FileList instance), so you'll have to
    provide a point of fake injection; in our case, TaskShow#uploadInput().

This approach assumes XHR2 (at least FormData) so no IE, but it's a simple
implementation:
* https://github.com/mockenoff/HTML5-AJAX-File-Uploader
* https://developer.mozilla.org/en/XMLHttpRequest/FormData


commit 05263e382fe34626aee1810fc1c9e2deb615a1a9
Author: Jason Morrison <jmorrison@thoughtbot.com>
Date:   Thu Nov 3 17:39:40 2011 -0400
    wip: upload attachment
* Now it's time to persist the upload on the server side
* Add paperclip gem
* Create Attachment model, route, controller.  Test-drive the units.
* Integration point: XHR requests from BB to Rails needs CSRF tokens, so inject
  as uploader.prefilter, analagous to $.ajaxPrefilter http://api.jquery.com/extending-ajax/

Next, display existing attachments to the user.

For structuring the attachments in Backbone, we want to be able to:

<% this.task.attachments.each(function(attachment) { %>
  Attached: <%= attachment.upload_file_name %>
<% }); %>

So, the Task model will have attachments property that is instantiates with an
AttachmentsCollection instance.

NOTE: This is written assuming that the model_relationships.asc chapter came
first and discusses how to structure the JSON, which is bundling the comments
and attachments associations under the Task's JSON representation.  It should
introduce and discuss using Rabl, too. Depending on how in-depth that section
is, we may need to write more here to contextualize.

We're providing a JSON represenatation using Rabl, rooted at the Task:

TODO: Link up actual file from example_app
[ruby]
source~~~~
# /app/views/tasks/show.json.rabl
attributes :id, :created_at, :updated_id, :title, :complete, :user_id

child :attachments do
  attributes :id, :created_at, :updated_id, :upload_file_name, :upload_url
end

child :comments do
  attributes :id, :created_at, :updated_id, :body
end
source~~~~

We can test drive the attachment display from Jasmine, see task_show_spec.js:

[javascript]
source~~~~
describe("ExampleApp.Views.TaskShow for a task with attachments", function() {
  // ...
  // TODO: Import the spec file portion
});
source~~~~

This depends on parsing the JSON from the client side, so test drive that for
the ExampleApp.Models.Tasks Jasmine spec:

TODO: Show overridden ExampleApp.Models.Task#parse
