<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="master.css" type="text/css" />
    <title>Organization</title>
  </head>

  <body>
    <div class="nav" id="navheader">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="introduction_section_unstarted_.html">Prev</a><br/>
         Introduction (section unstarted)
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         <strong>Backbone.js on Rails</strong>
        
      </td><td width="33%" align="right">
        
          <a href="rails_integration.html">Next</a><br/>
          Rails Integration
        
      </td></tr>
    </table>
    </div>

    <hr/>

    <div class="content">
      <div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a id="_organization"></a>Organization</h2></div></div></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_backbone_js_and_mvc"></a>Backbone.js and MVC</h3></div></div></div>
<p>Model–View–Controller (MVC) is an architectural pattern used in many
applications to isolate "domain logic" (the application logic for the user)
from the user interface (input and presentation).</p>
<div class="figure">
<a id="d0e84"></a><p class="title"><b>Figure 1. Model-view-controller concept</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="image/MVCDiagram.png" alt="image/MVCDiagram.png"></div></div>
</div>
<br class="figure-break"><p>In the above diagram a solid line represents a direct association and a dashed
line represents an indirect association (for example, via an observer).</p>
<p>As a user of Rails, you’re likely already familiar with the concept of MVC and
the benefits that the separation of concerns can give you. However, Rails itself
is not doing "traditional" MVC. A traditional MVC is event-based. This means
that the views trigger events which the controller figures out what to do with.
It can be argued that the requests generated by the browser are the "events" in
Rails; however, due to the single-threaded, request-response nature of the web,
the control flow between the different levels of MVC is much more
straightforward.</p>
<p>Given that Javascript has events, and that much of the interactions between the
different components of Backbone.js in the browser are not limited to
request/response, programming with Backbone.js is in a lot of ways more like
working with a traditional MVC architecture.</p>
<p>That said, technically speaking, Backbone.js is <span class="emphasis"><em>not</em></span> MVC, and the creators of
Backbone.js acknowledged this when they renamed Controllers to Routers in
version 0.5.0.</p>
<p>What is Backbone.js then, if not MVC? Technically speaking, it’s just the
Models and the Views with a Router to handle flow between them. In Backbone.js
the views will handle many of the aspects that controllers would typically
handle, such as actually figuring out what to do next and what to render.</p>
<p>While you could do it, the benefit of actually introducing a Controller in your
application would be limited, and the more pragmatic approach is to realize the
great organization that Backbone.js gives you is much better than what you had
before. The fact that it doesn’t have a nice name, or strict adherence to a
pattern, isn’t worth worrying about.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_what_goes_where"></a>What Goes Where</h3></div></div></div>
<p>Part of the initial learning curve of Backbone.js can be figuring out what goes
where, and mapping it to your expectations set by working with Rails. In Rails
we have Models, Views, Controllers, and Routers. In Backbone.js, we have
Models, Collections, Views, Templates, and Routers.</p>
<p>The models in Backbone.js and Rails are analogous. Backbone.js collections are
just ordered sets of models.  Because it lacks controllers, Backbone.js routers
and views work together to pick up the functionality provided by Rails
controllers. Finally, in Rails, when we say views, we actually mean templates.
In Backbone.js, however, you have a separation between the view and templates.</p>
<p>Once you introduce Backbone.js into your stack, you grow the layers in your
stack by four levels. This can be daunting at first, and frankly, at times it
can be difficult to keep everything going on in your application straight.
Ultimately, the additional organization and functionality of Backbone.js
outweighs the costs, so let’s break it down.</p>
<div class="itemizedlist">
<p class="title"><b>Rails</b></p>
<ul type="disc">
<li>
Model
</li>
<li>
Controller
</li>
<li>
View
</li>
</ul>
</div>
<div class="itemizedlist">
<p class="title"><b>Backbone.js</b></p>
<ul type="disc">
<li>
Model and Collection
</li>
<li>
Router
</li>
<li>
View
</li>
<li>
Template
</li>
</ul>
</div>
<p>In a typical Rails and Backbone.js application, the initial interaction between
the layers will be as follows:</p>
<div class="itemizedlist"><ul type="disc">
<li>
A request from a user comes in the <span class="strong"><strong>Rails router</strong></span> identifies what should
  handle the request based on the URL
</li>
<li>
The <span class="strong"><strong>Rails controller action</strong></span> to handle the request is called, some initial
  processing may be performed
</li>
<li>
The <span class="strong"><strong>Rails view template</strong></span> is rendered and returned to the user’s browser
</li>
<li>
The <span class="strong"><strong>Rails view template</strong></span> will include <span class="strong"><strong>Backbone.js initialization</strong></span>, usually
  this is populating some <span class="strong"><strong>Backbone collections</strong></span> as sets of <span class="strong"><strong>Backbone models</strong></span>
  with JSON data provided by the <span class="strong"><strong>Rails view</strong></span>
</li>
<li>
The <span class="strong"><strong>Backbone.js router</strong></span> determines which of its methods should handle the
  display based on the URL
</li>
<li>
The <span class="strong"><strong>Backbone.js router</strong></span> method calls that method, some initial processing
  may be performed, and one or more <span class="strong"><strong>Backbone.js views</strong></span> are rendered
</li>
<li>
The <span class="strong"><strong>Backbone.js view</strong></span> reads <span class="strong"><strong>templates</strong></span> and uses <span class="strong"><strong>Backbone.js</strong></span> models to
  render itself onto the page
</li>
</ul></div>
<p>At this point, the user will see a nice page in their browser and be able to
interact with it. The user interacting with elements on the page will trigger
actions to be taken at any level of the above sequence: <span class="strong"><strong>Backbone.js model</strong></span>,
<span class="strong"><strong>Backbone.js views</strong></span>, <span class="strong"><strong>Backbone.js router</strong></span>, or requests to the remote server.</p>
<p>Requests to the remote server may be any one of the following:</p>
<div class="itemizedlist"><ul type="disc">
<li>
At the <span class="strong"><strong>Backbone.js model</strong></span> or <span class="strong"><strong>Backbone.js collection</strong></span> level, communicating
  with Rails via JSON.
</li>
<li>
Normal Ajax requests, not using Backbone.js at all.
</li>
<li>
Normal requests that don’t hit Backbone.js and trigger a full page reload.
</li>
</ul></div>
<p>Which of the above remote server interactions you use will depend upon the
desired result, and the type of user interface. This book should help you
understand which interaction you’ll want to choose for each portion of your
application.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_namespacing_your_application"></a>Namespacing your application</h3></div></div></div>
<p>You will want to create an object in Javascript for your Backbone.js
application to reside. This variable will serve as a namespace for your
Backbone.js application. Namespacing all of the Javascript is desirable to
avoid potential collisions in naming. For example, it’s possible that a
Javascript library you want to use might also create a Task variable. If you
didn’t namespace your Task model then this would conflict.</p>
<p>This variable includes a place to hold Models, Collections, Views, and Routes,
and an init method which will be called to initialize the application. It’s
very common to create a new Router in the init function, and
Backbone.history.start() must be called in order to route the initial URL.
This app variable will look like the following.</p>
<pre class="programlisting">var ExampleApp = {
  Models: {},
  Collections: {},
  Views: {},
  Routers: {},
  init: function() {
    new ExampleApp.Routers.Tasks();
    Backbone.history.start();
  }
};</pre>
<p>You can find this file in the example app in
<code class="literal">app/assets/javascripts/example_app.js</code>.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_mixins"></a>Mixins</h3></div></div></div>
<p>Backbone provides a basic mechanism for inheritance.  Often you’ll want to build a collection of related, reusable behavior and include that in several classes that already inherit from a Backbone base class.  In these cases, you’ll want to use a <a class="ulink" href="http://en.wikipedia.org/wiki/Mixin" target="_top">mixin</a>.</p>
<p>Backbone includes <a class="ulink" href="http://documentcloud.github.com/backbone/#Events" target="_top">Backbone.Events</a> as an example of a mixin.</p>
<p>Here, we create a mixin named <code class="literal">Observer</code> that contains behavior for binding to events in a fashion that can be cleaned up later:</p>
<pre class="programlisting">var Observer = {
  bindTo: function(source, event, callback) {
    source.bind(event, callback, this);
    this.bindings = this.bindings || [];
    this.bindings.push({ source: source, event: event, callback: callback });
  },

  unbindFromAll: function() {
    _.each(this.bindings, function(binding) {
      binding.source.unbind(binding.event, binding.callback);
    });
    this.bindings = [];
  }
};</pre>
<p>We can mix <code class="literal">Observer</code> into a class by using Underscore’s <code class="literal">_.extend</code> on the prototype of that class:</p>
<pre class="programlisting">SomeCollectionView = Backbone.Collection.extend({
  initialize: function() {
    this.bindTo(this.collection, "change", this.render);
  },

  leave: function() {
    this.unbindFromAll(); // calling a method defined in the mixin
    this.remove();
  }
});

_.extend(SomeCollectionView.prototype, Observer);</pre>
</div>
</div>

    </div>

    <hr/>

    <div class="nav" id="navfooter">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="introduction_section_unstarted_.html">Prev</a><br/>
         Introduction (section unstarted)
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         Backbone.js on Rails
        
      </td><td width="33%" align="right">
        
          <a href="rails_integration.html">Next</a><br/>
          Rails Integration
        
      </td></tr>
    </table>
    </div>
  </body>
</html>
