<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="master.css" type="text/css" />
    <title>Introduction</title>
  </head>

  <body>
    <div class="nav" id="navheader">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="index.html">Prev</a><br/>
         Main
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         <strong>Backbone.js on Rails</strong>
        
      </td><td width="33%" align="right">
        
          <a href="getting_up_to_speed.html">Next</a><br/>
          Getting up to speed
        
      </td></tr>
    </table>
    </div>

    <hr/>

    <div class="content">
      <div class="titlepage">
<div><div><h2 class="title">
<a id="d0e3"></a>Backbone.js on Rails</h2></div></div>
<hr>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a id="_introduction"></a>Introduction</h2></div></div></div>
<p>Modern web applications are increasingly rich, shifting their complexity onto
the client side.  While there are very well-understood approaches embodied in
mature frameworks to organize server-side code, frameworks for organizing your
client-side code are newer and generally still emerging.  Backbone is one such
library that provides a set of structures to help you organize your JavaScript
code.</p>
<p>Libraries like jQuery have done a great deal to help abstract inconsistencies
across browsers and provide a high-level API for making AJAX requests and
performing DOM manipulation, but larger and richer client-side applications that
lack decoupled and modular organizational structures often fall to the same few
kinds of technical debt.</p>
<p>These apps are often highly asynchronous and the path of least resistance
implementation is often to have deeply nested callbacks to describe asynchronous
behavior, with nested <code class="literal">$.ajax</code> calls and success/failure conditional concerns
going several layers deep.</p>
<p>Second, rich client-side applications also often involve a layer of state and
logic on the client side.  One tempting way to implement this is to store domain
objects or business logic state in the DOM.  However, relying on the DOM as a
persistence layer - stashing your application’s data in hidden <code class="literal">&lt;div&gt;</code> elements
that you clone and graft and toggle into and out of view, or reading and writing
to lengthy sets of HTML <code class="literal">data-*</code> attributes - can quickly get cumbersome,
repetitive, and confusing.</p>
<p>A third common feature in rich client-side apps is presenting multiple views on
a single domain object.  Consider a web conferencing application with multiple
views on the members of your contact list - each contact is rendered in brief
inside a list view, and in more specificity in a detail view.  Additionally,
your conference call history includes information about the people who
participated.  Each time an individual contact’s information changes, this
information needs to cascade to all the view representations.</p>
<p>Often this leads to a tight coupling of persistence and presentation: invoking
<code class="literal">$.ajax</code> to save a user’s update and then updating several specific DOM elements
upon success.</p>
<p>Perhaps you’ve seen code like this:</p>
<pre class="programlisting">TODO: Contact app example, $.ajax nested a few layers deep, updating hidden DOM
elements or a global object e.g. <b class="hl-string"><i style="color:red">"window.contactsJSON"</i></b> as persistence, then
cascading update to several views</pre>
<p>What if it could look like this instead:</p>
<pre class="programlisting">TODO: Backbone refactoring of above example.</pre>
<p>By separating business logic, persistence, and presentation concerns, and
providing a decoupled, event-driven way to cascade changes through a system of
observers, each module of code is more well-encapsulated and expresses a
cohesive set of responsibilities without being coupled to outside concerns.
Your application code becomes easier to test, modify, and extend, and your
application can manage its complexity while its feature set grows.</p>
<p>It’s important to note that Backbone is a library, not a framework.  Though the
distinction may seem subtle, it’s largely one of intent and purpose.  If you’re
coming from a Rails background, you understand that a large part of Rails' value
is expressing and implementing highly-opinionated conventions that guide
development decisions.  Backbone doesn’t do this - conventions for rich
client-side applications aren’t as well set-down and individual use cases vary
more widely.  Instead of trying to serve as "the one way" or an opinionated
framework like Rails, Backbone provides a set of structures that help you
organize your application by building your own framework with its own set of
conventions.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_why_use_backbone_js"></a>Why use Backbone.js</h3></div></div></div>
<p>Web applications are pushing an increasing amount of behavior to the client.  The user experience can be quite a pleasure, but deeply nesting callbacks and relying on the DOM for app state aren’t.  There is a host of new JavaScript client-side frameworks blossoming, and you have no shortage of choice.</p>
<p>From "least similar to Backbone" to "most similar to Backbone", here are a few of the options:</p>
<p>Are you building a desktop-like application?  Would you benefit from a rich library of existing UI controls?  Check out Cappuccino or SproutCore.</p>
<p>Are you very comfortable with the model-view-view model (MVVM) pattern, perhaps from Microsoft WCF or Silverlight?  Take a look at Knockout.js, which has very robust object graph dependency tracking and declarative bindings between markup and view models.</p>
<p>Do you want a soup-to-nuts client-side framework, with a jQuery feel (and dependency), with generators, dependency management, builds, testing, and more?  JavaScriptMVC provides all of this, with an MVC core that supports observables and data transports like JSON over REST.  You can pick and choose a subset of functionality.</p>
<p>Server synchronization and data validation play a central role in structuring your application, and an opinion on it is one of the central design choices of Spine.js. Does the client generally take precedence, handling all its own validations, immediately returning to the user, and updating the server asynchronously?  Or do you have significant server-side processing and validation?  Spine.js strongly favors a client-centric approach, with a decoupled server.  There are a few other API differences, but in other respects Spine is very similar to Backbone.</p>
<p>Backbone favors a pared-down and flexible approach.  There is very little in the way of inheritance or class library, and the code you write ends up feeling very much like JavaScript.  It does not prescribe much in the way of favoring a client over server, or a particular server syncronization approach.  Although this means that you may need to write some of your own conventions, Backbone is built with that in mind: the source is small, very well annotated, and modularly designed so that it is easy to change.  It is small and flexible enough to make it pleasant to introduce into an existing application, but provides enough convention and structure to help you organize your JavaScript.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_the_example_application"></a>The Example Application</h3></div></div></div>
<p>Rails 3.1.0.rc5</p>
<p>Ruby 1.9.2</p>
<p>Backbone.js and Underscore.js are the non-minified versions. This is for
informational purposes, but also because the Rails 3.1 asset pipeline will
compress and minify them.</p>
<p>While Rails 3.1 defaults to CoffeeScript, we have decided to make all of the
example code normal Javascript as we believe that will be the most understandable to
the current readers.</p>
</div>
</div>
    </div>

    <hr/>

    <div class="nav" id="navfooter">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="index.html">Prev</a><br/>
         Main
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         Backbone.js on Rails
        
      </td><td width="33%" align="right">
        
          <a href="getting_up_to_speed.html">Next</a><br/>
          Getting up to speed
        
      </td></tr>
    </table>
    </div>
  </body>
</html>
