<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<article lang="en">
<articleinfo>
    <title>Backbone.js on Rails</title>
</articleinfo>
<section id="_preface_section_unstarted">
<title>Preface (section unstarted)</title>
</section>
<section id="_getting_up_to_speed_section_unstarted">
<title>Getting up to speed (section unstarted)</title>
<section id="_backbone_js_online_resources">
<title>Backbone.js online resources</title>
</section>
<section id="_javascript_online_resources_and_books">
<title>JavaScript online resources and books</title>
</section>
</section>
<section id="_introduction_section_unstarted">
<title>Introduction (section unstarted)</title>
<section id="_why_use_backbone_js">
<title>Why use Backbone.js</title>
</section>
<section id="_when_not_to_use_backbone_js">
<title>When not to use Backbone.js</title>
</section>
<section id="_why_not_sproutcore_cappuccino_knockout_js_spine_etc">
<title>Why not SproutCore, Cappuccino, Knockout.js, Spine, etc.</title>
</section>
</section>
<section id="_organization">
<title>Organization</title>
<section id="_backbone_js_and_mvc">
<title>Backbone.js and MVC</title>
<simpara>Model–View–Controller (MVC) is an architectural pattern used in many
applications to isolate "domain logic" (the application logic for the user)
from the user interface (input and presentation).</simpara>
<figure><title>Model-view-controller concept</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="image/MVCDiagram.png"/>
  </imageobject>
  <textobject><phrase>image/MVCDiagram.png</phrase></textobject>
</mediaobject>
</figure>
<simpara>In the above diagram, a solid line represents a direct association, a dashed
line an indirect association (for example, via an observer).</simpara>
<simpara>As a user of Rails, you&#8217;re likely already familiar with the concept of MVC and
the benefits that the separation of concerns can give you. However, Rails
itself is not doing "traditional" MVC. A traditional MVC is event-based. This
means that the views trigger events which the controller figures out what to do
with. It can be argued that the requests generated by the browser are the
"events" in Rails, however, due to the single-threaded, request-response nature
of the web, the control flow between the different levels of MVC is much more
straight-forward.</simpara>
<simpara>Given that Javascript has events, and that much of the interactions between the
different components of Backbone.js in the browser are not limited to
request/response, programming with Backbone.js is in a lot of ways more like
working with a traditional MVC architecture.</simpara>
<simpara>That being said, technically speaking, Backbone.js is <emphasis>not</emphasis> MVC, and this was
acknowledged by the creators of Backbone.js when they renamed Controllers to
Routers in version 0.5.0.</simpara>
<simpara>So what is Backbone.js then if not MVC? Technically speaking, it&#8217;s just the
Models and the Views with a Router to handle flow between them. In Backbone.js
the views will handle many of the aspects that controllers would typically
handle, such as actually figuring out what to do next and what to render.</simpara>
<simpara>While you could do it, the benefit of actually introducing a Controller in your
application would be limited, and the more pragmatic approach is to realize the
great organization that Backbone.js gives you is much better than what you had
before. The fact that it doesn&#8217;t have a nice name, or strict adherence to a
pattern, isn&#8217;t worth worrying about.</simpara>
</section>
<section id="_what_goes_where">
<title>What Goes Where</title>
<simpara>Part of the initial learning curve of Backbone.js can be figuring out what goes
where, and mapping it to your expectations set by working with Rails. In Rails
we have Models, Views, Controllers, and Routers. In Backbone.js, we have
Models, Views, Templates, and Routers.</simpara>
<simpara>The models in Backbone.js and Rails are analogous. Because it lacks
controllers, Backbone.js routers and views work together to pick up the
functionality provided by Rails controllers. Finally, in Rails, when we say
views, we actually mean templates. In Backbone.js, however, you have a
separation between the view and templates.</simpara>
<simpara>Once you introduce Backbone.js into your stack, you grow the layers in your
stack by four levels. This can be daunting at first, and frankly, at times it
can be difficult to keep everything going on in your application straight.
Ultimately, the additional organization and functionality of Backbone.js
outweighs the costs, so let&#8217;s break it down.</simpara>
<itemizedlist><title>Rails</title>
<listitem>
<simpara>
Model
</simpara>
</listitem>
<listitem>
<simpara>
Controller
</simpara>
</listitem>
<listitem>
<simpara>
View
</simpara>
</listitem>
</itemizedlist>
<itemizedlist><title>Backbone.js</title>
<listitem>
<simpara>
Model
</simpara>
</listitem>
<listitem>
<simpara>
Router
</simpara>
</listitem>
<listitem>
<simpara>
View
</simpara>
</listitem>
<listitem>
<simpara>
Template
</simpara>
</listitem>
</itemizedlist>
<simpara>In a typical Rails and Backbone.js application, the initial interaction between
the layers will be as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>
A request from a user comes in the <emphasis role="strong">Rails router</emphasis> identifies what should
  handle the request based on the URL
</simpara>
</listitem>
<listitem>
<simpara>
The <emphasis role="strong">Rails controller action</emphasis> to handle the request is called, some initial
  processing may be performed
</simpara>
</listitem>
<listitem>
<simpara>
The <emphasis role="strong">Rails view template</emphasis> is rendered and returned to the user&#8217;s browser
</simpara>
</listitem>
<listitem>
<simpara>
The <emphasis role="strong">Rails view template</emphasis> will include <emphasis role="strong">Backbone.js initialization</emphasis>, usually
  this is populating some <emphasis role="strong">Backbone models</emphasis> with JSON data provided by the
 <emphasis role="strong">Rails view</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
The <emphasis role="strong">Backbone.js router</emphasis> determines which of its methods should handle the
  display based on the URL
</simpara>
</listitem>
<listitem>
<simpara>
The <emphasis role="strong">Backbone.js router</emphasis> method calls that method, some initial processing
  may be performed, and one or more <emphasis role="strong">Backbone.js views</emphasis> are rendered
</simpara>
</listitem>
<listitem>
<simpara>
The <emphasis role="strong">Backbone.js view</emphasis> reads <emphasis role="strong">templates</emphasis> and uses <emphasis role="strong">Backbone.js</emphasis> models to
  render itself onto the page
</simpara>
</listitem>
</itemizedlist>
<simpara>At this point, the user will see a nice page in their browser and be able to
interact with it. The user interacting with elements on the page will trigger
actions to be taken at any level of the above sequence: <emphasis role="strong">Backbone.js model</emphasis>,
<emphasis role="strong">Backbone.js views</emphasis>, <emphasis role="strong">Backbone.js router</emphasis>, or requests to the remote server.</simpara>
<simpara>Requests to the remote server may be any one of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>
At the <emphasis role="strong">Backbone.js model</emphasis> level, communicating with Rails via JSON.
</simpara>
</listitem>
<listitem>
<simpara>
Normal Ajax requests, not using Backbone.js at all.
</simpara>
</listitem>
<listitem>
<simpara>
Normal requests that don&#8217;t hit Backbone.js and trigger a full page reload.
</simpara>
</listitem>
</itemizedlist>
<simpara>Which of the above remote server interactions you use will depend upon the
desired result, and the type of user interface. This book should help you
understand which interaction you&#8217;ll want to choose for each portion of your
application.</simpara>
</section>
<section id="_namespacing_your_application_chapter_unstarted">
<title>Namespacing your application (chapter unstarted)</title>
</section>
</section>
<section id="_rails_integration">
<title>Rails Integration</title>
<section id="_organizing_your_backbone_js_code_in_a_rails_app">
<title>Organizing your Backbone.js code in a Rails app</title>
<simpara>When using Backbone.js in a Rails app, you&#8217;ll have two kinds of
Backbone.js-related assets: classes, and templates.</simpara>
</section>
<section id="_rails_3_0_and_prior">
<title>Rails 3.0 and prior</title>
<simpara>With Rails 3.0 and prior, store your Backbone.js classes in
<literal>public/javascripts</literal>:</simpara>
<screen>public/
  javascripts/
    jquery.js
    jquery-ui.js
    models/
      user.js
      todo.js
    routers/
      users_router.js
      todos_router.js
    views/
      users/
        users_index.js
        users_new.js
        users_edit.js
      todos/
        todos_index.js</screen>
<simpara>If you are using templates, we prefer storing them in <literal>app/templates</literal> to keep
them separated from the server views:</simpara>
<screen>app/
  views/
    pages/
      home.html.erb
      terms.html.erb
      privacy.html.erb
      about.html.erb
  templates/
    users/
      index.jst
      new.jst
      edit.jst
    todos/
      index.jst
      show.jst</screen>
<simpara>On Rails 3.0 and prior apps, we use Jammit for packaging assets and
precompiling templates:</simpara>
<simpara><ulink url="http://documentcloud.github.com/jammit/">http://documentcloud.github.com/jammit/</ulink><?asciidoc-br?>
<ulink url="http://documentcloud.github.com/jammit/#jst">http://documentcloud.github.com/jammit/#jst</ulink></simpara>
<simpara>Jammit will make your templates available in a top-level JST object. For
example, to access the above todos/index.jst template, you would refer to it
as:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">JST['todos/index']</programlisting>
<simpara>Variables can be passed to the templates by passing a Hash to the template, as
shown below.</simpara>
<programlisting language="javascript" linenumbering="unnumbered">JST['todos/index']({ model: this.model })</programlisting>
<section id="_a_note_on_jammit_and_a_jst_naming_gotcha">
<title>A note on Jammit and a JST naming gotcha</title>
<simpara>One issue with Jammit that we&#8217;ve encountered and worked around is that the JST
template path can change when adding new templates.</simpara>
<simpara>When using Jammit, there is a slightly sticky issue as an app grows from one
template subdirectory to multiple template subdirectories.</simpara>
<simpara>Let&#8217;s say you place templates in app/templates. You work for a while on the
"Tasks" feature, placing templates under app/templates/tasks. So, window.JST
looks something like:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">JST['form']
JST['show']
JST['index']</programlisting>
<simpara>Now, you add another directory under app/templates, say app/templates/user.
Now, all JST references are prefixed with their parent directory name so they
are unambiguous:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">JST['tasks/form']
JST['tasks/show']
JST['tasks/index']
JST['users/new']
JST['users/show']
JST['users/index']</programlisting>
<simpara>This breaks existing JST references. You can work around this issue by applying
the following monkeypatch to Jammit, in config/initializers/jammit.rb</simpara>
<programlisting language="ruby" linenumbering="unnumbered">Jammit::Compressor.class_eval do
  private
  def find_base_path(path)
    File.expand_path(Rails.root.join('app','templates'))
  end
end</programlisting>
<simpara>As applications are moving to Rails 3.1, they&#8217;re also moving to Sprockets for
the asset packager.  Until then, many apps are using Jammit for asset
packaging.  One issue with Jammit we&#8217;ve encountered and worked around is that
the JST template path can change when adding new templates.  We have an open
issue and workaround:</simpara>
<simpara><ulink url="https://github.com/documentcloud/jammit/issues/192">https://github.com/documentcloud/jammit/issues/192</ulink></simpara>
</section>
</section>
<section id="_rails_3_1">
<title>Rails 3.1</title>
<simpara>Rails 3.1 introduces the asset pipeline:</simpara>
<simpara><ulink url="http://edgeguides.rubyonrails.org/asset_pipeline.html">http://edgeguides.rubyonrails.org/asset_pipeline.html</ulink></simpara>
<simpara>which uses the Sprockets library for preprocessing and packaging assets:</simpara>
<simpara><ulink url="http://getsprockets.org/">http://getsprockets.org/</ulink></simpara>
<simpara>To take advantage of the built-in asset pipeline, organize your Backbone.js
templates and classes in paths available to the asset pipeline.  Classes go in
<literal>app/assets/javascripts/</literal>, and templates go alongside, in
<literal>app/assets/templates/</literal>:</simpara>
<screen>app/
  assets/
    javascripts/
      jquery.js
      models/
        todo.js
      routers/
        todos_router.js
      views/
        todos/
          todos_index.js
    templates/
      todos/
        index.jst.ejs
        show.jst.ejs</screen>
<simpara>Using Sprockets' preprocessors, we can use templates as before.  Here, we&#8217;re
using the EJS template preprocessor to provide the same functionality as
Underscore.js' templates.  It compiles the <literal>*.jst</literal> files and makes them
available on the client side via the <literal>window.JST</literal> object. Identifying the
<literal>.ejs</literal> extension and invoking EJS to compile the templates is managed by
Sprockets, and requires the <literal>ejs</literal> gem to be included in the application
Gemfile.</simpara>
<simpara>To make the <literal>*.jst</literal> files available and create the <literal>window.JST</literal> object, require
them in your application.js Sprockets manifest:</simpara>
<screen>//  other application requires
//= require_tree ../templates
//= require_tree .</screen>
<simpara>Underscore.js templates:
<ulink url="http://documentcloud.github.com/underscore/#template">http://documentcloud.github.com/underscore/#template</ulink></simpara>
<simpara>EJS gem:
<ulink url="https://github.com/sstephenson/ruby-ejs">https://github.com/sstephenson/ruby-ejs</ulink></simpara>
<simpara>Sprockets support for EJS:
<ulink url="https://github.com/sstephenson/sprockets/blob/master/lib/sprockets/ejs_template.rb">https://github.com/sstephenson/sprockets/blob/master/lib/sprockets/ejs_template.rb</ulink></simpara>
</section>
<section id="_converting_your_rails_models_to_backbone_js_friendly_json_chapter_unstarted">
<title>Converting your Rails models to Backbone.js-friendly JSON (chapter unstarted)</title>
</section>
<section id="_converting_an_existing_page_view_area_to_use_backbone_js_chapter_unstarted">
<title>Converting an existing page/view area to use Backbone.js (chapter unstarted)</title>
</section>
<section id="_automatically_using_the_rails_authentication_token">
<title>Automatically using the Rails authentication token</title>
<simpara>When using Backbone.js in a Rails app, you will run into a conflict with the
Rails built in Cross Site Scripting (XSS) protection.</simpara>
<simpara>When Rails XSS is enabled, each POST or PUT request to Rails should include a
special token which is verified to ensure that the request originated from a
user which is actually using the Rails app. In recent versions of Rails,
Backbone.js Ajax requests are no exception.</simpara>
<simpara>To get around this, you have two options. Disable Rails XSS protection (not
recommended), or make Backbone.js play nicely with Rails XSS.</simpara>
<simpara>To make Backbone.js play nicely with Rails XSS you can monkeypatch Backbone.js
to include the Rails XSS token in any requests it makes.</simpara>
<simpara>The following is one such script.</simpara>
<programlisting language="js" linenumbering="unnumbered">//
// With additions by Maciej Adwent http://github.com/Maciek416
// If token name and value are not supplied, this code Requires jQuery
//
// Adapted from:
// http://www.ngauthier.com/2011/02/backbone-and-rails-forgery-protection.html
// Nick Gauthier @ngauthier
//

var BackboneRailsAuthTokenAdapter = {

  //
  // Given an instance of Backbone, route its sync() function so that
  // it executes through this one first, which mixes in the CSRF
  // authenticity token that Rails 3 needs to protect requests from
  // forgery. Optionally, the token's name and value can be supplied
  // by the caller.
  //
  fixSync: function(Backbone, paramName /*optional*/, paramValue /*optional*/){

    if(typeof(paramName)=='string' &amp;&amp; typeof(paramValue)=='string'){
      // Use paramName and paramValue as supplied
    } else {
      // Assume we've rendered meta tags with erb
      paramName = $("meta[name='csrf-param']").attr('content');
      paramValue = $("meta[name='csrf-token']").attr('content');
    }

    // alias away the sync method
    Backbone._sync = Backbone.sync;

    // define a new sync method
    Backbone.sync = function(method, model, success, error) {

      // only need a token for non-get requests
      if (method == 'create' || method == 'update' || method == 'delete') {

        // grab the token from the meta tag rails embeds
        var auth_options = {};
        auth_options[paramName] = paramValue;

        // set it as a model attribute without triggering events
        model.set(auth_options, {silent: true});
      }

      // proxy the call to the old sync method
      return Backbone._sync(method, model, success, error);
    };
  },


  // change Backbone's sync function back to the original one
  restoreSync: function(Backbone){
    Backbone.sync = Backbone._sync;
  }
};</programlisting>
<simpara>The above patch depends on jQuery, and should be included in your after jQuery
and Backbone.js are loaded. Using Jammit, you&#8217;d list it below the backbone.js
file.</simpara>
</section>
</section>
<section id="_views_and_templates">
<title>Views and Templates</title>
<section id="_view_explanation_chapter_unstarted">
<title>View explanation (chapter unstarted)</title>
</section>
<section id="_templating_strategy_chapter_unstarted">
<title>Templating strategy (chapter unstarted)</title>
</section>
<section id="_view_helpers_chapter_unstarted">
<title>View helpers (chapter unstarted)</title>
</section>
<section id="_form_helpers_chapter_unstarted">
<title>Form helpers (chapter unstarted)</title>
</section>
<section id="_event_binding_chapter_unstarted">
<title>Event binding (chapter unstarted)</title>
</section>
<section id="_cleaning_up_understanding_binding_and_unbinding_in_progress">
<title>Cleaning up: understanding binding and unbinding (in progress)</title>
<simpara>Imagine you&#8217;re writing a todo app.  Consider two views: an index view which
contains all the tasks, and a detail view that shows detail on one task.  The
interface switches between the two views, and both views can modify existing
tasks (say, to indicate that the task is complete or incomplete).</simpara>
<figure><title>Tasks index view</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="views_and_templates/tasks-index.png"/>
  </imageobject>
  <textobject><phrase>views_and_templates/tasks-index.png</phrase></textobject>
</mediaobject>
</figure>
<figure><title>Tasks detail view</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="views_and_templates/tasks-detail.png"/>
  </imageobject>
  <textobject><phrase>views_and_templates/tasks-detail.png</phrase></textobject>
</mediaobject>
</figure>
<simpara>The view classes look something like this:</simpara>
<programlisting language="js" linenumbering="unnumbered">var TasksIndex = Backbone.View.extend({
  template: JST['tasks/tasks_index'],
  tagName: 'section',
  id: 'tasks',

  initialize: function() {
    this.tasks = this.options.tasks;

    _.bindAll(this, "render");
    TaskApp.tasks.bind("change", this.render);
    TaskApp.tasks.bind("add", this.render);
  },

  render: function() {
    $(this.el).html(this.template({tasks: this.tasks}));
  }
});</programlisting>
<programlisting language="js" linenumbering="unnumbered">var TaskDetail = Backbone.View.extend({
  template: JST['tasks/tasks_detail'],
  tagName: 'section',
  id: 'task',

  events: {
    "click .comments .form-inputs button": "createComment"
  },

  initialize: function() {
    this.model = this.options.model;

    _.bindAll(this, "render");

    this.model.bind("change", this.render);
    this.model.comments.bind("change", this.render);
    this.model.comments.bind("add", this.render);
  },

  render: function() {
    $(this.el).html(this.template({task: this.model}));
  },

  createComment: function() {
    var comment = new Comment({ text: this.$('.new-comment-input').val() });
    this.$('.new-comment-input').val('');
    this.model.comments.create(comment);
  }
});</programlisting>
<simpara>Each task on the index page links to the detail view for itself.  When a user
follows one of these links and navigates from the index page to the detail
page, then interacts with the detail view to change a model, the <literal>change</literal> event
on the <literal>TaskApp.tasks</literal> collection is fired.  One consequence of this is that
the index view, which is still bound and observing the <literal>change</literal> event, will
re-render itself.</simpara>
<simpara>This is both a functional bug and a memory leak: not only will the index view
re-render and disrupt the detail display, but navigating back and forth between
the views without disposing of the previous view will keep creating and binding
more views.</simpara>
<simpara>The solution is to make sure you unbind and remove views when you leave them.
Our approach to this is to use a convention in <literal>Router</literal> instances, and reuse
this as a <literal>Router</literal> subclass, <literal>SwappingRouter</literal>.</simpara>
</section>
<section id="_swapping_router_in_progress">
<title>Swapping router (in progress)</title>
<simpara>When switching from one view to another, we should clean up the previous view.
Let&#8217;s augument our view to include the ability to clean itself up:</simpara>
<programlisting language="js" linenumbering="unnumbered">var MyView = Backbone.View.extend({
  // ...

  leave: function() {
    this.unbind();
    this.remove();
  },

  // ...
});</programlisting>
<simpara>The <literal>unbind()</literal> and <literal>remove()</literal> functions are provided by <literal>Backbone.Events</literal> and
<literal>Backbone.View</literal>.  <literal>unbind()</literal> will remove all callbacks registered on the view,
and <literal>remove()</literal> will remove the view&#8217;s element from the DOM.</simpara>
<simpara>In simple cases, we replace one full page view with another full page (less any
shared layout).  We introduce a convention that all actions underneath one
<literal>Router</literal> share the same root element, and define it as <literal>el</literal> on the router.</simpara>
<simpara>Now, a <literal>SwappingRouter</literal> can take advantage of the <literal>leave()</literal> function, and clean
up any existing views before swapping to a new one.  It swaps into a new view by
rendering that view into its own <literal>el</literal>:</simpara>
<programlisting language="js" linenumbering="unnumbered">SwappingRouter = function(options) {
  Backbone.Router.apply(this, [options]);
};

_.extend(SwappingRouter.prototype, Backbone.Router.prototype, {
  swap: function(newView) {
    if (this.currentView &amp;&amp; this.currentView.leave) {
      this.currentView.leave();
    }

    this.currentView = newView;
    this.currentView.render();
    $(this.el).empty().append(this.currentView.el);
  }
});

SwappingRouter.extend = Backbone.Router.extend;</programlisting>
</section>
<section id="_composite_views_in_progress">
<title>Composite views (in progress)</title>
<simpara>One of the first refactorings you find yourself doing in a non-trivial Backbone
app is splitting up large views into composable parts.  Let&#8217;s take another look
at the <literal>TaskDetail</literal> source code from the beginning of this section:</simpara>
<programlisting language="js" linenumbering="unnumbered">var TaskDetail = Backbone.View.extend({
  template: JST['tasks/tasks_detail'],
  tagName: 'section',
  id: 'task',

  events: {
    "click .comments .form-inputs button": "createComment"
  },

  initialize: function() {
    this.model = this.options.model;

    _.bindAll(this, "render");

    this.model.bind("change", this.render);
    this.model.comments.bind("change", this.render);
    this.model.comments.bind("add", this.render);
  },

  render: function() {
    $(this.el).html(this.template({task: this.model}));
  },

  createComment: function() {
    var comment = new Comment({ text: this.$('.new-comment-input').val() });
    this.$('.new-comment-input').val('');
    this.model.comments.create(comment);
  }
});</programlisting>
<simpara>along with the template for that view:</simpara>
<programlisting language="html" linenumbering="unnumbered">&lt;section class="task-details"&gt;
  &lt;input type="checkbox"&lt;%= task.isComplete() ? ' checked="checked"' : '' %&gt; /&gt;
  &lt;h2&gt;&lt;%= task.escape("title") %&gt;&lt;/h2&gt;
&lt;/section&gt;

&lt;section class="comments"&gt;
  &lt;ul&gt;
    &lt;% task.comments.each(function(comment) { %&gt;
      &lt;li&gt;
        &lt;h4&gt;&lt;%= comment.user.escape('name') %&gt;&lt;/h4&gt;
        &lt;p&gt;&lt;%= comment.escape('text') %&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;% } %&gt;
  &lt;/ul&gt;

  &lt;div class="form-inputs"&gt;
    &lt;label for="new-comment-input"&gt;Add comment&lt;/label&gt;
    &lt;textarea id="new-comment-input" cols="30" rows="10"&gt;&lt;/textarea&gt;
    &lt;button&gt;Add Comment&lt;/button&gt;
  &lt;/div&gt;
&lt;/section&gt;</programlisting>
<simpara>There are clearly several concerns going on here: rendering the task, rendering
the comments that folks have left, and rendering the form to create new
comments.  Let&#8217;s separate those concerns.  A first approach might be to just
break up the template files:</simpara>
<programlisting language="html" linenumbering="unnumbered">&lt;!-- tasks/show.jst --&gt;
&lt;section class="task-details"&gt;
  &lt;%= JST['tasks/details']({ task: task }) %&gt;
&lt;/section&gt;

&lt;section class="comments"&gt;
  &lt;%= JST['comments/list']({ task: task }) %&gt;
&lt;/section&gt;</programlisting>
<programlisting language="html" linenumbering="unnumbered">&lt;!-- tasks/details.jst --&gt;
&lt;input type="checkbox"&lt;%= task.isComplete() ? ' checked="checked"' : '' %&gt; /&gt;
&lt;h2&gt;&lt;%= task.escape("title") %&gt;&lt;/h2&gt;</programlisting>
<programlisting language="html" linenumbering="unnumbered">&lt;!-- comments/list.jst --&gt;
&lt;ul&gt;
  &lt;% task.comments.each(function(comment) { %&gt;
    &lt;%= JST['comments/item']({ comment: comment }) %&gt;
  &lt;% } %&gt;
&lt;/ul&gt;

&lt;%= JST['comments/new']() %&gt;</programlisting>
<programlisting language="html" linenumbering="unnumbered">&lt;!-- comments/item.jst --&gt;
&lt;h4&gt;&lt;%= comment.user.escape('name') %&gt;&lt;/h4&gt;
&lt;p&gt;&lt;%= comment.escape('text') %&gt;&lt;/p&gt;</programlisting>
<programlisting language="html" linenumbering="unnumbered">&lt;!-- comments/new.jst --&gt;
&lt;div class="form-inputs"&gt;
  &lt;label for="new-comment-input"&gt;Add comment&lt;/label&gt;
  &lt;textarea id="new-comment-input" cols="30" rows="10"&gt;&lt;/textarea&gt;
  &lt;button&gt;Add Comment&lt;/button&gt;
&lt;/div&gt;</programlisting>
<simpara>But this is really only half the story.  The <literal>TaskDetail</literal> view class still
handles multiple concerns: displaying the task, and creating comments.  Let&#8217;s
split that view class up, using the <literal>CompositeView</literal> base class:</simpara>
<programlisting language="js" linenumbering="unnumbered">CompositeView = function(options) {
  this.children = [];
  Backbone.View.apply(this, [options]);
};

_.extend(CompositeView.prototype, Backbone.View.prototype, {
  leave: function() {
    this.unbind();
    this.remove();
    this._leaveChildren();
    this._removeFromParent();
  },

  removeChild: function(view) {
    var index = this.children.indexOf(view);
    this.children.splice(index, 1);
  },

  renderChild: function(view) {
    view.render();
    this.children.push(view);
    view.parent = this;
  },

  appendChild: function(view) {
    this.renderChild(view);
    $(this.el).append(view.el);
  },

  renderChildInto: function(view, container) {
    this.renderChild(view);
    $(container).html('').append(view.el);
  },

  _leaveChildren: function() {
    var clonedChildren = this.children.slice(0);
    _.each(clonedChildren, function(view) {
      if (view.leave) {
        view.leave();
      }
    });
  },

  _removeFromParent: function() {
    if (this.parent) {
      this.parent.removeChild(this);
    }
  }
});

CompositeView.extend = Backbone.View.extend;</programlisting>
<simpara>Similar to the <literal>SwappingRouter</literal>, the <literal>CompositeView</literal> base class solves common
housekeeping problems by establishing a convention.  In this case, a parent view
maintains an array of its immediate children as <literal>this.children</literal>.</simpara>
<simpara>With this reference in place, a parent view&#8217;s <literal>leave()</literal> method can invoke
<literal>leave()</literal> on its children, ensuring that an entire tree of composed views is
cleaned up properly.</simpara>
<simpara>For child views that can dismiss themselves, such as dialog boxes, children
maintain a back-reference at <literal>this.parent</literal>.  This is used to reach up and call
<literal>this.parent.removeChild(this)</literal> for these self-dismissing views.</simpara>
<simpara>Making use of <literal>CompositeView</literal>, we split up the <literal>TaskDetail</literal> view class:</simpara>
<programlisting language="js" linenumbering="unnumbered">var TaskDetail = Backbone.View.extend({
  tagName: 'section',
  id: 'task',

  initialize: function() {
    this.model = this.options.model;
    _.bindAll(this, "renderDetails");
    this.model.bind("change", this.renderDetails);
  },

  render: function() {
    this.renderLayout();
    this.renderDetail();
    this.renderCommentsList();
  },

  renderLayout: function() {
    $(this.el).html(JST['tasks/show']());
  },

  renderDetails: function() {
    var detailsMarkup = JST['tasks/details']({ task: this.model });
    this.$('.task-details').html(detailsMarkup);
  },

  renderCommentsList: function() {
    var commentsList = new CommentsList({ model: this.model });
    var commentsContainer = this.$('comments');
    this.renderChildInto(commentsList, commentsContainer);
  }
});</programlisting>
<programlisting language="js" linenumbering="unnumbered">var CommentsList = CompositeView.extend({
  tagName: 'ul',

  initialize: function() {
    this.model = this.options.model;
    this.model.comments.bind("add", this.renderComments);
  },

  render: function() {
    this.renderLayout();
    this.renderComments();
    this.renderCommentForm();
  },

  renderLayout: function() {
    $(this.el).html(JST['comments/list']());
  },

  renderComments: function() {
    var commentsContainer = this.$('comments-list');
    commentsContainer.html('');

    this.model.comments.each(function(comment) {
      var commentMarkup = JST['comments/item']({ comment: comment });
      commentsContainer.append(commentMarkup);
    });
  },

  renderCommentForm: function() {
    var commentForm = new CommentForm({ model: this.model });
    var commentFormContainer = this.$('.new-comment-form');
    this.renderChildInto(commentForm, commentFormContainer);
  }
});</programlisting>
<programlisting language="js" linenumbering="unnumbered">var CommentForm = CompositeView.extend({
  events: {
    "click button": "createComment"
  },

  initialize: function() {
    this.model = this.options.model;
  },

  render: function() {
    $(this.el).html(JST['comments/new']);
  },

  createComment: function() {
    var comment = new Comment({ text: $('.new-comment-input').val() });
    this.$('.new-comment-input').val('');
    this.model.comments.create(comment);
  }
});</programlisting>
<simpara>Along with this, remove the <literal>&lt;%= JST(&#8230;) %&gt;</literal> template nestings, allowing the
view classes to assemble the templates instead.  In this case, each template
contains placeholder elements that are used to wrap child views:</simpara>
<programlisting language="html" linenumbering="unnumbered">&lt;!-- tasks/show.jst --&gt;
&lt;section class="task-details"&gt;
&lt;/section&gt;

&lt;section class="comments"&gt;
&lt;/section&gt;</programlisting>
<programlisting language="html" linenumbering="unnumbered">&lt;!-- tasks/details.jst --&gt;
&lt;input type="checkbox"&lt;%= task.isComplete() ? ' checked="checked"' : '' %&gt; /&gt;
&lt;h2&gt;&lt;%= task.escape("title") %&gt;&lt;/h2&gt;</programlisting>
<programlisting language="html" linenumbering="unnumbered">&lt;!-- comments/list.jst --&gt;
&lt;ul class="comments-list"&gt;
&lt;/ul&gt;

&lt;section class="new-comment-form"&gt;
&lt;/section&gt;</programlisting>
<programlisting language="html" linenumbering="unnumbered">&lt;!-- comments/item.jst --&gt;
&lt;h4&gt;&lt;%= comment.user.escape('name') %&gt;&lt;/h4&gt;
&lt;p&gt;&lt;%= comment.escape('text') %&gt;&lt;/p&gt;</programlisting>
<programlisting language="html" linenumbering="unnumbered">&lt;!-- comments/new.jst --&gt;
&lt;label for="new-comment-input"&gt;Add comment&lt;/label&gt;
&lt;textarea class="new-comment-input" cols="30" rows="10"&gt;&lt;/textarea&gt;
&lt;button&gt;Add Comment&lt;/button&gt;</programlisting>
<simpara>There are several advantages to this approach:</simpara>
<itemizedlist>
<listitem>
<simpara>
Split up like this, each view class has a smaller and more cohesive set of
  responsibilities.
</simpara>
</listitem>
<listitem>
<simpara>
The comments view code, extracted and decoupled from the task view code, can
  now be reused on other domain objects with comments.
</simpara>
</listitem>
<listitem>
<simpara>
The task view performs better, since adding new comments or updating the task
  details will only re-render the pertinent section, instead of re-rendering the
  entire task + comments composite.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_how_to_use_multiple_views_on_the_same_model_collection_chapter_unstarted">
<title>How to use multiple views on the same model/collection (chapter unstarted)</title>
</section>
<section id="_internationalization_chapter_unstarted">
<title>Internationalization (chapter unstarted)</title>
</section>
</section>
<section id="_models_and_collections">
<title>Models and collections</title>
<section id="_naming_conventions_chapter_unstarted">
<title>Naming conventions (chapter unstarted)</title>
</section>
<section id="_nested_resources_chapter_unstarted">
<title>Nested resources (chapter unstarted)</title>
</section>
<section id="_model_associations">
<title>Model associations</title>
<simpara>Backbone.js doesn&#8217;t prescribe a way to define associations between models, so
we need to get creative and use the power of JavaScript to set up associations
in a way that it&#8217;s usage is natural.</simpara>
<section id="_belongs_to_associations">
<title>Belongs to associations</title>
<simpara>Setting up a <literal>belongs_to</literal> association in Backbone is a two step process. Let&#8217;s
discuss setting up the association that may occur between a task and a user.
The end result of the approach is a <literal>Task</literal> instance having a property called
<literal>user</literal> where we store the associated <literal>User</literal> object.</simpara>
<simpara>To set this up, let&#8217;s start by telling Rails to augment the task&#8217;s JSON
representation to also send over the associated user attributes:</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class Task &lt; ActiveRecord::Base
  belongs_to :user

  def as_json(options = {})
    super(include: { user: { only: [:name, :email] } })
  end
end</programlisting>
<simpara>This means that when Backbone calls <literal>fetch()</literal> for a <literal>Task</literal> model, it will
include the name and email of the associated user nested within the task JSON
representation. Something like this:</simpara>
<programlisting language="javascript]" linenumbering="unnumbered">{
  "title": "Buy more Cheeseburgers",
  "due_date": "2011-03-04",
  "user": {
    "name": "Robert McGraffalon",
    "email": "bobby@themcgraffalons.com"
  }
}</programlisting>
<simpara>Now that we receive user data with the task&#8217;s JSON representation, let&#8217;s tell
our Backbone User model to store the User object. We do that on the task&#8217;s
initializer. Here&#8217;s a first cut at that:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var Task = Backbone.Model.extend({
  initialize: function() {
    this.user = new User(this.get('user'));
  }
});</programlisting>
<simpara>A couple of improvements to the above: You&#8217;ll soon realize that you will might
be setting the user outside of the initialize as well. Also, the initializer
should check whether there user data in the first place. To address the first
concern, let&#8217;s create a setter for the object. Backbone provides a handy
function called <literal>has</literal> that returns whether the provided option is set for the
object:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var User = Backbone.Model.extend({
  initialize: function() {
    if (this.has('user')) {
      this.user = setUser(new User(this.get('user')));
    }
  },

  setUser: function(user) {
    this.user = user;
  }
});</programlisting>
<simpara>The final setup allows for a nice clean interface to a task&#8217;s user, by
accessing the task property fo the user instance.</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var task = Task.fetch(1);
console.log(task.get('title') + ' is being worked on by ' + task.user.get('name'));</programlisting>
</section>
<section id="_has_many_associations">
<title>Has many associations</title>
<simpara>You can take a similar approach to set up a <literal>has_many</literal> association on the
client side models. This time, however, the object&#8217;s property will be a
Backbone collection.</simpara>
<simpara>Following the example, say we need access to a user&#8217;s tasks. Let&#8217;s set up the
JSON representation on the Rails side first:</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class User &lt; ActiveRecord::Base
  has_many :tasks

  def as_json(options = {})
    super(include: { tasks: { only: [:body, :due_date] } })
  end
end</programlisting>
<simpara>Now, on the Backbone <literal>User</literal> model&#8217;s initializer, let&#8217;s call the <literal>setTasks</literal>
function:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var User = Backbone.Model.extend({
  initialize: function() {
    var tasks = new Tasks.reset(this.get('tasks'));
    this.setTasks(tasks);
  },

  setTasks: function(tasks) {
    this.tasks = tasks;
  }
});</programlisting>
<simpara>Note that we are setting the relation to an instance of the <literal>Tasks</literal> collection.</simpara>
</section>
</section>
<section id="_scopes_and_filters">
<title>Scopes and filters</title>
<simpara>To filter a <literal>Backbone.Collection</literal>, like with Rails named scopes, define
functions on your collections that filter by your criteria and return new
instances of the collection class. A first implementation might look like this:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  complete: function() {
    var filteredTasks = this.select(function(task) {
      return task.get('completed_at') !== null;
    });
    return new Tasks(filteredTasks);
  }
});</programlisting>
<simpara>Ideally, the filter functions will reuse logic already defined in your model
class:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var Task = Backbone.Model.extend({
  isComplete: function() {
    return this.get('completed_at') !== null;
  }
});

var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  complete: function() {
    var filteredTasks = this.select(function(task) {
      return task.isComplete();
    });
    return new Tasks(filteredTasks);
  }
});</programlisting>
<simpara>Going further, you can separate the two concerns here, and extract a <literal>filtered</literal>
function:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var Task = Backbone.Model.extend({
  isComplete: function() {
    return this.get('completed_at') !== null;
  }
});

var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  complete: function() {
    return this.filtered(this.select(function(task) {
      return task.isComplete();
    }));
  },

  filtered: function(criteriaFunction) {
    return new Tasks(this.select(criteriaFunction));
  }
});</programlisting>
</section>
<section id="_sorting">
<title>Sorting</title>
<simpara>The simplest way to sort a <literal>Backbone.Collection</literal> is to define a <literal>comparator</literal>
function:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  comparator: function(task) {
    return task.dueDate;
  }
});</programlisting>
<simpara>If you&#8217;d like to provide more than one sort order on your collection, you can
use an approach similar to the <literal>filtered</literal> function above, and return a new
<literal>Backbone.Collection</literal> whose <literal>comparator</literal> is overridden.  Call <literal>sort</literal> to update
the ordering on the new collection:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  comparator: function(task) {
    return task.dueDate;
  },

  byCreatedAt: function() {
    var sortedCollection = new Tasks(this.models);
    sortedCollection.comparator = function(task) {
      return task.createdAt;
    };
    sortedCollection.sort();
    return sortedCollection;
  }
});</programlisting>
<simpara>Similarly, you can extract the resuable concern to another function:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  comparator: function(task) {
    return task.dueDate;
  },

  byCreatedAt: function() {
    return this.sortedBy(function(task) {
      return task.createdAt;
    });
  },

  byCompletedAt: function() {
    return this.sortedBy(function(task) {
      return task.createdAt;
    });
  },

  sortedBy: function(comparator) {
    var sortedCollection = new Tasks(this.models);
    sortedCollection.comparator = comparator;
    sortedCollection.sort();
    return sortedCollection;
  }
});</programlisting>
</section>
<section id="_client_server_duplicated_business_logic_chapter_unstarted">
<title>Client/Server duplicated business logic (chapter unstarted)</title>
</section>
<section id="_validations_chapter_unstarted">
<title>Validations (chapter unstarted)</title>
</section>
<section id="_synchronizing_between_clients_chapter_unstarted">
<title>Synchronizing between clients (chapter unstarted)</title>
</section>
</section>
<section id="_binding_models_and_views_section_unstarted">
<title>Binding models and views (section unstarted)</title>
</section>
<section id="_testing_section_unstarted">
<title>Testing (section unstarted)</title>
<section id="_full_stack_integration_testing">
<title>Full-stack integration testing</title>
</section>
<section id="_isolated_unit_testing">
<title>Isolated unit testing</title>
</section>
</section>
<section id="_the_javascript_language_section_unstarted">
<title>The JavaScript language (section unstarted)</title>
<section id="_model_attribute_types_and_serialization">
<title>Model attribute types and serialization</title>
</section>
<section id="_context_binding_js_literal_this_literal">
<title>Context binding (JS <literal>this</literal>)</title>
</section>
<section id="_coffeescript_with_backbone_js">
<title>CoffeeScript with Backbone.js</title>
</section>
</section>
<section id="_security_stub">
<title>Security (stub)</title>
<section id="_xss_with_json_bootstrapping_stub">
<title>XSS with JSON bootstrapping (stub)</title>
<simpara>Use <literal>json2.js</literal> and:</simpara>
<programlisting language="js" linenumbering="unnumbered">&lt;script type="text/json" id="something"&gt;
  &lt;%= something.to_json %&gt;
&lt;/script&gt;

&lt;script type="text/javascript"&gt;
  (function () {
    var something = JSON.parse($('#something').text());
    someJavascriptFunction(something);
  })();
&lt;/script&gt;</programlisting>
</section>
<section id="_xss_in_html_templates_stub">
<title>XSS in HTML templates (stub)</title>
<simpara>TODO: Discuss <literal>Backbone.Model.escape</literal>, <literal>_.escape</literal>, defaulting to escape with <literal>&lt;%=</literal> vs <literal>&lt;%==</literal>, escaping in other templating.</simpara>
</section>
</section>
</article>
