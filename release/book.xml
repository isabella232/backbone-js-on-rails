<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<article lang="en">
<articleinfo>
    <title>Backbone.js on Rails</title>
</articleinfo>
<section id="_preface">
<title>Preface</title>
</section>
<section id="_getting_up_to_speed">
<title>Getting up to speed</title>
<section id="_backbone_js_online_resources">
<title>Backbone.js online resources</title>
</section>
<section id="_javascript_online_resources_and_books">
<title>JavaScript online resources and books</title>
</section>
</section>
<section id="_introduction">
<title>Introduction</title>
<section id="_why_use_backbone_js">
<title>Why use Backbone.js</title>
</section>
<section id="_when_not_to_use_backbone_js">
<title>When not to use Backbone.js</title>
</section>
<section id="_why_not_sproutcore_cappuccino_knockout_js_spine_etc">
<title>Why not SproutCore, Cappuccino, Knockout.js, Spine, etc.</title>
</section>
</section>
<section id="_organization">
<title>Organization</title>
<section id="_backbone_js_and_mvc">
<title>Backbone.js and MVC</title>
</section>
<section id="_what_goes_where_in_mvc">
<title>What goes where in MVC</title>
</section>
<section id="_namespacing_your_application">
<title>Namespacing your application</title>
</section>
</section>
<section id="_rails_integration">
<title>Rails Integration</title>
<section id="_organizing_your_backbone_js_code_in_a_rails_app">
<title>Organizing your Backbone.js code in a Rails app</title>
<simpara>When using Backbone.js in a Rails app, you&#8217;ll have two primary kinds of Backbone.js-related assets: classes, and templates.</simpara>
</section>
<section id="_rails_3_0_and_prior">
<title>Rails 3.0 and prior</title>
<simpara>With Rails 3.0 and prior, store your Backbone.js classes in <literal>public/javascripts</literal>:</simpara>
<screen>public/
  javascripts/
    jquery.js
    jquery-ui.js
    models/
      user.js
      todo.js
    routers/
      users_router.js
      todos_router.js
    views/
      users/
        users_index.js
        users_new.js
        users_edit.js
      todos/
        todos_index.js</screen>
<simpara>If you are using templates, we prefer storing them in <literal>app/templates</literal> to keep them separated from the server views:</simpara>
<screen>app/
  views/
    pages/
      home.html.erb
      terms.html.erb
      privacy.html.erb
      about.html.erb
  templates/
    users/
      index.jst
      new.jst
      edit.jst
    todos/
      index.jst
      show.jst</screen>
<simpara>On Rails 3.0 and prior apps, we use Jammit for packaging assets and precompiling templates:</simpara>
<simpara><ulink url="http://documentcloud.github.com/jammit/">http://documentcloud.github.com/jammit/</ulink>
<ulink url="http://documentcloud.github.com/jammit/#jst">http://documentcloud.github.com/jammit/#jst</ulink></simpara>
<section id="_a_note_on_jsts_and_jammit">
<title>A note on JSTs and Jammit</title>
<simpara>As applications are moving to Rails 3.1, they&#8217;re also moving to Sprockets for the asset packager.  Until then, many apps are using Jammit for asset packaging.  One issue with Jammit we&#8217;ve encountered and worked around is that the JST template path can change when adding new templates.  We have an open issue and workaround:</simpara>
<simpara><ulink url="https://github.com/documentcloud/jammit/issues/192">https://github.com/documentcloud/jammit/issues/192</ulink></simpara>
</section>
</section>
<section id="_rails_3_1">
<title>Rails 3.1</title>
<simpara>Rails 3.1 introduces the asset pipeline:</simpara>
<simpara><ulink url="http://edgeguides.rubyonrails.org/asset_pipeline.html">http://edgeguides.rubyonrails.org/asset_pipeline.html</ulink></simpara>
<simpara>which uses the Sprockets library for preprocessing and packaging assets:</simpara>
<simpara><ulink url="http://getsprockets.org/">http://getsprockets.org/</ulink></simpara>
<simpara>To take advantage of the built-in asset pipeline, organize your Backbone.js templates and classes in paths available to the asset pipeline.  Classes go in <literal>app/assets/javascripts/</literal>, and templates go alongside, in <literal>app/assets/templates/</literal>:</simpara>
<screen>app/
  assets/
    javascripts/
      jquery.js
      models/
        todo.js
      routers/
        todos_router.js
      views/
        todos/
          todos_index.js
    templates/
      todos/
        index.jst.ejs
        show.jst.ejs</screen>
<simpara>Using Sprockets' preprocessors, we can use templates as before.  Here, we&#8217;re using the EJS template preprocessor to provide the same functionality as Underscore.js' templates.  It compiles the <literal>*.jst</literal> files and makes them available to the <literal>window.JST</literal> function.  Identifying the <literal>.ejs</literal> extension and invoking EJS to compile the templates is managed by Sprockets, and requires the <literal>ejs</literal> gem to be included in the application Gemfile.</simpara>
<simpara>Underscore.js templates:
<ulink url="http://documentcloud.github.com/underscore/#template">http://documentcloud.github.com/underscore/#template</ulink></simpara>
<simpara>EJS gem:
<ulink url="https://github.com/sstephenson/ruby-ejs">https://github.com/sstephenson/ruby-ejs</ulink></simpara>
<simpara>Sprockets support for EJS:
<ulink url="https://github.com/sstephenson/sprockets/blob/master/lib/sprockets/ejs_template.rb">https://github.com/sstephenson/sprockets/blob/master/lib/sprockets/ejs_template.rb</ulink>
=== Converting your Rails models to Backbone.js-friendly JSON
=== Converting an existing page/view area to use Backbone.js
=== Automatically using the Rails authentication token</simpara>
</section>
</section>
<section id="_views_and_templates">
<title>Views and Templates</title>
<section id="_view_explanation">
<title>View explanation</title>
</section>
<section id="_templating_strategy">
<title>Templating strategy</title>
</section>
<section id="_view_helpers">
<title>View helpers</title>
</section>
<section id="_form_helpers">
<title>Form helpers</title>
</section>
<section id="_event_binding">
<title>Event binding</title>
</section>
<section id="_how_to_use_multiple_views_on_the_same_model_collection">
<title>How to use multiple views on the same model/collection</title>
</section>
<section id="_composed_views">
<title>Composed views</title>
</section>
<section id="_cleaning_up_understanding_binding_and_unbinding">
<title>Cleaning up: understanding binding and unbinding</title>
</section>
<section id="_internationalization">
<title>Internationalization</title>
</section>
</section>
<section id="_models_and_collections">
<title>Models and collections</title>
<section id="_naming_conventions">
<title>Naming conventions</title>
</section>
<section id="_nested_resources">
<title>Nested resources</title>
</section>
<section id="_relationships">
<title>Relationships</title>
</section>
<section id="_scopes_and_filters">
<title>Scopes and filters</title>
<simpara>To filter a <literal>Backbone.Collection</literal>, like with Rails named scopes, define functions on your collections that return new collection instances, filtered by your criteria.  A first implementation might look like this:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  complete: function() {
    var filteredTasks = this.select(function(task) {
      return task.get('completed_at') !== null;
    });
    return new Tasks(filteredTasks);
  }
});</programlisting>
<simpara>Ideally, the filter functions will reuse logic already defined in your model class:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var Task = Backbone.Model.extend({
  isComplete: function() {
    return this.get('completed_at') !== null;
  }
});

var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  complete: function() {
    var filteredTasks = this.select(function(task) {
      return task.isComplete();
    });
    return new Tasks(filteredTasks);
  }
});</programlisting>
<simpara>Going further, you can separate the two concerns here, and extract a <literal>filtered</literal> function:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var Task = Backbone.Model.extend({
  isComplete: function() {
    return this.get('completed_at') !== null;
  }
});

var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  complete: function() {
    return this.filtered(this.select(function(task) {
      return task.isComplete();
    }));
  },

  filtered: function(criteriaFunction) {
    return new Tasks(this.select(criteriaFunction));
  }
});</programlisting>
</section>
<section id="_sorting">
<title>Sorting</title>
<simpara>The simplest way to sort <literal>Backbone.Collection</literal> is to define a <literal>comparator</literal> function:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  comparator: function(task) {
    return task.dueDate;
  }
});</programlisting>
<simpara>If you&#8217;d like to provide more than one sort on your collection, you can use an approach similar to the <literal>filtered</literal> function above, and return a new <literal>Backbone.Collection</literal> whose <literal>comparator</literal> is overridden.  Call <literal>sort</literal> to update the ordering on the new collection:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  comparator: function(task) {
    return task.dueDate;
  },

  byCreatedAt: function() {
    var sortedCollection = new Tasks(this.models);
    sortedCollection.comparator = function(task) {
      return task.createdAt;
    };
    sortedCollection.sort();
    return sortedCollection;
  }
});</programlisting>
<simpara>Similarly, you can extract the resuable concern to another function:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  comparator: function(task) {
    return task.dueDate;
  },

  byCreatedAt: function() {
    return this.sortedBy(function(task) {
      return task.createdAt;
    });
  },

  byCompletedAt: function() {
    return this.sortedBy(function(task) {
      return task.createdAt;
    });
  },

  sortedBy: function(comparator) {
    var sortedCollection = new Tasks(this.models);
    sortedCollection.comparator = comparator;
    sortedCollection.sort();
    return sortedCollection;
  }
});</programlisting>
</section>
<section id="_client_server_duplicated_business_logic">
<title>Client/Server duplicated business logic</title>
</section>
<section id="_validations">
<title>Validations</title>
</section>
<section id="_synchronizing_between_clients">
<title>Synchronizing between clients</title>
</section>
</section>
<section id="_testing">
<title>Testing</title>
<section id="_full_stack_integration_testing">
<title>Full-stack integration testing</title>
</section>
<section id="_isolated_unit_testing">
<title>Isolated unit testing</title>
</section>
</section>
<section id="_the_javascript_language">
<title>The JavaScript language</title>
<section id="_model_attribute_types_and_serialization">
<title>Model attribute types and serialization</title>
</section>
<section id="_context_binding_js_literal_this_literal">
<title>Context binding (JS <literal>this</literal>)</title>
</section>
<section id="_coffeescript_with_backbone_js">
<title>CoffeeScript with Backbone.js</title>
</section>
</section>
</article>
