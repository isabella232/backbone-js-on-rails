<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="master.css" type="text/css" />
    <title>Rails Integration</title>
  </head>

  <body>
    <div class="nav" id="navheader">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="organization.html">Prev</a><br/>
         Organization
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         <strong>Backbone.js on Rails</strong>
        
      </td><td width="33%" align="right">
        
          <a href="routers_views_and_templates.html">Next</a><br/>
          Routers, Views, and Templates
        
      </td></tr>
    </table>
    </div>

    <hr/>

    <div class="content">
      <div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a id="_rails_integration"></a>Rails Integration</h2></div></div></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_organizing_your_backbone_code_in_a_rails_app"></a>Organizing your Backbone code in a Rails app</h3></div></div></div>
<p>When using Backbone in a Rails app, you’ll have two kinds of
Backbone-related assets: classes and templates.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_rails_3_0_and_prior"></a>Rails 3.0 and prior</h3></div></div></div>
<p>With Rails 3.0 and prior, store your Backbone classes in
<code class="literal">public/javascripts</code>:</p>
<pre class="screen">public/
  javascripts/
    jquery.js
    jquery-ui.js
    collections/
      users.js
      todos.js
    models/
      user.js
      todo.js
    routers/
      users_router.js
      todos_router.js
    views/
      users/
        users_index.js
        users_new.js
        users_edit.js
      todos/
        todos_index.js</pre>
<p>If you are using templates, we prefer storing them in <code class="literal">app/templates</code> to keep
them separated from the server views:</p>
<pre class="screen">app/
  views/
    pages/
      home.html.erb
      terms.html.erb
      privacy.html.erb
      about.html.erb
  templates/
    users/
      index.jst
      new.jst
      edit.jst
    todos/
      index.jst
      show.jst</pre>
<p>On Rails 3.0 and prior apps, we use Jammit for packaging assets and
precompiling templates:</p>
<p><a class="ulink" href="http://documentcloud.github.com/jammit/" target="_top">http://documentcloud.github.com/jammit/</a></p>
<p><a class="ulink" href="http://documentcloud.github.com/jammit/#jst" target="_top">http://documentcloud.github.com/jammit/#jst</a></p>
<p>Jammit will make your templates available in a top-level JST object. For
example, to access the above todos/index.jst template, you would refer to it
as:</p>
<pre class="programlisting">JST[<b class="hl-string"><i style="color:red">'todos/index'</i></b>]</pre>
<p>Variables can be passed to the templates by passing a Hash to the template, as
shown below.</p>
<pre class="programlisting">JST[<b class="hl-string"><i style="color:red">'todos/index'</i></b>]({ model: <b class="hl-keyword">this</b>.model })</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p><span class="strong"><strong>Jammit and a JST naming gotcha</strong></span></p>
<p>One issue with Jammit that we’ve encountered and worked around is that the JST
template path can change when adding new templates.  Let’s say you place
templates in <code class="literal">app/templates</code>. You work for a while on the "Tasks" feature,
placing templates under <code class="literal">app/templates/tasks</code>. So, <code class="literal">window.JST</code> looks something
like:</p>
<pre class="programlisting">JST[<b class="hl-string"><i style="color:red">'form'</i></b>]
JST[<b class="hl-string"><i style="color:red">'show'</i></b>]
JST[<b class="hl-string"><i style="color:red">'index'</i></b>]</pre>
<p>Now, you add another directory under <code class="literal">app/templates</code>, say <code class="literal">app/templates/user</code>.
Now, templates with colliding names in JST references are prefixed with their
 parent directory name so they are unambiguous:</p>
<pre class="programlisting">JST[<b class="hl-string"><i style="color:red">'form'</i></b>] <i class="hl-comment" style="color: silver">// in tasks/form.jst</i>
JST[<b class="hl-string"><i style="color:red">'tasks/show'</i></b>]
JST[<b class="hl-string"><i style="color:red">'tasks/index'</i></b>]
JST[<b class="hl-string"><i style="color:red">'new'</i></b>]  <i class="hl-comment" style="color: silver">// in users/new.jst</i>
JST[<b class="hl-string"><i style="color:red">'users/show'</i></b>]
JST[<b class="hl-string"><i style="color:red">'users/index'</i></b>]</pre>
<p>This breaks existing JST references. You can work around this issue by applying
the following monkeypatch to Jammit, in <code class="literal">config/initializers/jammit.rb</code>:</p>
<pre class="programlisting">Jammit::Compressor.class_eval <b class="hl-keyword">do</b>
  private
  <b class="hl-keyword">def</b> find_base_path(path)
    File.expand_path(Rails.root.join(<b class="hl-string"><i style="color:red">'app'</i></b>,<b class="hl-string"><i style="color:red">'templates'</i></b>))
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre>
<p>As applications are moving to Rails 3.1, they’re also moving to Sprockets for
the asset packager.  Until then, many apps are using Jammit for asset
packaging.  We have an open issue and workaround:</p>
<p><a class="ulink" href="https://github.com/documentcloud/jammit/issues/192" target="_top">https://github.com/documentcloud/jammit/issues/192</a></p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_rails_3_1"></a>Rails 3.1</h3></div></div></div>
<p>Rails 3.1 introduces the
<a class="ulink" href="http://guides.rubyonrails.org/asset_pipeline.html" target="_top">asset pipeline</a>, which uses
the <a class="ulink" href="http://getsprockets.org" target="_top">Sprockets library</a> for preprocessing and packaging
assets.</p>
<p>To take advantage of the built-in asset pipeline, organize your Backbone
templates and classes in paths available to it: classes go in
<code class="literal">app/assets/javascripts/</code>, and templates go alongside, in
<code class="literal">app/assets/templates/</code>:</p>
<pre class="screen">app/
  assets/
    javascripts/
      collections/
        todos.js
      models/
        todo.js
      routers/
        todos_router.js
      views/
        todos/
          todos_index.js
    templates/
      todos/
        index.jst.ejs
        show.jst.ejs</pre>
<p>In Rails 3.1, jQuery is provided by the <code class="literal">jquery-rails</code> gem, and no longer
needs to be included in your directory structure.</p>
<p>Using Sprockets' preprocessors, we can use templates as before.  Here, we’re
using the EJS template preprocessor to provide the same functionality as
Underscore.js' templates.  It compiles the <code class="literal">*.jst</code> files and makes them
available on the client side via the <code class="literal">window.JST</code> object. Identifying the
<code class="literal">.ejs</code> extension and invoking EJS to compile the templates is managed by
Sprockets, and requires the <code class="literal">ejs</code> gem to be included in the application Gemfile.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>Underscore.js templates:
<a class="ulink" href="http://documentcloud.github.com/underscore/#template" target="_top">http://documentcloud.github.com/underscore/#template</a></p>
<p>EJS gem:
<a class="ulink" href="https://github.com/sstephenson/ruby-ejs" target="_top">https://github.com/sstephenson/ruby-ejs</a></p>
<p>Sprockets support for EJS:
<a class="ulink" href="https://github.com/sstephenson/sprockets/blob/master/lib/sprockets/ejs_template.rb" target="_top">https://github.com/sstephenson/sprockets/blob/master/lib/sprockets/ejs_template.rb</a></p>
</div>
<p>To make the <code class="literal">*.jst</code> files available and create the <code class="literal">window.JST</code> object, require
them in your application.js Sprockets manifest:</p>
<pre class="programlisting"><i class="hl-comment" style="color: silver">//  other application requires</i>
<i class="hl-comment" style="color: silver">//= require_tree ../templates</i>
<i class="hl-comment" style="color: silver">//= require_tree .</i></pre>
<p>Load order for Backbone and your Backbone app is very
important. jQuery and Underscore must be loaded before Backbone, then
the Rails authenticity token patch must be applied. Then your models must be
loaded before your collections (because your collections will reference your
models) and then your routers and views must be loaded.</p>
<p>Fortunately, Sprockets can handle this load order for us. When all is said and
done, your application.js Sprockets manifest will look as shown below:</p>
<pre class="programlisting"><i class="hl-comment" style="color: silver">//= require jquery</i>
<i class="hl-comment" style="color: silver">//= require jquery_ujs</i>
<i class="hl-comment" style="color: silver">//= require jquery-ui-1.8.18.custom.min</i>
<i class="hl-comment" style="color: silver">//</i>
<i class="hl-comment" style="color: silver">//= require underscore</i>
<i class="hl-comment" style="color: silver">//= require json2</i>
<i class="hl-comment" style="color: silver">//= require backbone</i>
<i class="hl-comment" style="color: silver">//= require backbone-support</i>
<i class="hl-comment" style="color: silver">//</i>
<i class="hl-comment" style="color: silver">//= require backbone-forms.js</i>
<i class="hl-comment" style="color: silver">//= require jquery-ui-editors.js</i>
<i class="hl-comment" style="color: silver">//= require uploader.js</i>
<i class="hl-comment" style="color: silver">//</i>
<i class="hl-comment" style="color: silver">//= require example_app</i>
<i class="hl-comment" style="color: silver">//</i>
<i class="hl-comment" style="color: silver">//= require_tree ./models</i>
<i class="hl-comment" style="color: silver">//= require_tree ./collections</i>
<i class="hl-comment" style="color: silver">//= require_tree ./views</i>
<i class="hl-comment" style="color: silver">//= require_tree ./routers</i>
<i class="hl-comment" style="color: silver">//= require_tree ../templates</i>
<i class="hl-comment" style="color: silver">//= require_tree .</i></pre>
<p>The above is taken from the example application included with this book. You
can view it at <code class="literal">example_app/app/assets/javascripts/application.js</code>.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_an_overview_of_the_stack_connecting_rails_and_backbone"></a>An overview of the stack: connecting Rails and Backbone</h3></div></div></div>
<p>By default, Backbone communicates with your Rails application via JSON HTTP
requests. If you’ve ever made a JSON API for your Rails app, then
for the most part, this will be very familiar.  If you have not made a JSON API
for your Rails application before, lucky you! It’s pretty straightforward.</p>
<p>This section will briefly touch on each of the major parts of an application
using both Rails and Backbone.  We’ll go into more detail in later chapters,
but this should give you the big picture of how the pieces fit together.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_setting_up_models"></a>Setting up models</h4></div></div></div>
<p>In our example application, we have a Task model, exposed via a JSON API at
<code class="literal">/tasks</code>. The simplest Backbone representation of this model would be as
shown below:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> Task = Backbone.Model.extend({
  urlRoot: <b class="hl-string"><i style="color:red">'/tasks'</i></b>
});</pre>
<p>The <code class="literal">urlRoot</code> property above describes a base for the server-side JSON API that
houses this resource.  Collection-level requests will occur at that root URL,
and requests relating to instances of this model will be found at <code class="literal">/tasks/:id</code>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>There is no need to have a one-to-one mapping between Rails models and
Backbone models.  Backbone models instead correspond with RESTful resources.
Since your Backbone code is in the presentation tier, it’s likely that some of
your Backbone models may end up providing only a subset of the information present
in the Rails models, or they may aggregate information from multiple Rails
models into a composite resource.</p>
</div>
<p>In Rails, it’s possible to access individual tasks, as well as all tasks (and
query all tasks) through the same <code class="literal">Task</code> model. In Backbone, models
only represent the singular representation of a <code class="literal">Task</code>. Backbone splits out the
plural representation of <code class="literal">Tasks</code> into <code class="literal">Collections</code>.</p>
<p>The simplest Backbone collection to represent our <code class="literal">Tasks</code> would be the
following.</p>
<pre class="programlisting"><b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend({
  model: Task
});</pre>
<p>If we specify the URL for <code class="literal">Tasks</code> in our collection instead, then models within
the collection will use the collection’s URL to construct their own URLs, and
the <code class="literal">urlRoot</code> no longer needs to be specified in the model. If we make that
change, then our collection and model will be as follows.</p>
<pre class="programlisting"><b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>
});

<b class="hl-keyword">var</b> Task = Backbone.Model.extend({});</pre>
<p>Notice in the above model definitions that there is no specification of the
attributes on the model. As in ActiveRecord, Backbone models get their
attributes from the data used to populate them at runtime. In this case,
this schema and data are JSON responses from the Rails server.</p>
<p>The default JSON representation of an ActiveRecord model is an object that includes
all the model’s attributes. It does not include the data for any related models
or any methods on the model, but it does include the ids of any <code class="literal">belongs_to</code> relations
as those are stored in a <code class="literal">relation_name_id</code> attribute on the model.</p>
<p>The JSON representation of your ActiveRecord models will be retrieved by
calling <code class="literal">to_json</code> on them, which returns a string of JSON. Customize the output
of <code class="literal">to_json</code> by overriding the <code class="literal">as_json</code> method in your model, which returns a
Ruby data structure like a Hash or Array which will be serialized into the JSON
string.  We’ll touch on this more later in the section, "Customizing your
Rails-generated JSON."</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_setting_up_rails_controllers"></a>Setting up Rails controllers</h4></div></div></div>
<p>The Backbone models and collections will talk to your Rails controllers. The
most basic pattern is one Rails controller providing one family of RESTful
resource to one Backbone model.</p>
<p>By default, Backbone models communicate in the normal RESTful way that Rails
controllers understand, using the proper verbs to support the standard RESTful
Rails controller actions: index, show, create, update, and destroy. Backbone
does not make any use of the new action.</p>
<p>Therefore, it’s just up to us to write a <span class="emphasis"><em>normal</em></span> RESTful controller.  The
newest and most succinct way to structure these is to use the <code class="literal">respond_with</code>
method, introduced in Rails 3.0.</p>
<p>When using <code class="literal">respond_with</code>, declare supported formats with <code class="literal">respond_to</code>. Inside
individual actions, you then specify the resource or resources to be delivered
using <code class="literal">respond_with</code>:</p>
<pre class="programlisting"><b class="hl-keyword">class</b> TasksController &lt; ApplicationController::Base
  respond_to :html, :json

  <b class="hl-keyword">def</b> index
    respond_with(@tasks = Task.all)
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre>
<p>In the above example tasks controller, the <code class="literal">respond_to</code> line declares that this
controller should respond to requests for both the HTML and JSON formats. Then,
in the index action, the <code class="literal">respond_with</code> call will build a response according to
the requested content type (which may be HTML or JSON in this case) and
provided resource, <code class="literal">@tasks</code>.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a id="_validations_and_your_http_api"></a>Validations and your HTTP API</h5></div></div></div>
<p>If a Backbone model has a <code class="literal">validate</code> method defined, it will be validated on
the client side, before its attributes are set. If validation fails, no changes
to the model will occur, and the "error" event will be fired. Your <code class="literal">validate</code>
method will be passed the attributes that are about to be updated. You can
signal that validation passed by returning nothing from your <code class="literal">validate</code> method.
You signify that validation has failed by returning something from the method.
What you return can be as simple as a string, or a more complex object that
describes the error in all its gory detail.</p>
<p>The amount of validation you include on the client side is essentially a
tradeoff between interface performance and code duplication.  It’s important
for the server to make the last call on validation.</p>
<p>So, your Backbone applications will likely rely on at least some server-side
validation logic.  Invalid requests return non-2xx HTTP responses, which
are handled by error callbacks in Backbone:</p>
<pre class="programlisting">task.save({ title: <b class="hl-string"><i style="color:red">"New Task title"</i></b> }, {
  error: <b class="hl-keyword">function</b>() {
    <i class="hl-comment" style="color: silver">// handle error from server</i>
  }
});</pre>
<p>The error callback will be triggered if your server returns a non-2xx
response. Therefore, you’ll want your controller to return a non-2xx HTTP
response code if validations fail.</p>
<p>A controller that does this would appear as shown in the following example:</p>
<pre class="programlisting"><b class="hl-keyword">class</b> TasksController &lt; ApplicationController::Base
  respond_to :json

  <b class="hl-keyword">def</b> create
    @task = Task.new(params[:task])
    <b class="hl-keyword">if</b> @task.save
      respond_with(@task)
    <b class="hl-keyword">else</b>
      respond_with(@task, :status =&gt; :unprocessable_entity)
    <b class="hl-keyword">end</b>
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre>
<p>The default Rails responders will respond with an unprocessable entity (422)
status code when there are validation errors, so the action above can be
refactored:</p>
<pre class="programlisting"><b class="hl-keyword">class</b> TasksController &lt; ApplicationController::Base
  respond_to :json
  <b class="hl-keyword">def</b> create
    @task = Task.new(params[:task])
    @task.save
    respond_with @task
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre>
<p>Your error callback will receive both the model as it was attempted to be
saved and the response from the server. You can take that response and handle
the errors returned by the above controller in whatever way is fit for your
application.</p>
<p>A few different aspects of validations that we saw here are covered in other sections of this book. For more information about validations, see
the "Validations" section of the "Models and Collections" chapter. For more
information about reducing redundancy between client and server validations,
see the "Duplicating business logic across the client and server" section of
the "Models and Collections" chapter. For more information about handling and
displaying errors on the client side, see the "Forms" section of the
"Routers, Views and Templates" chapter.</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_setting_up_views"></a>Setting Up Views</h4></div></div></div>
<p>Most Backbone applications will be a single-page app, or "SPA." This means that
your Rails application handles two jobs: First, it renders a single page which
hosts your Backbone application and, optionally, an initial data set for it to
use. From there, ongoing interaction with your Rails application occurs via
HTTP JSON APIs.</p>
<p>For our example application, this host page will be located at <code class="literal">Tasks#index</code>,
which is also routed to the root route.</p>
<p>You will want to create an object in JavaScript for your Backbone application.
Generally, we use this object as a top-level namespace for other Backbone
classes, as well as a place to hold initialization code.  For more information
on this namespacing see the "Namespacing your application" section of the
Organization chapter.</p>
<p>This application object will look like the following:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> ExampleApp = {
  Models: {},
  Collections: {},
  Views: {},
  Routers: {},
  initialize: <b class="hl-keyword">function</b>(data) {
    <b class="hl-keyword">var</b> tasks = <b class="hl-keyword">new</b> ExampleApp.Collections.Tasks(data.tasks);
    <b class="hl-keyword">new</b> ExampleApp.Routers.Tasks({ tasks: tasks });
    Backbone.history.start();
  }
};</pre>
<p>You can find this file in the example app in
<code class="literal">app/assets/javascripts/example_app.js</code>.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Important</h3>
<p>You must instantiate a Backbone router before calling
<code class="literal">Backbone.history.start()</code> otherwise <code class="literal">Backbone.history</code> will be <code class="literal">undefined</code>.</p>
</div>
<p>Then, inside <code class="literal">app/views/tasks/index.html.erb</code> you will call the <code class="literal">initialize</code> method.
You will often bootstrap data into the Backbone application to provide initial
state.  In our example, the tasks have already been provided to the Rails view
in an <code class="literal">@tasks</code> instance variable:</p>
<pre class="programlisting">&lt;%= content_for :javascript <b class="hl-keyword">do</b> -%&gt;
  &lt;%= javascript_tag <b class="hl-keyword">do</b> %&gt;
    ExampleApp.initialize({ tasks: &lt;%== @tasks.to_json %&gt; });
  &lt;% end %&gt;
&lt;% end -%&gt;</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>The above example uses ERB to pass the JSON for the tasks to the <code class="literal">initialize</code>
method, but we should be mindful of the XSS risks that dumping user-generated
content here poses.  See the "Encoding data when bootstrapping JSON data"
section in the "Security" chapter for a more secure approach.</p>
</div>
<p>Finally, you must have a Router in place that knows what to do.  We’ll cover
routers in more detail in the "Routers, Views and Templates" chapter.</p>
<pre class="programlisting">ExampleApp.Routers.Tasks = Backbone.Router.extend({
  routes: {
    <b class="hl-string"><i style="color:red">""</i></b>: <b class="hl-string"><i style="color:red">"index"</i></b>
  },

  index: <b class="hl-keyword">function</b>() {
    <i class="hl-comment" style="color: silver">// We've reached the end of Rails integration - it's all Backbone from here!</i>

    alert(<b class="hl-string"><i style="color:red">'Hello, world!  This is a Backbone router action.'</i></b>);

    <i class="hl-comment" style="color: silver">// Normally you would continue down the stack, instantiating a</i>
    <i class="hl-comment" style="color: silver">// Backbone.View class, calling render() on it, and inserting its element</i>
    <i class="hl-comment" style="color: silver">// into the DOM.</i>

    <i class="hl-comment" style="color: silver">// We'll pick back up here in the "Converting Views" section.</i>
  }
});</pre>
<p>The example router above is the last piece needed to complete our
initial Backbone infrastructure. When a user visits <code class="literal">/tasks</code>, the
<code class="literal">index.html.erb</code> Rails view will be rendered, which properly initializes
Backbone and its dependencies and the Backbone models, collections, routers,
and views.</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_customizing_your_rails_generated_json"></a>Customizing your Rails-generated JSON</h3></div></div></div>
<p>There are a few common things you’ll do in your Rails app when working with
Backbone.</p>
<p>First, it’s likely that you’ll want to switch from including all attributes,
which is the default, to delivering some subset.</p>
<p>This can be done by specifying explicitly only the attributes that are to be
included (whitelisting), or specifying the attributes that should <span class="emphasis"><em>not</em></span> be
included (blacklisting). Which one you choose will depend on how many attributes
your model has and how paranoid you are about something important appearing in
the JSON when it shouldn’t be there.</p>
<p>If you’re concerned about sensitive data unintentionally being included in the
JSON when it shouldn’t be, then you’ll want to whitelist attributes into the
JSON with the <code class="literal">:only</code> option:</p>
<pre class="programlisting"><b class="hl-keyword">def</b> as_json(options = {})
  <b class="hl-keyword">super</b>(options.merge(:only =&gt; [ :id, :title ]))
<b class="hl-keyword">end</b></pre>
<p>The above <code class="literal">as_json</code> override will make it so that the JSON will <span class="emphasis"><em>only</em></span> include the
id and title attributes, even if there are many other attributes on the model.</p>
<p>If instead you want to include all attributes by default and just exclude a few,
you accomplish this with the <code class="literal">:except</code> option:</p>
<pre class="programlisting"><b class="hl-keyword">def</b> as_json(options = {})
  <b class="hl-keyword">super</b>(options.merge(:except =&gt; [ :encrypted_password ]))
<b class="hl-keyword">end</b></pre>
<p>Another common customization you will want to do in the JSON is include the
output of methods (say, calculated values) on your model. This is accomplished
with the <code class="literal">:methods</code> option, as shown in the following example:</p>
<pre class="programlisting"><b class="hl-keyword">def</b> as_json(options = {})
  <b class="hl-keyword">super</b>(options.merge(:methods =&gt; [ :calculated_value ]))
<b class="hl-keyword">end</b></pre>
<p>The final thing you’ll most commonly do with your JSON is include related
objects. If the <code class="literal">Task</code> model <code class="literal">has_many :comments</code>, include all of the JSON for
comments in the JSON for a Task with the <code class="literal">:include</code> option:</p>
<pre class="programlisting"><b class="hl-keyword">def</b> as_json(options = {})
  <b class="hl-keyword">super</b>(options.merge(:include =&gt; [ :comments ]))
<b class="hl-keyword">end</b></pre>
<p>As you may have guessed, you can then customize the JSON for the comments by
overriding the <code class="literal">as_json</code> method on the <code class="literal">Comment</code> model.</p>
<p>While this is the most common set of <code class="literal">as_json</code> options you’ll use when working with
Backbone, it certainly isn’t all of them. The official, complete
documentation for the <code class="literal">as_json</code> method can be found here:
<a class="ulink" href="http://apidock.com/rails/ActiveModel/Serializers/JSON/as_json" target="_top">http://apidock.com/rails/ActiveModel/Serializers/JSON/as_json</a></p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_activerecord_base_include_root_in_json"></a>ActiveRecord::Base.include_root_in_json</h4></div></div></div>
<p>Depending on the versions, Backbone and Rails may have different expectations
about the format of JSON structures; specifically, whether or not a root key is
present.  When generating JSON from Rails, this is controlled by the
ActiveRecord setting <code class="literal">ActiveRecord::Base.include_root_in_json</code>.</p>
<pre class="programlisting">  &gt; ActiveRecord::Base.include_root_in_json = <b class="hl-keyword">false</b>
  &gt; Task.last.as_json
 =&gt; {<b class="hl-string"><i style="color:red">"id"</i></b>=&gt;<span class="hl-number">4</span>, <b class="hl-string"><i style="color:red">"title"</i></b>=&gt;<b class="hl-string"><i style="color:red">"Enjoy a three mile swim"</i></b>}

  &gt; ActiveRecord::Base.include_root_in_json = <b class="hl-keyword">true</b>
  &gt; Task.last.as_json
 =&gt; {<b class="hl-string"><i style="color:red">"task"</i></b>=&gt;{<b class="hl-string"><i style="color:red">"id"</i></b>=&gt;<span class="hl-number">4</span>, <b class="hl-string"><i style="color:red">"title"</i></b>=&gt;<b class="hl-string"><i style="color:red">"Enjoy a three mile swim"</i></b>}}</pre>
<p>In Rails 3.0, <code class="literal">ActiveRecord::Base.include_root_in_json</code> is set to "true." In 3.1,
it defaults to "false." This reversal was made to simplify the JSON returned by
default in Rails application, but it is a fairly big change from the default
behavior of Rails 3.0.</p>
<p>Practically speaking, this change is a good one, but take particular note if
you’re upgrading an existing Rails 3.0 application to Rails 3.1 and you already
have a published API; you may need to expose a new version of your API.</p>
<p>From the Backbone side, the default behavior expects no root node.  This
behavior is defined in a few places: <code class="literal">Backbone.Collection.prototype.parse</code>,
<code class="literal">Backbone.Model.prototype.parse</code>, and <code class="literal">Backbone.Model.prototype.toJSON</code>:</p>
<pre class="programlisting">_.extend(Backbone.Collection.<b class="hl-keyword">prototype</b>, Backbone.Events, {
  <i class="hl-comment" style="color: silver">// http://documentcloud.github.com/backbone/#Collection-parse</i>
  parse : <b class="hl-keyword">function</b>(resp, xhr) {
    <b class="hl-keyword">return</b> resp;
  },

  <i class="hl-comment" style="color: silver">// snip...</i>
});

_.extend(Backbone.Model.<b class="hl-keyword">prototype</b>, Backbone.Events, {
  <i class="hl-comment" style="color: silver">// http://documentcloud.github.com/backbone/#Model-toJSON</i>
  toJSON : <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> _.clone(<b class="hl-keyword">this</b>.attributes);
  },

  <i class="hl-comment" style="color: silver">// http://documentcloud.github.com/backbone/#Model-parse</i>
  parse : <b class="hl-keyword">function</b>(resp, xhr) {
    <b class="hl-keyword">return</b> resp;
  },

  <i class="hl-comment" style="color: silver">// snip...</i>
});</pre>
<p>If you need to accept JSON with a root node, you can override <code class="literal">parse</code> in each of
your models, or override the prototype’s function.  You’ll need to override it
on the appropriate collection(s), too.</p>
<p>If you need to send JSON back to a server that includes a root node, you can
override <code class="literal">toJSON</code>, per model or across all models.  When you do this, you’ll
need to explicitly specify the name of the root key.  We use a convention of a
<code class="literal">modelName</code> function on your model to provide this:</p>
<pre class="programlisting">Backbone.Model.<b class="hl-keyword">prototype</b>.toJSON = <b class="hl-keyword">function</b>() {
  <b class="hl-keyword">var</b> hashWithRoot = {};
  hashWithRoot[<b class="hl-keyword">this</b>.modelName] = <b class="hl-keyword">this</b>.attributes;
  <b class="hl-keyword">return</b> _.clone(hashWithRoot);
};

<b class="hl-keyword">var</b> Task = Backbone.Model.extend({
  modelName: <b class="hl-string"><i style="color:red">"task"</i></b>,

  <i class="hl-comment" style="color: silver">// ...</i>
});</pre>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_converting_an_existing_page_view_area_to_use_backbone"></a>Converting an existing page/view area to use Backbone</h3></div></div></div>
<p>This section is meant to get you started understanding how Backbone views
work by illustrating the conversion of a Rails view to a Backbone view.</p>
<p>Its important to note that a Rails view is not directly analogous to a Backbone
view. In Rails, the term "view" usually refers to an HTML template, where
Backbone views are classes that contain event handling and presentation logic.</p>
<p>Consider the following Rails view for a tasks index:</p>
<pre class="programlisting"><b class="hl-tag" style="color: #000096">&lt;h1&gt;</b>Tasks<b class="hl-tag" style="color: #000096">&lt;/h1&gt;</b>

<b class="hl-tag" style="color: #000096">&lt;table&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;tr&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;th&gt;</b>Title<b class="hl-tag" style="color: #000096">&lt;/th&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;th&gt;</b>Completed<b class="hl-tag" style="color: #000096">&lt;/th&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;/tr&gt;</b>

  <b class="hl-tag" style="color: #000096">&lt;%</b> <span class="hl-attribute" style="color: #F5844C">@tasks.each</span> <span class="hl-attribute" style="color: #F5844C">do</span> <span class="hl-attribute" style="color: #F5844C">|task|</span> <span class="hl-attribute" style="color: #F5844C">%&gt;</span>
    <span class="hl-attribute" style="color: #F5844C">&lt;tr&gt;</span>
      <span class="hl-attribute" style="color: #F5844C">&lt;td&gt;&lt;%</span>= <span class="hl-value" style="color: #993300">task.title</span> <span class="hl-attribute" style="color: #F5844C">%&gt;&lt;/td&gt;</span>
      <span class="hl-attribute" style="color: #F5844C">&lt;td&gt;&lt;%</span>= <span class="hl-value" style="color: #993300">task.completed</span> <span class="hl-attribute" style="color: #F5844C">%&gt;&lt;/td&gt;</span>
    <span class="hl-attribute" style="color: #F5844C">&lt;/tr&gt;</span>
  <span class="hl-attribute" style="color: #F5844C">&lt;%</span> <span class="hl-attribute" style="color: #F5844C">end</span> <span class="hl-attribute" style="color: #F5844C">%&gt;</span>
<span class="hl-attribute" style="color: #F5844C">&lt;/table&gt;</span></pre>
<p>So far, we have the Backbone <code class="literal">Task</code> model and collection and the Rails <code class="literal">Task</code>
model and controller discussed above, and we’re bootstrapping the Backbone app
with all the tasks.  Next, we will create a Backbone view which will render a
corresponding Backbone template.</p>
<p>A Backbone view is a class that is responsible for rendering the display of a
logical element on the page. A view also binds to DOM events occurring within
its DOM scope that trigger various behaviors.</p>
<p>We’ll start with a basic view that achieves the same result as the Rails template
above, rendering a collection of tasks:</p>
<pre class="programlisting">ExampleApp.Views.TasksIndex = Backbone.View.extend({
  render: <b class="hl-keyword">function</b> () {
    <b class="hl-keyword">this</b>.$el.html(JST[<b class="hl-string"><i style="color:red">'tasks/index'</i></b>]({ tasks: <b class="hl-keyword">this</b>.collection }));
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>;
  }
};</pre>
<p>The <code class="literal">render</code> method above renders the <span class="emphasis"><em>tasks/index</em></span> JST template, passing
the collection of tasks into the template.</p>
<p>Each Backbone view has an element that it stores in <code class="literal">this.$el</code>.  This element
can be populated with content, although it’s a good practice for code outside
the view to actually insert the view into the DOM.</p>
<p>We’ll update the Backbone route to instantiate this view, passing in the
collection for it to render. The router then renders the view, and inserts it
into the DOM:</p>
<pre class="programlisting">ExampleApp.Routers.Tasks = Backbone.Router.extend({
  routes: {
    <b class="hl-string"><i style="color:red">""</i></b>: <b class="hl-string"><i style="color:red">"index"</i></b>
  },

  index: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> view = <b class="hl-keyword">new</b> ExampleApp.Views.TasksIndex({ collection: ExampleApp.tasks });
    $(<b class="hl-string"><i style="color:red">'body'</i></b>).html(view.render().$el);
  }
});</pre>
<p>Now that we have the Backbone view in place that renders the template, and
it’s being called by the router, we can focus on converting the above Rails
view to a Backbone template.</p>
<p>Backbone depends on Underscore.js which, among many things, provides
templating.  The delimiter and basic concepts used for Underscore.js
templates and ERB are the same.  When converting an existing Rails application
to Backbone, this similarity can help ease the transition.</p>
<p>The <code class="literal">tasks/index</code> JST template does two things:</p>
<div class="itemizedlist"><ul type="disc">
<li>
Loops over all of the tasks
</li>
<li>
For each task, it outputs the task title and completed attributes
</li>
</ul></div>
<p>Underscore.js provides many iteration functions that will be familiar to Rails
developers such as  <code class="literal">_.each</code>, <code class="literal">_.map</code>, and <code class="literal">_.reject</code>. Backbone also proxies to
Underscore.js to provide these iteration functions as methods on <code class="literal">Backbone.Collection</code>.</p>
<p>We’ll use the <code class="literal">each</code> method to iterate through the <code class="literal">Tasks</code> collection that was
passed to the view, as shown in the converted Underscore.js template below:</p>
<pre class="programlisting"><b class="hl-tag" style="color: #000096">&lt;h1&gt;</b>Tasks<b class="hl-tag" style="color: #000096">&lt;/h1&gt;</b>

<b class="hl-tag" style="color: #000096">&lt;table&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;tr&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;th&gt;</b>Title<b class="hl-tag" style="color: #000096">&lt;/th&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;th&gt;</b>Completed<b class="hl-tag" style="color: #000096">&lt;/th&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;/tr&gt;</b>

  <b class="hl-tag" style="color: #000096">&lt;%</b> <span class="hl-attribute" style="color: #F5844C">tasks.each(function(model)</span> <span class="hl-attribute" style="color: #F5844C">{</span> <span class="hl-attribute" style="color: #F5844C">%&gt;</span>
    <span class="hl-attribute" style="color: #F5844C">&lt;tr&gt;</span>
      <span class="hl-attribute" style="color: #F5844C">&lt;td&gt;&lt;%</span>= <span class="hl-value" style="color: #993300">model.escape('title')</span> <span class="hl-attribute" style="color: #F5844C">%&gt;&lt;/td&gt;</span>
      <span class="hl-attribute" style="color: #F5844C">&lt;td&gt;&lt;%</span>= <span class="hl-value" style="color: #993300">model.escape('completed')</span> <span class="hl-attribute" style="color: #F5844C">%&gt;&lt;/td&gt;</span>
    <span class="hl-attribute" style="color: #F5844C">&lt;/tr&gt;</span>
  <span class="hl-attribute" style="color: #F5844C">&lt;%</span> <span class="hl-attribute" style="color: #F5844C">});</span> <span class="hl-attribute" style="color: #F5844C">%&gt;</span>
<span class="hl-attribute" style="color: #F5844C">&lt;/table&gt;</span></pre>
<p>In Rails 3.0 and above, template output is HTML-escaped by default. In order to
ensure that we have the same XSS protection as we did in our Rails template, we
access and output the Backbone model attributes using the <code class="literal">escape</code> method
instead of the normal <code class="literal">get</code> method.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_breaking_out_the_taskview"></a>Breaking out the TaskView</h4></div></div></div>
<p>In Backbone, views are often bound to an underlying model, re-rendering
themselves when the model data changes.  Consider what happens when any task
changes data with our approach above; the entire collection must be
re-rendered.  It’s useful to break up these composite views into two separate
classes, each with their own responsibility: a parent view that handles the
aggregation, and a child view responsible for rendering each node of content.</p>
<p>With each of the <code class="literal">Task</code> models represented by an individual <code class="literal">TaskView</code>,
changes to an individual model are broadcast to its corresponding <code class="literal">TaskView</code>,
which re-renders only the markup for one task.</p>
<p>Continuing our example from above, a <code class="literal">TaskView</code> will be responsible for
rendering just the individual table row for a <code class="literal">Task</code>:</p>
<pre class="programlisting"><b class="hl-tag" style="color: #000096">&lt;tr&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;td&gt;</b><b class="hl-tag" style="color: #000096">&lt;%=</b> <span class="hl-attribute" style="color: #F5844C">model.escape('title')</span> <span class="hl-attribute" style="color: #F5844C">%&gt;&lt;/td&gt;</span>
  <span class="hl-attribute" style="color: #F5844C">&lt;td&gt;&lt;%</span>= <span class="hl-value" style="color: #993300">model.escape('completed')</span> <span class="hl-attribute" style="color: #F5844C">%&gt;&lt;/td&gt;</span>
<span class="hl-attribute" style="color: #F5844C">&lt;/tr&gt;</span></pre>
<p>And the Task index template will be changed to appear as shown below:</p>
<pre class="programlisting"><b class="hl-tag" style="color: #000096">&lt;h1&gt;</b>Tasks<b class="hl-tag" style="color: #000096">&lt;/h1&gt;</b>

<b class="hl-tag" style="color: #000096">&lt;table&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;tr&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;th&gt;</b>Title<b class="hl-tag" style="color: #000096">&lt;/th&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;th&gt;</b>Completed<b class="hl-tag" style="color: #000096">&lt;/th&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;/tr&gt;</b>

  <i class="hl-comment" style="color: silver">&lt;!-- child content will be rendered here --&gt;</i>

<b class="hl-tag" style="color: #000096">&lt;/table&gt;</b></pre>
<p>As you can see above in the index template, the individual tasks are no longer
iterated over and rendered inside the table, but instead within the
<code class="literal">TasksIndex</code> and <code class="literal">TaskView</code> views, respectively:</p>
<pre class="programlisting">ExampleApp.Views.TaskView = Backbone.View.extend({
  render: <b class="hl-keyword">function</b> () {
    <b class="hl-keyword">this</b>.$el.html(JST[<b class="hl-string"><i style="color:red">'tasks/view'</i></b>]({ model: <b class="hl-keyword">this</b>.model }));
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>;
  }
});</pre>
<p>The <code class="literal">TaskView</code> view above is very similar to the one we saw previously for the
<code class="literal">TasksIndex</code> view.  It is only responsible for rendering the contents of its own
element, and the concern of assembling the view of the list is left to the
parent view object:</p>
<pre class="programlisting">ExampleApp.Views.TasksIndex = Backbone.View.extend({
  render: <b class="hl-keyword">function</b> () {
    <b class="hl-keyword">var</b> self = <b class="hl-keyword">this</b>;

    <b class="hl-keyword">this</b>.$el.html(JST[<b class="hl-string"><i style="color:red">'tasks/index'</i></b>]()); <i class="hl-comment" style="color: silver">// Note that no collection is needed</i>
                                         <i class="hl-comment" style="color: silver">// to build the container markup.</i>

    <b class="hl-keyword">this</b>.collection.each(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">var</b> taskView = <b class="hl-keyword">new</b> ExampleApp.Views.TaskView({ model: task });
      self.$(<b class="hl-string"><i style="color:red">'table'</i></b>).append(taskView.render().el);
    });

    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>;
  }
});</pre>
<p>In the new <code class="literal">TasksIndex</code> view above, the <code class="literal">tasks</code> collection is iterated over. For
each task, a new <code class="literal">TaskView</code> is instantiated, rendered, and then inserted into
the <code class="literal">&lt;table&gt;</code> element.</p>
<p>If you look at the output of the <code class="literal">TasksIndex</code>, it will appear as follows:</p>
<pre class="programlisting"><b class="hl-tag" style="color: #000096">&lt;div&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;h1&gt;</b>Tasks<b class="hl-tag" style="color: #000096">&lt;/h1&gt;</b>

  <b class="hl-tag" style="color: #000096">&lt;table&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;tr&gt;</b>
      <b class="hl-tag" style="color: #000096">&lt;th&gt;</b>Title<b class="hl-tag" style="color: #000096">&lt;/th&gt;</b>
      <b class="hl-tag" style="color: #000096">&lt;th&gt;</b>Completed<b class="hl-tag" style="color: #000096">&lt;/th&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;/tr&gt;</b>

    <b class="hl-tag" style="color: #000096">&lt;div&gt;</b>
      <b class="hl-tag" style="color: #000096">&lt;tr&gt;</b>
        <b class="hl-tag" style="color: #000096">&lt;td&gt;</b>Task 1<b class="hl-tag" style="color: #000096">&lt;/td&gt;</b>
        <b class="hl-tag" style="color: #000096">&lt;td&gt;</b>true<b class="hl-tag" style="color: #000096">&lt;/td&gt;</b>
      <b class="hl-tag" style="color: #000096">&lt;/tr&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;/div&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;div&gt;</b>
      <b class="hl-tag" style="color: #000096">&lt;tr&gt;</b>
        <b class="hl-tag" style="color: #000096">&lt;td&gt;</b>Task 2<b class="hl-tag" style="color: #000096">&lt;/td&gt;</b>
        <b class="hl-tag" style="color: #000096">&lt;td&gt;</b>false<b class="hl-tag" style="color: #000096">&lt;/td&gt;</b>
      <b class="hl-tag" style="color: #000096">&lt;/tr&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;/div&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;/table&gt;</b>
<b class="hl-tag" style="color: #000096">&lt;/div&gt;</b></pre>
<p>Unfortunately, we can see that there is a problem with the above rendered
view: the surrounding div around each of the rendered tasks.</p>
<p>Each of the rendered tasks has a surrounding div because this is the element
that each view has that is accessed via <code class="literal">this.el</code>, and what the view’s content
is inserted into. By default, this element is a div and therefore every view
will be wrapped in an extra div. While sometimes this extra div doesn’t really
matter, as in the outermost div that wraps the entire index, other times this
produces invalid markup.</p>
<p>Fortunately, Backbone provides us with a clean and simple mechanism for
changing the element to something other than a div. In the case of the
<code class="literal">TaskView</code>, we would like this element to be a tr, then the wrapping tr can be
removed from the task view template.</p>
<p>The element to use is specified by the <code class="literal">tagName</code> member of the <code class="literal">TaskView</code>, as
shown below:</p>
<pre class="programlisting">ExampleApp.Views.TaskView = Backbone.View.extend({
  tagName: <b class="hl-string"><i style="color:red">"tr"</i></b>,

  initialize: <b class="hl-keyword">function</b>() {
  },

  render: <b class="hl-keyword">function</b> () {
    <b class="hl-keyword">this</b>.$el.html(JST[<b class="hl-string"><i style="color:red">'tasks/view'</i></b>]({ model: <b class="hl-keyword">this</b>.model }));
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>;
  }
};</pre>
<p>Given the above <code class="literal">tagName</code> customization, the task view template will appear as
follows:</p>
<pre class="programlisting"><b class="hl-tag" style="color: #000096">&lt;td&gt;</b><b class="hl-tag" style="color: #000096">&lt;%=</b> <span class="hl-attribute" style="color: #F5844C">model.escape('title')</span> <span class="hl-attribute" style="color: #F5844C">%&gt;&lt;/td&gt;</span>
<span class="hl-attribute" style="color: #F5844C">&lt;td&gt;&lt;%</span>= <span class="hl-value" style="color: #993300">model.escape('completed')</span> <span class="hl-attribute" style="color: #F5844C">%&gt;&lt;/td&gt;</span></pre>
<p>And the resulting output of the <code class="literal">TasksIndex</code> will be much cleaner, as shown
below:</p>
<pre class="programlisting"><b class="hl-tag" style="color: #000096">&lt;div&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;h1&gt;</b>Tasks<b class="hl-tag" style="color: #000096">&lt;/h1&gt;</b>

  <b class="hl-tag" style="color: #000096">&lt;table&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;tr&gt;</b>
      <b class="hl-tag" style="color: #000096">&lt;th&gt;</b>Title<b class="hl-tag" style="color: #000096">&lt;/th&gt;</b>
      <b class="hl-tag" style="color: #000096">&lt;th&gt;</b>Completed<b class="hl-tag" style="color: #000096">&lt;/th&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;/tr&gt;</b>

    <b class="hl-tag" style="color: #000096">&lt;tr&gt;</b>
      <b class="hl-tag" style="color: #000096">&lt;td&gt;</b>Task 1<b class="hl-tag" style="color: #000096">&lt;/td&gt;</b>
      <b class="hl-tag" style="color: #000096">&lt;td&gt;</b>true<b class="hl-tag" style="color: #000096">&lt;/td&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;/tr&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;tr&gt;</b>
      <b class="hl-tag" style="color: #000096">&lt;td&gt;</b>Task 2<b class="hl-tag" style="color: #000096">&lt;/td&gt;</b>
      <b class="hl-tag" style="color: #000096">&lt;td&gt;</b>false<b class="hl-tag" style="color: #000096">&lt;/td&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;/tr&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;/table&gt;</b>
<b class="hl-tag" style="color: #000096">&lt;/div&gt;</b></pre>
<p>We’ve now covered the basic building blocks of converting Rails views to
Backbone and getting a functional system. The majority of Backbone programming
you will do will likely be in the views and templates, and there is a lot more
to them: event binding, different templating strategies, helpers, event
unbinding, and more. Those topics are covered in the "Routers, Views, and
Templates" chapter.</p>
</div>
</div>
</div>

    </div>

    <hr/>

    <div class="nav" id="navfooter">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="organization.html">Prev</a><br/>
         Organization
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         Backbone.js on Rails
        
      </td><td width="33%" align="right">
        
          <a href="routers_views_and_templates.html">Next</a><br/>
          Routers, Views, and Templates
        
      </td></tr>
    </table>
    </div>
  </body>
</html>
