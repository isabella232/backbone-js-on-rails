<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="master.css" type="text/css" />
    <title>Rails Integration</title>
  </head>

  <body>
    <div class="nav" id="navheader">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="organization.html">Prev</a><br/>
         Organization
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         <strong>Backbone.js on Rails</strong>
        
      </td><td width="33%" align="right">
        
          <a href="views_and_templates.html">Next</a><br/>
          Views and Templates
        
      </td></tr>
    </table>
    </div>

    <hr/>

    <div class="content">
      <div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a id="_rails_integration"></a>Rails Integration</h2></div></div></div>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_organizing_your_backbone_js_code_in_a_rails_app"></a>Organizing your Backbone.js code in a Rails app</h3></div></div></div>
<p>When using Backbone.js in a Rails app, you’ll have two kinds of Backbone.js-related assets: classes, and templates.</p>
</div>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_rails_3_0_and_prior"></a>Rails 3.0 and prior</h3></div></div></div>
<p>With Rails 3.0 and prior, store your Backbone.js classes in <code class="literal">public/javascripts</code>:</p>
<pre class="screen">public/
  javascripts/
    jquery.js
    jquery-ui.js
    models/
      user.js
      todo.js
    routers/
      users_router.js
      todos_router.js
    views/
      users/
        users_index.js
        users_new.js
        users_edit.js
      todos/
        todos_index.js</pre>
<p>If you are using templates, we prefer storing them in <code class="literal">app/templates</code> to keep them separated from the server views:</p>
<pre class="screen">app/
  views/
    pages/
      home.html.erb
      terms.html.erb
      privacy.html.erb
      about.html.erb
  templates/
    users/
      index.jst
      new.jst
      edit.jst
    todos/
      index.jst
      show.jst</pre>
<p>On Rails 3.0 and prior apps, we use Jammit for packaging assets and precompiling templates:</p>
<p><a class="ulink" href="http://documentcloud.github.com/jammit/" target="_top">http://documentcloud.github.com/jammit/</a>
<a class="ulink" href="http://documentcloud.github.com/jammit/#jst" target="_top">http://documentcloud.github.com/jammit/#jst</a></p>
<p>Jammit will make your templates available in a top-level JST object. For example, to access the above todos/index.jst template, you would refer to it as:</p>
<pre class="programlisting">JST['todos/index']</pre>
<p>Variables can be passed to the templates by passing a Hash to the template, as shown below.</p>
<pre class="programlisting">JST['todos/index']({ model: this.model })</pre>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_a_note_on_jammit_and_a_jst_naming_gotcha"></a>A note on Jammit and a JST naming gotcha</h4></div></div></div>
<p>One issue with Jammit that we’ve encountered and worked around is that the JST template path can change when adding new templates.</p>
<p>When using Jammit, there is a slightly sticky issue as an app grows from one template subdirectory to multiple template subdirectories.</p>
<p>Let’s say you place templates in app/templates. You work for a while on the "Tasks" feature, placing templates under app/templates/tasks. So, window.JST looks something like:</p>
<pre class="programlisting">JST['form']
JST['show']
JST['index']</pre>
<p>Now, you add another directory under app/templates, say app/templates/user. Now, all JST references are prefixed with their parent directory name so they are unambiguous:</p>
<pre class="programlisting">JST['tasks/form']
JST['tasks/show']
JST['tasks/index']
JST['users/new']
JST['users/show']
JST['users/index']</pre>
<p>This breaks existing JST references. You can work around this issue by applying the following monkeypatch to Jammit, in config/initializers/jammit.rb</p>
<pre class="programlisting">Jammit::Compressor.class_eval do
  private
  def find_base_path(path)
    File.expand_path(Rails.root.join('app','templates'))
  end
end</pre>
<p>As applications are moving to Rails 3.1, they’re also moving to Sprockets for the asset packager.  Until then, many apps are using Jammit for asset packaging.  One issue with Jammit we’ve encountered and worked around is that the JST template path can change when adding new templates.  We have an open issue and workaround:</p>
<p><a class="ulink" href="https://github.com/documentcloud/jammit/issues/192" target="_top">https://github.com/documentcloud/jammit/issues/192</a></p>
</div>
</div>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_rails_3_1"></a>Rails 3.1</h3></div></div></div>
<p>Rails 3.1 introduces the asset pipeline:</p>
<p><a class="ulink" href="http://edgeguides.rubyonrails.org/asset_pipeline.html" target="_top">http://edgeguides.rubyonrails.org/asset_pipeline.html</a></p>
<p>which uses the Sprockets library for preprocessing and packaging assets:</p>
<p><a class="ulink" href="http://getsprockets.org/" target="_top">http://getsprockets.org/</a></p>
<p>To take advantage of the built-in asset pipeline, organize your Backbone.js templates and classes in paths available to the asset pipeline.  Classes go in <code class="literal">app/assets/javascripts/</code>, and templates go alongside, in <code class="literal">app/assets/templates/</code>:</p>
<pre class="screen">app/
  assets/
    javascripts/
      jquery.js
      models/
        todo.js
      routers/
        todos_router.js
      views/
        todos/
          todos_index.js
    templates/
      todos/
        index.jst.ejs
        show.jst.ejs</pre>
<p>Using Sprockets' preprocessors, we can use templates as before.  Here, we’re using the EJS template preprocessor to provide the same functionality as Underscore.js' templates.  It compiles the <code class="literal">*.jst</code> files and makes them available on the client side via the <code class="literal">window.JST</code> object. Identifying the <code class="literal">.ejs</code> extension and invoking EJS to compile the templates is managed by Sprockets, and requires the <code class="literal">ejs</code> gem to be included in the application Gemfile.</p>
<p>Underscore.js templates:
<a class="ulink" href="http://documentcloud.github.com/underscore/#template" target="_top">http://documentcloud.github.com/underscore/#template</a></p>
<p>EJS gem:
<a class="ulink" href="https://github.com/sstephenson/ruby-ejs" target="_top">https://github.com/sstephenson/ruby-ejs</a></p>
<p>Sprockets support for EJS:
<a class="ulink" href="https://github.com/sstephenson/sprockets/blob/master/lib/sprockets/ejs_template.rb" target="_top">https://github.com/sstephenson/sprockets/blob/master/lib/sprockets/ejs_template.rb</a></p>
</div>
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title">
<a id="_converting_your_rails_models_to_backbone_js_friendly_json_chapter_unstarted"></a>Converting your Rails models to Backbone.js-friendly JSON (chapter unstarted)</h3></div></div></div></div>
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title">
<a id="_converting_an_existing_page_view_area_to_use_backbone_js_chapter_unstarted"></a>Converting an existing page/view area to use Backbone.js (chapter unstarted)</h3></div></div></div></div>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_automatically_using_the_rails_authentication_token"></a>Automatically using the Rails authentication token</h3></div></div></div>
<p>When using Backbone.js in a Rails app, you will run into a conflict with the Rails built in Cross Site Scripting (XSS) protection.</p>
<p>When Rails XSS is enabled, each POST or PUT request to Rails should include a special token which is verified to ensure that the request originated from a user which is actually using the Rails app. In recent versions of Rails, Backbone.js Ajax requests are no exception.</p>
<p>To get around this, you have two options. Disable Rails XSS protection (not recommended), or make Backbone.js play nicely with Rails XSS.</p>
<p>To make Backbone.js play nicely with Rails XSS you can monkeypatch Backbone.js to include the Rails XSS token in any requests it makes.</p>
<p>The following is one such script.</p>
<pre class="programlisting">//
// With additions by Maciej Adwent http://github.com/Maciek416
// If token name and value are not supplied, this code Requires jQuery
//
// Adapted from:
// http://www.ngauthier.com/2011/02/backbone-and-rails-forgery-protection.html
// Nick Gauthier @ngauthier
//

var BackboneRailsAuthTokenAdapter = {

  //
  // Given an instance of Backbone, route its sync() function so that
  // it executes through this one first, which mixes in the CSRF
  // authenticity token that Rails 3 needs to protect requests from
  // forgery. Optionally, the token's name and value can be supplied
  // by the caller.
  //
  fixSync: function(Backbone, paramName /*optional*/, paramValue /*optional*/){

    if(typeof(paramName)=='string' &amp;&amp; typeof(paramValue)=='string'){
      // Use paramName and paramValue as supplied
    } else {
      // Assume we've rendered meta tags with erb
      paramName = $("meta[name='csrf-param']").attr('content');
      paramValue = $("meta[name='csrf-token']").attr('content');
    }

    // alias away the sync method
    Backbone._sync = Backbone.sync;

    // define a new sync method
    Backbone.sync = function(method, model, success, error) {

      // only need a token for non-get requests
      if (method == 'create' || method == 'update' || method == 'delete') {

        // grab the token from the meta tag rails embeds
        var auth_options = {};
        auth_options[paramName] = paramValue;

        // set it as a model attribute without triggering events
        model.set(auth_options, {silent: true});
      }

      // proxy the call to the old sync method
      return Backbone._sync(method, model, success, error);
    };
  },


  // change Backbone's sync function back to the original one
  restoreSync: function(Backbone){
    Backbone.sync = Backbone._sync;
  }
};</pre>
<p>The above patch depends on jQuery, and should be included in your after jQuery and Backbone.js are loaded. Using Jammit, you’d list it below the backbone.js file.</p>
</div>
</div>

    </div>

    <hr/>

    <div class="nav" id="navfooter">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="organization.html">Prev</a><br/>
         Organization
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         Backbone.js on Rails
        
      </td><td width="33%" align="right">
        
          <a href="views_and_templates.html">Next</a><br/>
          Views and Templates
        
      </td></tr>
    </table>
    </div>
  </body>
</html>
