<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="master.css" type="text/css" />
    <title>Models and collections</title>
  </head>

  <body>
    <div class="nav" id="navheader">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="routers_views_and_templates.html">Prev</a><br/>
         Routers, Views, and Templates
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         <strong>Backbone.js on Rails</strong>
        
      </td><td width="33%" align="right">
        
          <a href="testing.html">Next</a><br/>
          Testing
        
      </td></tr>
    </table>
    </div>

    <hr/>

    <div class="content">
      <div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a id="_models_and_collections"></a>Models and collections</h2></div></div></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_model_associations"></a>Model associations</h3></div></div></div>
<p>Backbone.js doesn’t prescribe a way to define associations between models, so
we need to get creative and use the power of JavaScript to set up associations
in such a way that its usage is natural.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_belongs_to_associations"></a>Belongs to associations</h4></div></div></div>
<p>Setting up a <code class="literal">belongs_to</code> association in Backbone is a two step process. Let’s
discuss setting up the association that may occur between a task and a user.
The end result of the approach is a <code class="literal">Task</code> instance having a property called
<code class="literal">user</code> where we store the associated <code class="literal">User</code> object.</p>
<p>To set this up, let’s start by telling Rails to augment the task’s JSON
representation to also send over the associated user attributes:</p>
<pre class="programlisting"><b class="hl-keyword">class</b> Task &lt; ActiveRecord::Base
  belongs_to :user

  <b class="hl-keyword">def</b> as_json(options = <b class="hl-keyword">nil</b>)
    <b class="hl-keyword">super</b>((options || {}).merge(include: { user: { only: [:name, :email] } }))
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre>
<p>This means that when Backbone calls <code class="literal">fetch()</code> for a <code class="literal">Task</code> model, it will
include the name and email of the associated user nested within the task JSON
representation. Something like this:</p>
<pre class="programlisting">{
  <b class="hl-string"><i style="color:red">"title"</i></b>: <b class="hl-string"><i style="color:red">"Buy more Cheeseburgers"</i></b>,
  <b class="hl-string"><i style="color:red">"due_date"</i></b>: <b class="hl-string"><i style="color:red">"2011-03-04"</i></b>,
  <b class="hl-string"><i style="color:red">"user"</i></b>: {
    <b class="hl-string"><i style="color:red">"name"</i></b>: <b class="hl-string"><i style="color:red">"Robert McGraffalon"</i></b>,
    <b class="hl-string"><i style="color:red">"email"</i></b>: <b class="hl-string"><i style="color:red">"bobby@themcgraffalons.com"</i></b>
  }
}</pre>
<p>Now that we receive user data with the task’s JSON representation, let’s tell
our Backbone User model to store the User object. We do that on the task’s
initializer. Here’s a first cut at that:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> Task = Backbone.Model.extend({
  initialize: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.user = <b class="hl-keyword">new</b> User(<b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'user'</i></b>));
  }
});</pre>
<p>We can make a couple of improvements to the above. First, you’ll soon realize
that you might be setting the user outside of the initialize as well. Second,
the initializer should check whether there is user data in the first place. To
address the first concern, let’s create a setter for the object. Backbone
provides a handy function called <code class="literal">has</code> that returns true or false depending on
whether the provided attribute is set for the object:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> Task = Backbone.Model.extend({
  initialize: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">if</b> (<b class="hl-keyword">this</b>.has(<b class="hl-string"><i style="color:red">'user'</i></b>)) {
      <b class="hl-keyword">this</b>.setUser(<b class="hl-keyword">new</b> User(<b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'user'</i></b>)));
    }
  },

  setUser: <b class="hl-keyword">function</b>(user) {
    <b class="hl-keyword">this</b>.user = user;
  }
});</pre>
<p>The final setup allows for a nice clean interface to a task’s user, by
accessing the task property of the user instance.</p>
<pre class="programlisting"><b class="hl-keyword">var</b> task = Task.fetch(<span class="hl-number">1</span>);
console.log(task.get(<b class="hl-string"><i style="color:red">'title'</i></b>) + <b class="hl-string"><i style="color:red">' is being worked on by '</i></b> + task.user.get(<b class="hl-string"><i style="color:red">'name'</i></b>));</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_has_many_associations"></a>Has many associations</h4></div></div></div>
<p>You can take a similar approach to set up a <code class="literal">has_many</code> association on the
client side models. This time, however, the object’s property will be a
Backbone collection.</p>
<p>Following the example, say we need access to a user’s tasks. Let’s set up the
JSON representation on the Rails side first:</p>
<pre class="programlisting"><b class="hl-keyword">class</b> User &lt; ActiveRecord::Base
  has_many :tasks

  <b class="hl-keyword">def</b> as_json(options = <b class="hl-keyword">nil</b>)
    <b class="hl-keyword">super</b>((options || {}).merge(include: { tasks: { only: [:body, :due_date] } }))
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre>
<p>Now, on the Backbone <code class="literal">User</code> model’s initializer, let’s call the <code class="literal">setTasks</code>
function:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> User = Backbone.Model.extend({
  initialize: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> tasks = <b class="hl-keyword">new</b> Tasks.reset(<b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'tasks'</i></b>));
    <b class="hl-keyword">this</b>.setTasks(tasks);
  },

  setTasks: <b class="hl-keyword">function</b>(tasks) {
    <b class="hl-keyword">this</b>.tasks = tasks;
  }
});</pre>
<p>Note that we are setting the relation to an instance of the <code class="literal">Tasks</code> collection.</p>
<p>TODO: Let’s exapnd upon this, as it isn’t the most flexible solution.  (It is
a good start.) We are setting the JSON representation of the Rails models to
suit the Backbone.js concerns.  Additionally, the <code class="literal">Task#as_json</code> method at the
top is concerned with the User JSON representation.  It should at least delegate
to User#as_json. Going further, the JSON presentation for consumption by
Backbone.js should be completely extracted into the JSON API endpoint controller
action, or even a separate presenter class.</p>
<p>TODO: Some of this is repeated in the model_relationships section, unify.</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_filters_and_sorting"></a>Filters and sorting</h3></div></div></div>
<p>When using our Backbone models and collections, it’s often handy to filter the
collections by reusable criteria, or sort them by several different criteria.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_filters"></a>Filters</h4></div></div></div>
<p>To filter a <code class="literal">Backbone.Collection</code>, like with Rails named scopes, define
functions on your collections that filter by your criteria, using the <code class="literal">select</code>
function from Underscore.js, and return new instances of the collection class. A
first implementation might look like this:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  complete: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> filteredTasks = <b class="hl-keyword">this</b>.select(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.get(<b class="hl-string"><i style="color:red">'completed_at'</i></b>) !== null;
    });
    <b class="hl-keyword">return</b> <b class="hl-keyword">new</b> Tasks(filteredTasks);
  }
});</pre>
<p>Let’s refactor this a bit.  Ideally, the filter functions will reuse logic
already defined in your model class:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> Task = Backbone.Model.extend({
  isComplete: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'completed_at'</i></b>) !== null;
  }
});

<b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  complete: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> filteredTasks = <b class="hl-keyword">this</b>.select(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.isComplete();
    });
    <b class="hl-keyword">return</b> <b class="hl-keyword">new</b> Tasks(filteredTasks);
  }
});</pre>
<p>Going further, notice that there are actually two concerns in this function.
The first is the notion of filtering the collection, and the other is the
specific filtering criteria (<code class="literal">task.isComplete()</code>).</p>
<p>Let’s separate the two concerns here, and extract a <code class="literal">filtered</code> function:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> Task = Backbone.Model.extend({
  isComplete: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'completed_at'</i></b>) !== null;
  }
});

<b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  complete: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.filtered(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.isComplete();
    });
  },

  filtered: <b class="hl-keyword">function</b>(criteriaFunction) {
    <b class="hl-keyword">return</b> <b class="hl-keyword">new</b> Tasks(<b class="hl-keyword">this</b>.select(criteriaFunction));
  }
});</pre>
<p>We can extract this function into a reusable mixin, abstracting the <code class="literal">Tasks</code>
collection class using <code class="literal">this.constructor</code>:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> FilterableCollectionMixin = {
  filtered: <b class="hl-keyword">function</b>(criteriaFunction) {
    <b class="hl-keyword">return</b> <b class="hl-keyword">new</b> <b class="hl-keyword">this</b>.constructor(<b class="hl-keyword">this</b>.select(criteriaFunction));
  }
};

<b class="hl-keyword">var</b> Task = Backbone.Model.extend({
  isComplete: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'completed_at'</i></b>) !== null;
  }
});

<b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  complete: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.filtered(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.isComplete();
    });
  }
});

_.extend(Tasks.<b class="hl-keyword">prototype</b>, FilterableCollectionMixin);</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_propagating_collection_changes"></a>Propagating collection changes</h4></div></div></div>
<p>The <code class="literal">FilterableCollectionMixin</code>, as we’ve written it, will produce a filtered
collection that does not update when the original collection is changed.  To do
so, bind to the change, add, and remove events on the source collection,
reapply the filter function, and repopulate the filtered collection:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> FilterableCollectionMixin = {
  filtered: <b class="hl-keyword">function</b>(criteriaFunction) {
    <b class="hl-keyword">var</b> sourceCollection = <b class="hl-keyword">this</b>;
    <b class="hl-keyword">var</b> filteredCollection = <b class="hl-keyword">new</b> <b class="hl-keyword">this</b>.constructor;

    <b class="hl-keyword">var</b> applyFilter = <b class="hl-keyword">function</b>() {
      filteredCollection.reset(sourceCollection.select(criteriaFunction));
    };

    <b class="hl-keyword">this</b>.bind(<b class="hl-string"><i style="color:red">"change"</i></b>, applyFilter);
    <b class="hl-keyword">this</b>.bind(<b class="hl-string"><i style="color:red">"add"</i></b>,    applyFilter);
    <b class="hl-keyword">this</b>.bind(<b class="hl-string"><i style="color:red">"remove"</i></b>, applyFilter);

    applyFilter();

    <b class="hl-keyword">return</b> filteredCollection;
  }
};</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_sorting"></a>Sorting</h4></div></div></div>
<p>The simplest way to sort a <code class="literal">Backbone.Collection</code> is to define a <code class="literal">comparator</code>
function.  This functionality is built in:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  comparator: <b class="hl-keyword">function</b>(task) {
    <b class="hl-keyword">return</b> task.dueDate;
  }
});</pre>
<p>If you’d like to provide more than one sort order on your collection, you can
use an approach similar to the <code class="literal">filtered</code> function above, and return a new
<code class="literal">Backbone.Collection</code> whose <code class="literal">comparator</code> is overridden.  Call <code class="literal">sort</code> to update
the ordering on the new collection:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  comparator: <b class="hl-keyword">function</b>(task) {
    <b class="hl-keyword">return</b> task.dueDate;
  },

  byCreatedAt: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> sortedCollection = <b class="hl-keyword">new</b> Tasks(<b class="hl-keyword">this</b>.models);
    sortedCollection.comparator = <b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.createdAt;
    };
    sortedCollection.sort();
    <b class="hl-keyword">return</b> sortedCollection;
  }
});</pre>
<p>Similarly, you can extract the reusable concern to another function:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  comparator: <b class="hl-keyword">function</b>(task) {
    <b class="hl-keyword">return</b> task.dueDate;
  },

  byCreatedAt: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.sortedBy(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.createdAt;
    });
  },

  byCompletedAt: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.sortedBy(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.completedAt;
    });
  },

  sortedBy: <b class="hl-keyword">function</b>(comparator) {
    <b class="hl-keyword">var</b> sortedCollection = <b class="hl-keyword">new</b> Tasks(<b class="hl-keyword">this</b>.models);
    sortedCollection.comparator = comparator;
    sortedCollection.sort();
    <b class="hl-keyword">return</b> sortedCollection;
  }
});</pre>
<p>And then into another reusable mixin:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> SortableCollectionMixin = {
  sortedBy: <b class="hl-keyword">function</b>(comparator) {
    <b class="hl-keyword">var</b> sortedCollection = <b class="hl-keyword">new</b> <b class="hl-keyword">this</b>.constructor(<b class="hl-keyword">this</b>.models);
    sortedCollection.comparator = comparator;
    sortedCollection.sort();
    <b class="hl-keyword">return</b> sortedCollection;
  }
};

<b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  comparator: <b class="hl-keyword">function</b>(task) {
    <b class="hl-keyword">return</b> task.dueDate;
  },

  byCreatedAt: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.sortedBy(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.createdAt;
    });
  },

  byCompletedAt: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.sortedBy(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.completedAt;
    });
  }
});

_.extend(Tasks.<b class="hl-keyword">prototype</b>, SortableCollectionMixin);</pre>
<p>Just as with the <code class="literal">FilterableCollectionMixin</code> before, the
<code class="literal">SortableCollectionMixin</code> should observe its source if updates are to propagate
from one collection to another:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> SortableCollectionMixin = {
  sortedBy: <b class="hl-keyword">function</b>(comparator) {
    <b class="hl-keyword">var</b> sourceCollection = <b class="hl-keyword">this</b>;
    <b class="hl-keyword">var</b> sortedCollection = <b class="hl-keyword">new</b> <b class="hl-keyword">this</b>.constructor;
    sortedCollection.comparator = comparator;

    <b class="hl-keyword">var</b> applySort = <b class="hl-keyword">function</b>() {
      sortedCollection.reset(sourceCollection.models);
      sortedCollection.sort();
    };

    <b class="hl-keyword">this</b>.on(<b class="hl-string"><i style="color:red">"change"</i></b>, applySort);
    <b class="hl-keyword">this</b>.on(<b class="hl-string"><i style="color:red">"add"</i></b>,    applySort);
    <b class="hl-keyword">this</b>.on(<b class="hl-string"><i style="color:red">"remove"</i></b>, applySort);

    applySort();

    <b class="hl-keyword">return</b> sortedCollection;
  }
};</pre>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_validations"></a>Validations</h3></div></div></div>
<p>The server is the authoritative place for verifying whether data that being
stored is valid. Even though backbone.js
<a class="ulink" href="http://documentcloud.github.com/backbone/#Model-validate" target="_top">exposes an API</a>
for performing client side validations, when it comes to validating user data
in a backbone.js application we want to continue to use the very same
mechanisms on the server side that we’ve used in Rails all along: the
ActiveModel validations API.</p>
<p>The challenge is tying the two together: letting your ActiveRecord objects
reject invalid user data, and having the errors bubble up all the way to the
interface for user feedback - and having it all be seamless to the user and
easy for the developer.</p>
<p>Let’s wire this up. To get started, we’ll add a validation on the task’s title
attribute on the ActiveRecord model like so:</p>
<pre class="programlisting"><b class="hl-keyword">class</b> Task &lt; ActiveRecord::Base
  validates :title, presence: <b class="hl-keyword">true</b>
<b class="hl-keyword">end</b></pre>
<p>On the backbone side of the world, we have a Backbone task called
YourApp.Models.Task:</p>
<pre class="programlisting">YourApp.Models.Task = Backbone.Model.extend({
  urlRoot: <b class="hl-string"><i style="color:red">'/tasks'</i></b>
});</pre>
<p>We also have a place where users enter new tasks - just a form on the task
list.</p>
<pre class="programlisting">&lt;form&gt;
  &lt;ul&gt;
    &lt;li <b class="hl-keyword">class</b>=<b class="hl-string"><i style="color:red">"task_title_input"</i></b>&gt;
      &lt;label <b class="hl-keyword">for</b>=<b class="hl-string"><i style="color:red">"title"</i></b>&gt;Title&lt;/label&gt;
      &lt;input id=<b class="hl-string"><i style="color:red">"title"</i></b> maxlength=<b class="hl-string"><i style="color:red">"255"</i></b> name=<b class="hl-string"><i style="color:red">"title"</i></b> type=<b class="hl-string"><i style="color:red">"text"</i></b>&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;button <b class="hl-keyword">class</b>=<b class="hl-string"><i style="color:red">"submit"</i></b> id=<b class="hl-string"><i style="color:red">"create-task"</i></b>&gt;Create task&lt;/button&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/form&gt;</pre>
<p>On the NewTask backbone view, we bind the button’s click event to a new
function that we’ll call <code class="literal">createTask</code>.</p>
<pre class="programlisting">YourApp.Views.NewTask = Backbone.View.extend({
  events: {
    <b class="hl-string"><i style="color:red">"click #create-task"</i></b>: <b class="hl-string"><i style="color:red">"createTask"</i></b>
  },

  createTask: {
    <i class="hl-comment" style="color: silver">// grab attribute values from the form</i>
    <i class="hl-comment" style="color: silver">// storing them on the attributes hash</i>
    <b class="hl-keyword">var</b> attributes = {};
    _.each(<b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'form input, form select'</i></b>), <b class="hl-keyword">function</b>(element) {
      <b class="hl-keyword">var</b> element = $(element);
      <b class="hl-keyword">if</b>(element.attr(<b class="hl-string"><i style="color:red">'name'</i></b>) != <b class="hl-string"><i style="color:red">"commit"</i></b>) {
        attributes[element.attr(<b class="hl-string"><i style="color:red">'name'</i></b>)] = element.val();
      }
    });

    <b class="hl-keyword">var</b> self = <b class="hl-keyword">this</b>;
    <i class="hl-comment" style="color: silver">// create a new task and save it to the server</i>
    <b class="hl-keyword">new</b> YourApp.Models.Task(attributes).save({
        success: <b class="hl-keyword">function</b>() { <i class="hl-comment" style="color: silver">/* handle success */</i> }
        error:   <b class="hl-keyword">function</b>() { <i class="hl-comment" style="color: silver">/* validation error occurred, show user */</i> }
      });
    <b class="hl-keyword">return</b> false;
  }
})</pre>
<p>This gets the job done, but let’s introduce a new class to handle extracting
attributes from the form so that it’s decoupled from this view and it’s
therefore easier to extend and reuse.</p>
<p>We’ll call this the <code class="literal">FormAttributes</code>, and its code is like follows:</p>
<pre class="programlisting">FormAttributes = <b class="hl-keyword">function</b>(form) {
  <b class="hl-keyword">this</b>.form = form;
}

_.extend(FormAttributes.<b class="hl-keyword">prototype</b>, {
  attributes: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> attributes = {};
    _.each($(<b class="hl-string"><i style="color:red">'input, select'</i></b>, form), <b class="hl-keyword">function</b>(element) {
      <b class="hl-keyword">var</b> element = $(element);
      <b class="hl-keyword">if</b>(element.attr(<b class="hl-string"><i style="color:red">'name'</i></b>) != <b class="hl-string"><i style="color:red">"commit"</i></b>) {
        attributes[element.attr(<b class="hl-string"><i style="color:red">'name'</i></b>)] = element.val();
      }
    });
    <b class="hl-keyword">return</b> attributes;
  }
});</pre>
<p>With this class in place, we can rewrite our form submit action to:</p>
<pre class="programlisting">YourApp.Views.NewTask = Backbone.View.extend({
  events: {
    <b class="hl-string"><i style="color:red">"click #create-task"</i></b>: <b class="hl-string"><i style="color:red">"createTask"</i></b>
  },

  createTask: {
    <b class="hl-keyword">var</b> attributes = <b class="hl-keyword">new</b> FormAttributes(<b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'form'</i></b>)).attributes();

    <b class="hl-keyword">var</b> self = <b class="hl-keyword">this</b>;
    <i class="hl-comment" style="color: silver">// create a new task and save it to the server</i>
    <b class="hl-keyword">new</b> YourApp.Models.Task(attributes).save({
        success: <b class="hl-keyword">function</b>() { <i class="hl-comment" style="color: silver">/* handle success */</i> }
        error:   <b class="hl-keyword">function</b>() { <i class="hl-comment" style="color: silver">/* validation error occurred, show user */</i> }
      });
    <b class="hl-keyword">return</b> false;
  }
})</pre>
<p>When you call save() on a backbone model, Backbone will delegate to <code class="literal">.sync()</code>
and create a POST request on the model’s URL where the payload are the
attributes that you’ve passed onto the <code class="literal">save()</code> call.</p>
<p>The easiest way to handle this in Rails is to use respond_to/respond_with
available in Rails 3 applciations:</p>
<pre class="programlisting"><b class="hl-keyword">class</b> TasksController &lt; ApplicationController
  respond_to :json
  <b class="hl-keyword">def</b> create
    task = Task.create(params)
    respond_with task
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre>
<p>When the task is created successfully, Rails will render the show action using
the object that you’ve passed to the respond_with call, so make sure the show
action is defined in your routes:</p>
<pre class="programlisting">resources :tasks, only: [:create, :show]</pre>
<p>When the task cannot be created successfully because some validation constraint
is not met, the the Rails responder will render the model’s errors as a JSON
object, and use an HTTP status code of 422, which will alert backbone that
there was an error in the request and it was not processed.</p>
<p>The response from Rails in that case looks something like this:</p>
<pre class="programlisting">{ <b class="hl-string"><i style="color:red">"title"</i></b>: [<b class="hl-string"><i style="color:red">"can't be blank"</i></b>] }</pre>
<p>So that two line action in a Rails controller is all we need to talk to our
backbone models and handle error cases.</p>
<p>Back to the backbone model’s <code class="literal">save()</code> call, Backbone will invoke one of two
callbacks when it receives a response from the rails app, so we simply pass in
a hash containing a function to run both for the success and the error cases.</p>
<p>In the success case, we may want to add the new model instance to a global
collection of tasks. Backbone will trigger the add event on that collection, so
there’s your chance for some other view to bind to that event and rerender
itself so that the new task appears on the page.</p>
<p>In the error case, however, we want to display inline errors on the form. When
backbone triggers the <code class="literal">error</code> callback, it passes along two parameters: the
model being saved and the raw response. We have to parse the JSON response and
iterate through it rendering an inline error on the form corresponding to each
of the errors. Let’s introduce a couple of new classes that will help along the
way.</p>
<p>First off is the <code class="literal">ErrorList</code>. An <code class="literal">ErrorList</code> encapsulates parsing of the raw
JSON that came in from the server and provides an iterator to easily loop
through errors:</p>
<pre class="programlisting">ErrorList = <b class="hl-keyword">function</b> (response) {
  <b class="hl-keyword">if</b> (response &amp;&amp; response.responseText) {
    <b class="hl-keyword">this</b>.attributesWithErrors = JSON.parse(response.responseText);
  }
};

_.extend(ErrorList.<b class="hl-keyword">prototype</b>, {
  each: <b class="hl-keyword">function</b> (iterator) {
    _.each(attributesWithErrors, iterator);
  },

  size: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> _.size(attributesWithErrors);
  }
});</pre>
<p>Next up is the <code class="literal">ErrorView</code>, who’s in charge of taking the Errorlist and
appending each inline error in the form, providing feedback to the user that
their input is invalid.</p>
<pre class="programlisting">ErrorView = Backbone.View.extend({
  initialize: <b class="hl-keyword">function</b>() {
    _.bindAll(<b class="hl-keyword">this</b>, <b class="hl-string"><i style="color:red">"renderError"</i></b>);
  },

  render: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">".error"</i></b>).removeClass(<b class="hl-string"><i style="color:red">"error"</i></b>);
    <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">"p.inline-errors"</i></b>).remove();
    <b class="hl-keyword">this</b>.options.errors.each(<b class="hl-keyword">this</b>.renderError);
  },

  renderError: <b class="hl-keyword">function</b>(errors, attribute) {
    <b class="hl-keyword">var</b> errorString = errors.join(<b class="hl-string"><i style="color:red">", "</i></b>);
    <b class="hl-keyword">var</b> field = <b class="hl-keyword">this</b>.fieldFor(attribute);
    <b class="hl-keyword">var</b> errorTag = $(<b class="hl-string"><i style="color:red">'&lt;p&gt;'</i></b>).addClass(<b class="hl-string"><i style="color:red">'inline-errors'</i></b>).text(errorString);
    field.append(errorTag);
    field.addClass(<b class="hl-string"><i style="color:red">"error"</i></b>);
  },

  fieldFor: <b class="hl-keyword">function</b>(attribute) {
    <b class="hl-keyword">return</b> $(<b class="hl-keyword">this</b>.options.el).find(<b class="hl-string"><i style="color:red">'[id*="_'</i></b> + attribute + <b class="hl-string"><i style="color:red">'_input"]'</i></b>).first();
  }
});</pre>
<p>Note the <code class="literal">fieldFor</code> function. It expects a field with an id containing a
certain format. Therefore, in order for this to work the form’s HTML must
contain a matching element. In our case, it was the list item with an id of
<code class="literal">task_title_input</code>.</p>
<p>When a backbone view’s <code class="literal">el</code> is already on the DOM, we need to pass it into the
view’s constructor. In the case of the <code class="literal">ErrorView</code> class, we want to operate on
the view that contains the form that originated the errors.</p>
<p>To use these classes, we take the response from the server and pass that along
to the ErrorList constructor, which we then pass to the ErrorView that will do
it’s fine job in inserting the inline errors when we call <code class="literal">render()</code> on it.
Putting it all together, our save call’s callbacks now look like this:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> self = <b class="hl-keyword">this</b>;
<b class="hl-keyword">var</b> model = <b class="hl-keyword">new</b> YourApp.Models.Task(attributes);
model.save({
  error: <b class="hl-keyword">function</b>(model, response) {
    <b class="hl-keyword">var</b> errors = <b class="hl-keyword">new</b> ErrorList(response);
    <b class="hl-keyword">var</b> view   = <b class="hl-keyword">new</b> ErrorView( { el: self.el, errors: errors } );
    view.render();
  }
});</pre>
<p>Here we’ve shown how you can decouple different concerns into their own
classes, creating a system that is easier to extend, and potentially
arriving at generic enough solutions to be even shared across applications.
Our simple FormAttributes class has a long way to go. It can grow up to handle
many other cases such as dates.</p>
<p>One example of a generic library that handles much of what we’ve done here,
as well as helpers for rendering the forms, is Backbone.Form. In order to know
how to render all attributes of a model, it requires you to specify a
"schema" on the model class - and it will take it from there. The source for
Backbone.Form can be found
<a class="ulink" href="https://github.com/powmedia/backbone-forms" target="_top">on github</a>.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_model_relationships"></a>Model relationships</h3></div></div></div>
<p>In any non-trivial application, you will have relationships in your domain model
that are valuable to express on the client side.  For example, consider a
contact management application where each person in your contact list has many
phone numbers, each of a different kind.</p>
<p>Or, consider a project planning application where there are Teams, Members, and
Projects as resources (models and collections).  There are relationships between
each of these primary resources, and those relationships in turn may be exposed
as first-class resources: a Membership to link a Team and a Member, or a
Permission to link a Team with a Project.  These relationships are often exposed
as first-class models so they can be created and destroyed the same way as other
models, and so that additional domain information about the relationship, such
as a duration, rate, or quantity, can be described.</p>
<p>These model relationships don’t have to be persisted by a relational database.
In a chatroom application whose data is persisted in a key-value store, the data
could still be modeled as a Room which has many Messages, as well as Memberships
that link the Room to Users.  A content management application that stores its
data in a document database still has the notion of hierarchy, where a Site
contains many Pages, each of which is constitutes of zero or more Sections.</p>
<p>In a vanilla Rails application, the object model is described on the server side
with ActiveRecord subclasses, and exposed to the Backbone.js client through a
JSON HTTP API.  You have a few choices to make when designing this API, largely
focused on the inherent coupling of model relationships and data — when you handle a request for one resource, which of its associated resources
(if any) do you deliver, too?</p>
<p>Then, on the client side, you have a wide degree of choice in how to model the
relationships, when to eagerly pre-fetch associations and when to lazily defer
loading, and whether to employ a supporting library to help define your model
relationships.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_relations_in_the_task_app"></a>Relations in the Task App</h4></div></div></div>
<p>In the example application, there are Users which have many Tasks through
Lists. Each Task has many Comments and Attachments.</p>
<div class="informalfigure"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="65%"><tr><td align="center"><img src="image/TaskAppEntityRelationships.png" align="middle" width="100%" alt="image/TaskAppEntityRelationships.png"></td></tr></table></div></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_deciding_how_to_deliver_data_to_the_client"></a>Deciding how to deliver data to the client</h4></div></div></div>
<p>Before you decide how to model your JSON API or how to declare, your client-side model
relationships, step back and consider the user experience of your application.
For TaskApp, we decided to have interactions as follows:</p>
<div class="itemizedlist"><ul type="disc">
<li>
A user signs up or logs in
</li>
<li>
The user is directed to their dashboard
</li>
<li>
The dashboard shows all lists and the tasks on each list, but not the
  comments or attachments.
</li>
<li>
When a user views the details of an individual task, the comments and
  attachments for that task are displayed.
</li>
</ul></div>
<p>This leads us to see that the Lists and Tasks for a user are used immediately
upon navigating to the dasboard, but the Comment and Attachment data for a Task
are not needed upon initial page load, and are possibly never needed at all.</p>
<p>Let’s say that we are also planning for the user to have continuous network
access, but not to necessarily have a high speed connection.  Also, users tend
to view their lists of tasks frequently, but rarely view the comments and
attachments.</p>
<p>Based on this, we will bootstrap the collections of Lists and Tasks inside the
dashboard, and defer loading of associated Comments and Attachments until after
the user clicks through to a task.</p>
<p>We could have selected from several other alternatives, including:</p>
<div class="itemizedlist"><ul type="disc">
<li>
Don’t preload any information, and deliver only static assets (HTML, CSS, JS)
  on the dashboard request.  Fetch all resources over separate XHR calls.  This
  can provide for a faster initial page load, at the cost of a longer time to
  actual interactivity: although the byte size of the page plus data is roughly
  the same, the overhead of additional HTTP requests incurs the extra load time.
</li>
<li>
Preload all the information, including Comments and Attachments.  This would
  work well if we expected users to frequently access the comments and
  attachments of many tasks.
</li>
<li>
Use localStorage as the primary storage engine, and sync to the Rails server
  in the background.  This would be advantageous if we expected network access
  to be intermittent, although it incurs the additional complexity of having to
  resolve conflicts on the server if two clients submit conflicting updates.
</li>
</ul></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_designing_the_http_json_api"></a>Designing the HTTP JSON API</h4></div></div></div>
<p>Now that we know we’ll bootstrap the Lists and Tasks and defer the Comments and
Associations, we should decide how to deliver the deferred content.  We have two
options here.  Our goal is to fetch to comments and attachments for an
individual task.</p>
<p>One way we could approach this is the issue separate API calls for each
nested resource:</p>
<pre class="programlisting">$ curl http://tasksapp.local:3000/tasks/78/comments.json | ppjson
[
  {
    "id": 208,
    "user_id": 3,
    "body": "What do you think of this mock? (See attachment)"
  },
  {
    "id": 209,
    "user_id": 1,
    "body": "Looks great!  I'll implement that."
  }
]

$ curl http://tasksapp.local:3000/tasks/78/attachments.json | ppjson
[
  {
    "id": "32",
    "file_url": "https://s3.amazonaws.com/tasksapp/uploads/32/mock.png"
  }
]</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>We will authenticate API requests with cookies, just like normal user
login, so the actual curl request would need to include a cookie from a logged
in user.</p>
</div>
<p>This approach has the advantage of adhering more to convention, and requiring
less code in both the server-side JSON presentation and the client-side JSON
parsing.  Its disadvantage is performance: to fetch a task’s associated data, we
need to send 2 HTTP requests.  When more kinds of associated resources are added
in the future, the number of requests will increase.</p>
<p>Another way we could approach this is to embed the comment and attachment data in
the JSON representation of an individual task, and deliver this data from the
<code class="literal">/tasks/:id</code> endpoint:</p>
<pre class="programlisting">$ curl http://tasksapp.local:3000/tasks/78.json | ppjson
{
  /* some attributes left out for clarity */

  "id": 78,
  "user_id": 1,
  "title": "Clean up landing page",
  "comments": [
    {
      "id": 208,
      "user_id": 3,
      "body": "What do you think of this mock? (See attachment)"
    },
    {
      "id": 209,
      "user_id": 1,
      "body": "Looks great!  I'll implement that."
    }
  ],
  "attachments": [
    {
      "id": "32",
      "upload_url": "https://s3.amazonaws.com/tasksapp/uploads/32/mock.png"
    }
  ]
}</pre>
<p>This approach involves additional code in both producing the JSON on the server
side and parsing the JSON on the client side.  We’ll take this approach for the
example application, both because it requires fewer HTTP requests and because
it’s a more interesting example and illustrates the technique of parsing nested
models in Backbone.js.</p>
<p>Now that we know we’ll bootstrap the Lists and Tasks and defer the Comments and
Attachments, we know that our HTTP JSON API should support at least the
following Rails routes:</p>
<pre class="programlisting">resources :lists, :only =&gt; [:create, :update, :delete]
resources :tasks, :only =&gt; [:show, :create, :update, :delete]</pre>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Tip</h3>
<p>In some applications, you choose to expose a user-facing API.  It’s often
valuable to dogfood this endpoint by making use of it from your own Backbone
code.  Often these APIs will be scoped under an "/api" namespace, possibly with
an API version namespace as well.</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_implementing_the_api_presenting_the_json"></a>Implementing the API: presenting the JSON</h4></div></div></div>
<p>For building the JSON presentation, we have a few options. Rails already comes
with support for overriding the <code class="literal">Task#as_json</code> method, which is probably
the easiest thing to do. However, logic regarding the JSON representation of
a model is not necessarily the model’s concern. Furthermore, the <code class="literal">as_json</code> API
starts to fall appart when representing complex hierarchies. Other approaches
such as creating a separate presenter object, or writing a builder-like view are
all better approaches because additionally we don’t pollute our models with
presentational logic.</p>
<p>The <a class="ulink" href="https://github.com/nesquena/rabl" target="_top">RABL rubygem</a> is a good generalization
of the problem and can help with this particular aspect of your API implementation.</p>
<p>RABL allows you to create templates where you can easily specify the JSON
representation of your models. If you’ve worked with the great <code class="literal">builder</code>
library to generate arbitrary XML, such as an RSS feed, you’ll feel right at
home.</p>
<p>To use it, first include the <code class="literal">rabl</code> and <code class="literal">yajl-ruby</code> gems in your Gemfile. Then
you can create a view ending with <code class="literal">.json.rabl</code> to handle any particular request.
 For example, a tasks#show action and views may look like this:</p>
<pre class="programlisting"><b class="hl-keyword">class</b> TasksController &lt; ApplicationController
  respond_to :json
  <b class="hl-keyword">def</b> show
    @task = Task.find(params[:id])
    respond_with @task
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre>
<p>Rails responders will first look for a template matching the controller/action
with the format in the file name, in this case <code class="literal">json</code>. If it doesn’t find it,
it will invoke <code class="literal">to_json</code> on the <code class="literal">@task</code> model, but in this case we are providing
one in <code class="literal">app/views/tasks/show.json.rabl</code>, so it will render that instead:</p>
<pre class="programlisting">object @task
attributes(:id, :title, :complete)
child(:user) { attributes(:id, :email) }</pre>
<p>Now it is much easier to extend and tweak the JSON generated on the server,
while still keeping the model free of presentational behavior. Do look at
the <a class="ulink" href="https://github.com/nesquena/rabl#readme" target="_top">project’s readme</a> for all the
bells and whistles.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_parsing_the_json_and_instantiating_client_side_models"></a>Parsing the JSON and instantiating client-side models</h4></div></div></div>
<p>TODO: Expand outline</p>
<p>Outline:  Discuss overriding Backbone Model parse() function.  Talk about how
parsing fits into the fetch/new object lifecycle.  Point out inconsistencies
(parse not invoked during reset, only fetch/set etc)
Discuss <a class="ulink" href="https://github.com/PaulUithol/Backbone-relational" target="_top">https://github.com/PaulUithol/Backbone-relational</a></p>
<p>TODO: If a Backbone Task doesn’t always have its associations filled (e.g. when
rendering the TasksIndex Backbone view, whose JSON is built by bootstrapping, in
<code class="literal">Tasks#index</code>), when you move from TasksIndex to TasksShow, you need to invoke
task.fetch() to pull all the task attributes from <code class="literal">GET /tasks/:id</code> and populate
the associations.  Whose concern is that?  Presumably the TaskShow view.  You
could discuss lazily populating this by making the task associations functions
instead of properties (compare task.attachments.each to task.attachments().each;
in the latter, you could lazily fetch and populate, but then you run into the
issue that fetch is async.)</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_duplicating_business_logic_across_the_client_and_server"></a>Duplicating business logic across the client and server</h3></div></div></div>
<p>When you’re building a multi-tier application where business logic is spread
across tiers, one big challenge you face is to avoid duplicating that logic
across tiers.  There is a tradeoff here, between duplication and performance.
It’s desirable to have one and only one implementation of a particular concern
in your domain, but it’s also desirable for your application to perform
responsively.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_an_example_model_validations"></a>An example: model validations</h4></div></div></div>
<p>For example, let’s say that a user must have an email address.</p>
<p>At one end of the scale, there is no duplication: all business logic is defined
in one tier, and other tiers access the logic by remote invocation.  Your Rails
<code class="literal">Member</code> model provides a validation:</p>
<pre class="programlisting"><b class="hl-keyword">class</b> Member &lt; ActiveRecord::Base
  validate :email, :presence =&gt; <b class="hl-keyword">true</b>
<b class="hl-keyword">end</b></pre>
<p>The Backbone view attempts to persist the Member as usual, binding to its
<code class="literal">error</code> event to handle the server side error:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> MemberFormView = Backbone.View.extend({
  events: {
    <b class="hl-string"><i style="color:red">"submit form"</i></b>: <b class="hl-string"><i style="color:red">"submit"</i></b>
  },

  initialize: <b class="hl-keyword">function</b>() {
    _.bindAll(<b class="hl-keyword">this</b>, <b class="hl-string"><i style="color:red">"error"</i></b>);
    <b class="hl-keyword">this</b>.model.bind(<b class="hl-string"><i style="color:red">"error"</i></b>, <b class="hl-keyword">this</b>.error);
  },

  render: <b class="hl-keyword">function</b>() {
    <i class="hl-comment" style="color: silver">// render form...</i>
  },

  submit: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> attributes = <b class="hl-keyword">new</b> FormSerializer(<b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'form'</i></b>)).attributes();
    <b class="hl-keyword">this</b>.model.save(attributes);
  },

  error: <b class="hl-keyword">function</b>(model, errorResponse) {
    <b class="hl-keyword">new</b> ErrorView(errorResponse, <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'form'</i></b>)).render();
  }
});</pre>
<p>This uses the <code class="literal">ErrorView</code> class which is able to parse the error hash returned
from Rails, which was discussed on the Validations section.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>This is also the first time you probably see <code class="literal">_.bindAll()</code>, so let’s diverge
briefly to introduce what it is doing.</p>
<p>When an event is triggered, the code invoking the callback is able to set the
javascript context. By calling <code class="literal">_.bindAll(this, "error")</code>, we are instead
overriding whatever context it may have been, and setting it to <code class="literal">this</code>. This is
necessary so that when we call <code class="literal">this.$(<span class="emphasis"><em>form</em></span>)</code> in the <code class="literal">error()</code> callback,
we get the right object back.</p>
<p>Always use <code class="literal">_.bindAll</code> when you need to force the javascript context (<code class="literal">this</code>)
within a function’s body.</p>
</div>
<p>In the case of no duplication, your Backbone <code class="literal">Member</code> model does not declare
this validation.  An user fills out a form for a creating a new Member in your
application, submits the form, and, if they forgot to include an email address,
a validation message is displayed.  The application delegates the entire
validation concern to the server, as we saw in the validations section.  TODO:
Link up that reference.</p>
<p>However, round-tripping validation to the server can be too slow in some cases,
and we’d like to provide feedback to the end-user more quickly.  To do this, we
have to implement the validation concern on the client side as well.  Backbone
provides a facility for validating models during their persistence, so we could
write:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> Member = Backbone.Model.extend({
  validate: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> errors = {};
    <b class="hl-keyword">if</b> (_.isEmpty(<b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'email'</i></b>))) {
      errors.email = [<b class="hl-string"><i style="color:red">"can't be blank"</i></b>];
    }
    <b class="hl-keyword">return</b> errors;
  }
});</pre>
<p>Conveniently, we’ve structured the return value of the <code class="literal">validate()</code> function to
mirror the structure of the Rails error JSON we saw returned above.  Now, we
could augment the <code class="literal">ErrorView</code> class’s constructor function to handle either
client-side or server-side errors:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> ErrorView = <b class="hl-keyword">function</b>(responseOrErrors, form) {
  <b class="hl-keyword">this</b>.form = $(form);

  <b class="hl-keyword">if</b> (responseOrErrors &amp;&amp; responseOrErrors.responseText) {
    <b class="hl-keyword">this</b>.errors = JSON.parse(responseOrErrors.responseText);
  } <b class="hl-keyword">else</b> {
    <b class="hl-keyword">this</b>.errors = responseOrErrors;
  }
};</pre>
<p>Now, with Backbone, the <code class="literal">validate()</code> function is called for each invocation of
<code class="literal">set()</code>, so as soon as we set the email address on the Member, its presence is
validated.  For the user experience with the quickest response, we could observe
changes on the email form field, updating the model’s <code class="literal">email</code> attribute whenever
it changes, and displaying the inline error message immediately.</p>
<p>With ErrorView able to handle either client-side or server-side error messages,
we have a server-side guarantee of data correctness, <sup>[<a id="d0e2886" href="#ftn.d0e2886" class="footnote">1</a>]</sup> and a responsive UI that can validate the Member email presence
without round-tripping to the server.</p>
<p>The tradeoff we’ve made is that of duplication; the concern of "what constituted
a valid Member" is written twice — in two different languages, no less.  In
some cases this is unavoidable.  In others, there are mitigation strategies for
reducing the duplication, or at least its impact on your code quality and
maintainability.</p>
<p>Let’s take a look at what kinds of logic you might find duplicated, and then
strategies for reducing duplication.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_kinds_of_logic_you_duplicate"></a>Kinds of logic you duplicate</h4></div></div></div>
<p>In Rails applications, our model layer can contain a variety of kinds of
business logic:</p>
<div class="itemizedlist"><ul type="disc">
<li>
Validations - This is pretty straightforward, since there’s a well-defined
  Rails API for validating ActiveModel classes.
</li>
<li>
Querying - Sorting and filtering fall into this category.  Implementations
  vary slightly, but are often built with <code class="literal">named_scope</code> or class methods
  returning <code class="literal">ActiveRecord::Relation</code> instances.  Occasionally querying is
  delegated to class other than the ActiveRecord instance.
</li>
<li>
Callbacks - Similar to validations, there’s a well-defined API for callbacks
  (or "lifecycle events") on Rails models; <code class="literal">after_create</code> and such.
</li>
<li>
Algorithms - Everything else.  Sometimes they’re implemented on the
  ActiveRecord instances, but are often split out into other classes and used via
  composition.  One example from commerce apps would be an <code class="literal">Order</code> summing the
  costs of its <code class="literal">LineItems</code>.  Or consider an example from an agile project planning
  application, where a <code class="literal">ProjectPlan</code> recalculates a <code class="literal">Project</code>'s set of <code class="literal">UserStory</code>
  objects into weekly <code class="literal">Iteration</code> bucket objects.
</li>
</ul></div>
<p>There are often other methods on your Rails models, but they either are a mix of
the above categories (a <code class="literal">state_machine</code> implementation could be considered a mix
of validations and callback) and other methods that don’t count as business
logic — methods that are actually implementing presentation concerns are a
frequent example.</p>
<p>It’s worth considering each of these categories in turn, and how they can be
distributed across client and server to provide a responsive experience.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_validations_2"></a>Validations</h4></div></div></div>
<p>Validations are probably the lowest-hanging fruit.  Since the API for declaring
validations is largely declarative and well-bounded, we can imagine providing an
interface that introspects Rails models and builds a client-side implementation
automatically.  Certainly there are cases which aren’t automatable, such as
custom Ruby validation code or validations which depend on a very large dataset
that would be impractical to deliver to the client (say, a zipcode database).
These cases would need to fall back to either an XHR call to the server-side
implementation, or a custom-written client-side implementation - a duplicate
implementation.</p>
<p>TODO: This is actually what the
<a class="ulink" href="https://github.com/bcardarella/client_side_validations" target="_top">client_side_validations gem</a>
does…</p>
<p>TODO: The csv model branch is a wip for Backbone compliance, pretty neat:
<a class="ulink" href="https://github.com/bcardarella/client_side_validations/tree/model" target="_top">https://github.com/bcardarella/client_side_validations/tree/model</a></p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_querying"></a>Querying</h4></div></div></div>
<p>TODO: Expand on outline.</p>
<p>Outline: I think it’s possible to establish conventions here, similar to
validations, so that server-side scopes can be converted to client-side
collection filtering.  However, is this valuable?  Do you actually often
duplicate the same querying (sorting/filter) concerns across client and server?</p>
<p>Also, since this whole discussion is about perf, consider tradeoff of paginating
anyways, that’s interesting, so can you reduce duplication and generate code
with that too?</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_callbacks"></a>Callbacks</h4></div></div></div>
<p>TODO: Expand on outline.</p>
<p>Outline: These often depend on server-side persistence, so would you even want
them on the client side?  Perhaps, e.g. same lifecycle events for the analagous
client-side models, but it’s actually likely that your client-side models will
differ sufficiently (since they’re in the presentation tier) from server-side
models that these concerns won’t be duplicates, so it’s less of a worry.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_algorithms"></a>Algorithms</h4></div></div></div>
<p>TODO: Expand on outline.</p>
<p>Outline: General algorithms are often the trickiest. It’s possibly to write the
logic in JS and then make that available to Ruby, if you have a REALLY large
piece of logic, but weigh the cost of that overhead against the cost of
duplicating the logic.  At some point it probably makes sense, though.  Also
consider JS server-side and wrapping that as a webservice for Rails access…
would that be easier?  Need specific examples to motivate this well.</p>
<p><a class="ulink" href="http://c2.com/cgi/wiki?HalfObjectPlusProtocol" target="_top">http://c2.com/cgi/wiki?HalfObjectPlusProtocol</a>
<a class="ulink" href="http://c2.com/cgi/wiki?HoppPatternLanguage" target="_top">http://c2.com/cgi/wiki?HoppPatternLanguage</a></p>
<p>TODO: The ErrorList/ErrorView implementation here isn’t quite consistent with
those in the prior validations chapter.  Refactor for consistency or, if that’s
inappropriate, do a better job explaining the changes.</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_synchronizing_between_clients"></a>Synchronizing between clients</h3></div></div></div>
<p>A big driving force behind the move to rich client web apps is to improve the user experience. These applications are more responsive and can support more detailed and stateful interactions.</p>
<p>One such interaction involves multiple concurrent users interacting with the same resource in realtime. We can deliver a more seamless experience by propagating users' changes to one another as they take place: when we edit the same document, I see your changes on my screen as you type them. If you’ve ever used Google Docs or Google Wave, you’ve seen this in action.</p>
<p>So, how can we build this functionality into our own applications?</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_the_moving_parts"></a>The moving parts</h4></div></div></div>
<p>There are a few different pieces that we’ll put together for this.  The basic parts are:</p>
<div class="orderedlist"><ol type="1">
<li>
Change events. The fundamental unit of information that we broadcast through our system to keep clients in sync.  Delivered as messages, these events contain enough information for any receiving client to update its own data without needing a full re-fetch from the server.
</li>
<li>
An event source.  With trusted clients, changes can originate directly from the client.  More often, however, we will want the server to arbitrate changes so that it can apply authorization, data filtering, and validations.
</li>
<li>
A transport layer that supports pushing to clients.  <a class="ulink" href="http://www.w3.org/TR/websockets/" target="_top">The WebSocket API</a> is such a transport, and is ideal for its low overhead and latency.
</li>
<li>
Event-driven clients.  Clients should be able to react to incoming change events, ideally handling them with incremental UI updates rather than re-drawing themselves entirely.  Backbone.js helps out in this department, as your client-side application app is likely already set up to handle such events.
</li>
<li>
A message bus.  Separating the concern of message delivery from our main application helps it stay smaller and helps us scale our messaging and application infrastructure separately. There are already several great off-the-shelf tools we can use for this.
</li>
</ol></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_putting_it_together_a_look_at_the_life_cycle_of_a_change"></a>Putting it together: a look at the life cycle of a change</h4></div></div></div>
<p>Revisiting our todo application, we’d like to add the ability to collaborate on todo lists.  Different users will be able to work on the same todo list concurrently.  Several users can look at the same list; adding, changing, and checking off items.</p>
<p>There are a few technical decisions mentioned previously.  For this example, we will:</p>
<div class="orderedlist"><ol type="1">
<li>
Use Rails on the server and Backbone on the client.
</li>
<li>
Use the server as the canonical event source so that clients do not have to trust one another.  In particular, we’ll employ an <code class="literal">ActiveRecord::Observer</code> that observes Rails model changes and dispatches a change event.
</li>
<li>
Use <a class="ulink" href="http://faye.jcoglan.com" target="_top">Faye</a> as the messaging backend, which has Ruby and JavaScript implementations for clients and server.  Faye implements the <a class="ulink" href="http://svn.cometd.com/trunk/bayeux/bayeux.html" target="_top">Bayeux protocol</a>, prefers WebSocket for transport (thought it gracefully degrades to long polling, CORS, or JSON-P), and supports a bunch of other goodies like clustering and extensions (inbound- and outbound- message filtering, like Rack middleware).
</li>
</ol></div>
<p>In our application, there are several connected clients viewing the same todo list, and one user Alice makes a change to an item on the list.</p>
<p>Let’s take a look at the lifecycle of one change event.</p>
<p>TODO: System-partitioned sequence diagram</p>
<p>Setup:</p>
<div class="orderedlist"><ol type="1">
<li>
An instance of JavaScript class <code class="literal">BackboneSync.FayeSubscriber</code> is instantiated on each client.  It is configured with a channel to listen to, and a collection to update.
</li>
<li>
The Faye server is started.
</li>
<li>
The Rails server is started, and several clients are connected and viewing <code class="literal">#todo_lists/1</code>.
</li>
</ol></div>
<p>On Alice’s machine, the client responsible for the change:</p>
<div class="orderedlist"><ol type="1">
<li>
Alice clicks "Save" in her view of the list.
</li>
<li>
The "save" view event is triggered.
</li>
<li>
The event handler invokes <code class="literal">this.model.save(attributes)</code>.
</li>
<li>
<code class="literal">Backbone.Model.prototype.save</code> calls <code class="literal">Backbone.sync</code>.
</li>
<li>
<code class="literal">Backbone.sync</code> invokes <code class="literal">$.ajax</code> and issues an HTTP PUT request to the server.
</li>
</ol></div>
<p>On the server:</p>
<div class="orderedlist"><ol type="1">
<li>
Rails handles the PUT request and calls <code class="literal">#update_attributes</code> on an ActiveRecord model instance.
</li>
<li>
An <code class="literal">ActiveRecord::Observer</code> observing this model gets its <code class="literal">#after_save</code> method invoked.
</li>
<li>
The observer dispatches a change event message to Faye.
</li>
<li>
Faye broadcasts the change event to all subscribers.
</li>
</ol></div>
<p>On all clients:</p>
<div class="orderedlist"><ol type="1">
<li>
<code class="literal">FayeSubscriber</code> receives the change event message, likely over a WebSocket.
</li>
<li>
The subscriber parses the event message, picking out the event (<code class="literal">update</code>), the <code class="literal">id</code> of the model to update, and a new set of attributes to apply.
</li>
<li>
The <code class="literal">FayeSubscriber</code> fetches the model from the collection, and calls <code class="literal">set</code> on it to update its attributes.
</li>
</ol></div>
<p>Now all the clients have received the changeset that Alice made.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_implementation_step_1_faye_server"></a>Implementation: Step 1, Faye server</h4></div></div></div>
<p>We’ll need to run Faye to relay messages from publishers to subscribers.  For
Rails apps that depend on Faye, I like to keep a <code class="literal">faye/</code> subdirectory under the
app root that contains a <code class="literal">Gemfile</code> and <code class="literal">config.ru</code>, and maybe a shell script to
start Faye:</p>
<pre class="programlisting">$ cat faye/Gemfile

source 'http://rubygems.org'
gem 'faye'

$ cat faye/config.ru

require 'faye'
bayeux = Faye::RackAdapter.new(:mount =&gt; '/faye', :timeout =&gt; 25)
bayeux.listen(9292)

$ cat faye/run.sh

#!/usr/bin/env bash
BASEDIR=$(dirname $0)
BUNDLE_GEMFILE=$BASEDIR/Gemfile
bundle exec rackup $BASEDIR/config.ru -s thin -E production

$ ./faye/run.sh

&gt;&gt; Thin web server (v1.2.11 codename Bat-Shit Crazy)
&gt;&gt; Maximum connections set to 1024
&gt;&gt; Listening on 0.0.0.0:9292, CTRL+C to stop</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_implementing_it_step_2_activerecord_observers"></a>Implementing it: Step 2, ActiveRecord observers</h4></div></div></div>
<p>Now that the message bus is running, let’s walk through the server code.  The
Rails app’s responsibility is this: whenever a Todo model is created, updated,
or deleted, publish a change event message.</p>
<p>This is implemented with an ActiveRecord::Observer.  We provide the
functionality in a module:</p>
<pre class="programlisting"><b class="hl-keyword">module</b> BackboneSync
  <b class="hl-keyword">module</b> Rails
    <b class="hl-keyword">module</b> Faye
      mattr_accessor :root_address
      <b class="hl-keyword">self</b>.root_address = <b class="hl-string"><i style="color:red">'http://localhost:9292'</i></b>

      <b class="hl-keyword">module</b> Observer
        <b class="hl-keyword">def</b> after_update(model)
          Event.new(model, :update).publish
        <b class="hl-keyword">end</b>

        <b class="hl-keyword">def</b> after_create(model)
          Event.new(model, :create).publish
        <b class="hl-keyword">end</b>

        <b class="hl-keyword">def</b> after_destroy(model)
          Event.new(model, :destroy).publish
        <b class="hl-keyword">end</b>
      <b class="hl-keyword">end</b>

      <b class="hl-keyword">class</b> Event
        <b class="hl-keyword">def</b> initialize(model, event)
          @model = model
          @event = event
        <b class="hl-keyword">end</b>

        <b class="hl-keyword">def</b> broadcast
          Net::HTTP.post_form(uri, :message =&gt; message)
        <b class="hl-keyword">end</b>

        private

        <b class="hl-keyword">def</b> uri
          URI.parse(<b class="hl-string"><i style="color:red">"#{BackboneSync::Rails::Faye.root_address}/faye"</i></b>)
        <b class="hl-keyword">end</b>

        <b class="hl-keyword">def</b> message
          { :channel =&gt; channel,
            :data =&gt; data          }.to_json
        <b class="hl-keyword">end</b>

        <b class="hl-keyword">def</b> channel
          <b class="hl-string"><i style="color:red">"/sync/#{@model.class.table_name}"</i></b>
        <b class="hl-keyword">end</b>

        <b class="hl-keyword">def</b> data
          { @event =&gt; { @model.id =&gt; @model.as_json } }
        <b class="hl-keyword">end</b>
      <b class="hl-keyword">end</b>
    <b class="hl-keyword">end</b>
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre>
<p>and then mix it into a concrete Observer class in our application.  In this
case, we name it <code class="literal">TodoObserver</code>:</p>
<pre class="programlisting"><b class="hl-keyword">class</b> TodoObserver &lt; ActiveRecord::Observer
  include BackboneSync::Rails::Faye::Observer
<b class="hl-keyword">end</b></pre>
<p>This observer is triggered each time a Rails <code class="literal">Todo</code> model is created, updated,
or destroyed.  When one of these events happen, the Observer sends along a
message to our message bus, indicating the change.</p>
<p>Let’s say that a <code class="literal">Todo</code> was just created:</p>
<pre class="programlisting">&gt;&gt; Todo.create(title: <b class="hl-string"><i style="color:red">"Buy some tasty kale juice"</i></b>)
=&gt; <i class="hl-comment" style="color: silver">#&lt;Todo id: 17, title: "Buy some tasty kale juice", created_at: "2011-09-06 20:49:03", updated_at: "2011-09-07 15:01:09"&gt;</i></pre>
<p>The message looks like this:</p>
<pre class="programlisting">{
  <b class="hl-string"><i style="color:red">"channel"</i></b>: <b class="hl-string"><i style="color:red">"/sync/todos"</i></b>,
  <b class="hl-string"><i style="color:red">"data"</i></b>: {
    <b class="hl-string"><i style="color:red">"create"</i></b>: {
      <b class="hl-string"><i style="color:red">"17"</i></b>: {
        <b class="hl-string"><i style="color:red">"id"</i></b>: <span class="hl-number">17</span>,
        <b class="hl-string"><i style="color:red">"title"</i></b>: <b class="hl-string"><i style="color:red">"Buy some tasty kale juice"</i></b>,
        <b class="hl-string"><i style="color:red">"created_at"</i></b>: <b class="hl-string"><i style="color:red">"2011-09-06T20:49:03Z"</i></b>,
        <b class="hl-string"><i style="color:red">"updated_at"</i></b>: <b class="hl-string"><i style="color:red">"2011-09-07T15:01:09Z"</i></b>
      }
    }
  }
}</pre>
<p>Received by Faye, the message is broadcast to all clients subscribing to the
<code class="literal">/sync/todos</code> channel, including our browser-side <code class="literal">FayeSubscriber</code> objects.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_implementing_it_step_3_in_browser_subscribers"></a>Implementing it: Step 3, In-browser subscribers</h4></div></div></div>
<p>In each browser, we want to connect to the Faye server, subscribe to events on
channels that interest us, and update Backbone collections based on those
messages.</p>
<p>Faye runs an HTTP server, and serves up its own client library, so that’s easy to pull in:</p>
<pre class="programlisting"><b class="hl-tag" style="color: #000096">&lt;script</b> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"text/javascript"</span> <span class="hl-attribute" style="color: #F5844C">src</span>=<span class="hl-value" style="color: #993300">"http://localhost:9292/faye.js"</span><b class="hl-tag" style="color: #000096">&gt;</b><b class="hl-tag" style="color: #000096">&lt;/script&gt;</b></pre>
<p>To subscribe to Faye channels, instantiate a <code class="literal">Faye.Client</code> and call <code class="literal">subscribe</code> on it:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> client = <b class="hl-keyword">new</b> Faye.Client(<b class="hl-string"><i style="color:red">'http://localhost:9292/faye'</i></b>);
client.subscribe(<b class="hl-string"><i style="color:red">'/some/channel'</i></b>, <b class="hl-keyword">function</b>(message) {
  <i class="hl-comment" style="color: silver">// handle message</i>
});</pre>
<p>When the browser receives messages from Faye, we want to update a Backbone
collection.  Let’s wrap up those two concerns into a <code class="literal">FayeSubscriber</code>:</p>
<pre class="programlisting"><b class="hl-keyword">this</b>.BackboneSync = <b class="hl-keyword">this</b>.BackboneSync || {};

BackboneSync.RailsFayeSubscriber = (<b class="hl-keyword">function</b>() {
  <b class="hl-keyword">function</b> RailsFayeSubscriber(collection, options) {
    <b class="hl-keyword">this</b>.collection = collection;
    <b class="hl-keyword">this</b>.client = <b class="hl-keyword">new</b> Faye.Client(<b class="hl-string"><i style="color:red">'&lt;%= BackboneSync::Rails::Faye.root_address %&gt;/faye'</i></b>);
    <b class="hl-keyword">this</b>.channel = options.channel;
    <b class="hl-keyword">this</b>.subscribe();
  }

  RailsFayeSubscriber.<b class="hl-keyword">prototype</b>.subscribe = <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.client.subscribe(<b class="hl-string"><i style="color:red">"/sync/"</i></b> + <b class="hl-keyword">this</b>.channel, _.bind(<b class="hl-keyword">this</b>.receive, <b class="hl-keyword">this</b>));
  };

  RailsFayeSubscriber.<b class="hl-keyword">prototype</b>.receive = <b class="hl-keyword">function</b>(message) {
    <b class="hl-keyword">var</b> self = <b class="hl-keyword">this</b>;
    <b class="hl-keyword">return</b> $.each(message, <b class="hl-keyword">function</b>(event, eventArguments) {
      <b class="hl-keyword">return</b> self[event](eventArguments);
    });
  };

  RailsFayeSubscriber.<b class="hl-keyword">prototype</b>.update = <b class="hl-keyword">function</b>(params) {
    <b class="hl-keyword">var</b> self = <b class="hl-keyword">this</b>;
    <b class="hl-keyword">return</b> $.each(params, <b class="hl-keyword">function</b>(id, attributes) {
      <b class="hl-keyword">var</b> model = self.collection.get(id);
      <b class="hl-keyword">return</b> model.set(attributes);
    });
  };

  RailsFayeSubscriber.<b class="hl-keyword">prototype</b>.create = <b class="hl-keyword">function</b>(params) {
    <b class="hl-keyword">var</b> self = <b class="hl-keyword">this</b>;
    <b class="hl-keyword">return</b> $.each(params, <b class="hl-keyword">function</b>(id, attributes) {
      <b class="hl-keyword">var</b> model = <b class="hl-keyword">new</b> self.collection.model(attributes);
      <b class="hl-keyword">return</b> self.collection.add(model);
    });
  };

  RailsFayeSubscriber.<b class="hl-keyword">prototype</b>.destroy = <b class="hl-keyword">function</b>(params) {
    <b class="hl-keyword">var</b> self = <b class="hl-keyword">this</b>;
    <b class="hl-keyword">return</b> $.each(params, <b class="hl-keyword">function</b>(id, attributes) {
      <b class="hl-keyword">var</b> model = self.collection.get(id);
      <b class="hl-keyword">return</b> self.collection.remove(model);
    });
  };

  <b class="hl-keyword">return</b> RailsFayeSubscriber;
})();</pre>
<p>Now, for each collection that we’d like to keep in sync, we instantiate a
corresponding <code class="literal">FayeSubscriber</code>.  Say, in your application bootstrap code:</p>
<pre class="programlisting">MyApp.Routers.TodosRouter = Backbone.Router.extend({
  initialize: <b class="hl-keyword">function</b>(options) {
    <b class="hl-keyword">this</b>.todos = <b class="hl-keyword">new</b> Todos.Collections.TodosCollection();
    <b class="hl-keyword">new</b> BackboneSync.FayeSubscriber(<b class="hl-keyword">this</b>.todos, { channel: <b class="hl-string"><i style="color:red">'todos'</i></b> });
    <b class="hl-keyword">this</b>.todos.reset(options.todos);
  },

  <i class="hl-comment" style="color: silver">// ...</i>
});</pre>
<p>Now run the app, and watch browsers receive push updates!</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_testing_synchronization"></a>Testing synchronization</h4></div></div></div>
<p>Of course, this introduces a great deal of complexity into your app. There’s a
new daemon running on the server (faye), and every client now has to correctly
listen on its messages and rerender the appropriate views to show the new data.
This gets even more complex when the resource being updated is currently being
edited by another user. Your own requirements will ditcate the correct behavior
in cases like that, but what’s most important is that you are able to reproduce
such workflows in automated tests.</p>
<p>While there is a chapter dedicated to testing Backbone applications, this section
describes the tools and approach that will allow you to verify this behavior in
tests.</p>
<p>Following an outside-in development approach, we start with an acceptance test
and dive into the isolated testing examples when the acceptance tests drive us
to them. There’s nothing novel in regards to isolation testing of these
components, so we will not touch on them here. Instead, we’ll describe how to
write an acceptance test for the above scenario.</p>
<p>The required pieces for the approach are:</p>
<div class="itemizedlist"><ul type="disc">
<li>
Ensure a faye server running on your testing environment.
</li>
<li>
Fire up a browser session using an browser acceptance testing framework.
</li>
<li>
Sign in as Alice.
</li>
<li>
Start a second browser session and sign in as Olivia.
</li>
<li>
Edit some data on Alice’s session.
</li>
<li>
See the edited data reflected on Olivia’s session.
</li>
</ul></div>
<p>We will be using cucumber with Capybara and RSpec for this example.</p>
<p>To ensure the Faye server is running, we merely try to make a connection
to it when cucumber boots, failing early if we can’t connect. Here’s a
small snippet that you can drop in <code class="literal">features/support/faye.rb</code> to do
just that:</p>
<pre class="programlisting"><b class="hl-keyword">begin</b>
  Timeout.timeout(<span class="hl-number">1</span>) <b class="hl-keyword">do</b>
    uri = URI.parse(BackboneSync::Rails::Faye.root_address)
    TCPSocket.new(uri.host, uri.port).close
  <b class="hl-keyword">end</b>
<b class="hl-keyword">rescue</b> Errno::ECONNREFUSED, Errno::EHOSTUNREACH, Timeout::Error
  raise <b class="hl-string"><i style="color:red">"Could not connect to Faye"</i></b>
<b class="hl-keyword">end</b></pre>
<p>With that in place, we are now sure that Faye is running and we can move
on to our cucumber scenario. Create a <code class="literal">features/sync_task.feature</code> file
and let’s describe the desired functionality:</p>
<pre class="programlisting">  @javascript
  Scenario: Viewing a task edited by another user
    Given the following users exist:
      | email               |
      | alice@example.com   |
      | olivia@example.com  |
    Given the following task exists:
      | title                  |
      | Purchase Cheeseburgers |
    And I am using session "Alice"
    And I sign in as "alice@example.com"
    Then I should see "Purchase Cheeseburgers"
    When I switch to session "Olivia"
    And I sign in as "olivia@example.com"
    And I edit the "Purchase Cheeseburgers" task and rename it to "Purchase Giant Cheeseburgers"
    And I switch to session "Alice"
    Then I should see "Purchase Giant Cheeseburgers"</pre>
<p>Thankfully, Capybara allows us to run acceptance tests with client side
behavior by specifying different drivers to run scenarios that require
javascript vs. those which don’t. The very first line above, <code class="literal">@javascript</code>,
tells capybara to use a javascript enabled driver such as selenium or
capybara-webkit.</p>
<p>The following two steps that create some fixture data are provided by
<a class="ulink" href="https://github.com/thougthbot/factory_girl" target="_top">FactoryGirl</a>, which looks
into your factory definitions and builds step definitions based on their
attributes and associations.</p>
<p>But then we get into the meat of the problem: switching sessions. Capybara
introduced the ability to name and switch sessions in your scenarios via
the <code class="literal">session_name</code> method. The definition for the <code class="literal">I am using session
"Alice"</code> step looks like so:</p>
<pre class="programlisting">When /^I (?:am using|switch to) session <b class="hl-string"><i style="color:red">"([^"</i></b>]+)<b class="hl-string"><i style="color:red">"$/ do |new_session_name|
</i></b>  Capybara.session_name = new_session_name
<b class="hl-keyword">end</b></pre>
<p>This allows us to essentially open up different browsers, in the case you’re
using the selenium driver, and it is the key to exercising background syncing
code in capybara acceptance testing.</p>
<p>With this in place, the rest is quite straightforward — we simply interact
with the application as you would with any cucumber scenario, visiting pages,
filling in forms, and verifying results on the page, all the while specifying
which session you’re interacting with.</p>
<p>Additionally, the <code class="literal">BackboneSync.FayeSubscriber</code> javascript class should also
be tested in isolation. We’ve used jasmine for testing javascript behavior
succesfully, so it is the approach we recommend. For more information about
using jasmine, refer to the chapter on testing.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_more_reading"></a>More reading</h4></div></div></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>Faye implements a messaging protocol called Bayeux: <a class="ulink" href="http://svn.cometd.com/trunk/bayeux/bayeux.html" target="_top">http://svn.cometd.com/trunk/bayeux/bayeux.html</a></p>
</div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>Read up on idempotent messages.  Check out this solid, readable article <a class="ulink" href="http://devhawk.net/2007/11/09/the-importance-of-idempotence/" target="_top">The Importance of Idempotence</a>.</p>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_uploading_attachments"></a>Uploading attachments</h3></div></div></div>
<p>While Ruby gems such as paperclip make the API for attaching files to models
very similar to the standard ActiveModel attribute persistence API, attaching
files to Backbone models is not quite as straightforward.  In this section,
we’ll take a look at the general approach for attaching files, and then examine
the specific implementation used in the example application.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_how_to_attach_files_to_backbone_models"></a>How to attach files to Backbone models</h4></div></div></div>
<p>If you upload to a backbone model, you can’t do it in a typical async request.
Meaning, <code class="literal">model.save()</code> can’t just send a file to the server like other
attributes.  Instead, we save the attachment in a separate request, and then
just swap in an attachment id on the model. This does mean that you can have
unclaimed attachments if the end user leaves the page before saving the parent
model, but those can be periodically cleaned out if the disk usage is an issue.</p>
<p>When modeling this from the Rails side, you can choose to persist the file
upload identifier (e.g. the local path or S3 URL) on one of your models
directly, or you can break the attachment out into its own ActiveRecord model.
It’s generally more straightforward to break the attachment out into its own
model, because this can greatly simplify grabbing the attachment reference.</p>
<p>There are quite a few approaches to uploading files asynchronously, and browser
support varies.  There are features like multiple file upload and drag-and-drop
to consider, too.</p>
<p>We’ll use the HTML5 File API because it’s a straightforward approach that is
supported by modern browsers.  The API is small and the wrapper code that we
start with:</p>
<p><a class="ulink" href="https://github.com/mockenoff/HTML5-AJAX-File-Uploader" target="_top">https://github.com/mockenoff/HTML5-AJAX-File-Uploader</a></p>
<p>is easy to read.  This approach requires XHR2 and FormData:</p>
<div class="itemizedlist"><ul type="disc"><li>
<a class="ulink" href="https://developer.mozilla.org/en/XMLHttpRequest/FormData" target="_top">https://developer.mozilla.org/en/XMLHttpRequest/FormData</a>
</li></ul></div>
<p>If you would like to provide fallback support for older
browsers, using Flash or iframes, you can do so with plugins like (TODO:
recommend plugins).</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_example_attaching_images_to_tasks"></a>Example: Attaching images to Tasks</h4></div></div></div>
<p>In our example task management app, we’d like for the owner of a task to attach
several images to each task.  We want uploads to happen in the task detail view,
and for the uploads to appear in-page as soon as they are uploaded.  We don’t
need to display uploads on the index view.</p>
<p>First, let’s write an acceptance test to drive the functionality:</p>
<pre class="programlisting">@javascript
Feature: Attach a file to a task

  As a user
  I want to attach files to a task
  So that I can include reference materials

  Background:
    Given I am signed up as "email@example.com"
    When I sign in as "email@example.com"
    And I go to the tasks page
    And I create a task "Buy"
    And I create a task "Eat"

  Scenario: Attach a file to a task
    When I attach "spec/fixtures/blueberries.jpg" to the "Buy" task
    Then I should see "blueberries.jpg" attached to the "Buy" task
    And I should see no attachments on the "Eat" task

  Scenario: Attach multiple files to a task
    When I attach "spec/fixtures/blueberries.jpg" to the "Buy" task
    And I attach "spec/fixtures/strawberries.jpg" to the "Buy" task
    Then I should see "blueberries.jpg" attached to the "Buy" task
    And I should see "strawberries.jpg" attached to the "Buy" task</pre>
<p>The first failures we get are from the lack of upload UI.  We’ll drop down to
unit tests to drive this out:</p>
<pre class="programlisting"><i class="hl-comment" style="color: silver">//= require application</i>

describe(<b class="hl-string"><i style="color:red">"ExampleApp.Views.TaskShow"</i></b>, <b class="hl-keyword">function</b>() {
  <b class="hl-keyword">var</b> task, view, $el;

  beforeEach(<b class="hl-keyword">function</b>() {
    task = <b class="hl-keyword">new</b> ExampleApp.Models.Task({
      id: <span class="hl-number">1</span>,
      title: <b class="hl-string"><i style="color:red">"Wake up"</i></b>
    });

    view = <b class="hl-keyword">new</b> ExampleApp.Views.TaskShow({ model: task });
    $el = $(view.render().el);
  });

  it(<b class="hl-string"><i style="color:red">"renders the detail view for a task"</i></b>, <b class="hl-keyword">function</b>() {
    expect($el).toHaveText(/Wake up/);
  });

  it(<b class="hl-string"><i style="color:red">"renders a file upload area"</i></b>, <b class="hl-keyword">function</b>() {
    expect($el).toContain(<b class="hl-string"><i style="color:red">".upload label:contains('Attach a file to upload')"</i></b>);
    expect($el).toContain(<b class="hl-string"><i style="color:red">".upload button:contains('Upload attachment')"</i></b>);
    expect($el).toContain(<b class="hl-string"><i style="color:red">".upload input[type=file]"</i></b>);
  });

  it(<b class="hl-string"><i style="color:red">"links the upload label and input"</i></b>, <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> $label = $el.find(<b class="hl-string"><i style="color:red">'.upload label'</i></b>);
    <b class="hl-keyword">var</b> $input = $el.find(<b class="hl-string"><i style="color:red">'.upload input'</i></b>);
    expect($label.attr(<b class="hl-string"><i style="color:red">'for'</i></b>)).toEqual($input.attr(<b class="hl-string"><i style="color:red">'id'</i></b>));
  });
});</pre>
<p>Then, we’ll add the upload form to the TaskShow view to the <code class="literal">tasks/show.jst.ejs</code>
template, so the UI elements are in place:</p>
<pre class="programlisting">&lt;p&gt;Task title&lt;/p&gt;

&lt;ul class="attachments"&gt;
&lt;/ul&gt;

&lt;div class="upload"&gt;
  &lt;label for="input"&gt;Attach a file to upload&lt;/label&gt;
  &lt;input type="file" name="file" /&gt;
  &lt;button&gt;Upload attachment&lt;/button&gt;
&lt;/div&gt;</pre>
<p>Once our units pass, we run the acceptance tests again. The next failure we see
is that nothing happens upon upload.  We’ll drop down to Jasmine here to write
unit tests for the uploading:</p>
<pre class="programlisting"><i class="hl-comment" style="color: silver">//= require application</i>

describe(<b class="hl-string"><i style="color:red">"ExampleApp.Views.TaskShow uploading"</i></b>, <b class="hl-keyword">function</b>() {
  <b class="hl-keyword">var</b> task, view, $el;

  beforeEach(<b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.xhr = sinon.useFakeXMLHttpRequest();
    <b class="hl-keyword">var</b> requests = <b class="hl-keyword">this</b>.requests = []

    <b class="hl-keyword">this</b>.xhr.onCreate = <b class="hl-keyword">function</b>(xhr) {
      requests.push(xhr);
    };

    <b class="hl-keyword">this</b>.xhr.<b class="hl-keyword">prototype</b>.upload = {
      addEventListener: <b class="hl-keyword">function</b>() {}
    };

    task = <b class="hl-keyword">new</b> ExampleApp.Models.Task({
      id: <span class="hl-number">1</span>,
      title: <b class="hl-string"><i style="color:red">"Wake up"</i></b>
    });

    view = <b class="hl-keyword">new</b> ExampleApp.Views.TaskShow({ model: task });
  });

  afterEach(<b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.xhr.restore();
  });

  it(<b class="hl-string"><i style="color:red">"uploads the file when the upload button is clicked"</i></b>, <b class="hl-keyword">function</b>() {
    view.uploadInput = <b class="hl-keyword">function</b>() {
      <b class="hl-keyword">return</b> { files: [<b class="hl-string"><i style="color:red">"uploaded file contents"</i></b>], }
    };

    $el = $(view.render().el);
    view.upload();

    expect(<b class="hl-keyword">this</b>.requests.length).toEqual(<span class="hl-number">1</span>);
    expect(<b class="hl-keyword">this</b>.requests[<span class="hl-number">0</span>].url).toEqual(<b class="hl-string"><i style="color:red">"/tasks/1/attachments.json"</i></b>);
  });
});</pre>
<p>TODO: Finish outline:</p>
<div class="itemizedlist"><ul type="disc">
<li>
NB: You can’t overwrite input.files (a FileList instance), so you’ll have to
provide a point of fake injection; in our case, TaskShow#uploadInput().
</li>
<li>
Make it pass by adding uploader.js and adding uploader logic to TaskShow view
</li>
<li>
Now we are uploading, but the server isn’t accepting/persisting
</li>
<li>
<p>
Test-drive persistence on server side:
</p>
<div class="itemizedlist"><ul type="circle">
<li>
Add paperclip gem
</li>
<li>
Create Attachment model, route, controller.  Test-drive the units.
</li>
<li>
NB on integration point: XHR requests from BB to Rails needs CSRF tokens, so inject
   as uploader.prefilter, analagous to $.ajaxPrefilter <a class="ulink" href="http://api.jquery.com/extending-ajax/" target="_top">http://api.jquery.com/extending-ajax/</a>
</li>
</ul></div>
</li>
<li>
Next, display existing attachments to the user.
</li>
</ul></div>
<p>For structuring the attachments in Backbone, we want to be able to do something
like the following:</p>
<pre class="programlisting">&lt;% this.task.attachments.each(function(attachment) { %&gt;
  Attached: &lt;img src="&lt;%= attachment.get('upload_url')" /&gt; %&gt;
&lt;% }); %&gt;</pre>
<p>So, the Task model will have attachments property that is instantiates with an
AttachmentsCollection instance.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>This is written assuming that the model_relationships.asc chapter came
first and discusses how to structure the JSON, which is bundling the comments
and attachments associations under the Task’s JSON representation.  It should
introduce and discuss using Rabl, too. Depending on how in-depth that section
is, we may need to write more here to contextualize.</p>
</div>
<p>We’re providing a JSON represenatation using Rabl, rooted at the Task:</p>
<pre class="programlisting">object @task

attributes :id, :created_at, :updated_id, :title, :complete, :user_id

child :attachments <b class="hl-keyword">do</b>
  attributes :id, :created_at, :updated_id, :upload_file_name, :upload_url
<b class="hl-keyword">end</b></pre>
<p>Note that you have to have to tell Rabl to suppress the root JSON node, just
like we suppress the root JSON node in ActiveRecord with
<code class="literal">ActiveRecord::Base.include_root_in_json = false</code>:</p>
<pre class="programlisting"><i class="hl-comment" style="color: silver"># config/initializers/rabl_init.rb</i>
Rabl.configure <b class="hl-keyword">do</b> |config|
  config.include_json_root = <b class="hl-keyword">false</b>
<b class="hl-keyword">end</b></pre>
<p>We can test drive the attachment display from Jasmine, see task_show_spec.js:</p>
<pre class="programlisting"><i class="hl-comment" style="color: silver">//= require application</i>

describe(<b class="hl-string"><i style="color:red">"ExampleApp.Views.TaskShow for a task with attachments"</i></b>, <b class="hl-keyword">function</b>() {
  <b class="hl-keyword">var</b> task, view, $el;

  beforeEach(<b class="hl-keyword">function</b>() {
    task = <b class="hl-keyword">new</b> ExampleApp.Models.Task({
      id: <span class="hl-number">1</span>,
      title: <b class="hl-string"><i style="color:red">"Buy pies"</i></b>,
      attachments: [
        {
          upload_file_name: <b class="hl-string"><i style="color:red">"blueberries.jpg"</i></b>,
          upload_url: <b class="hl-string"><i style="color:red">"http://www.realblueberries.com/images/Blueberry-Cluster-1.jpg"</i></b>
        },
        {
          upload_file_name: <b class="hl-string"><i style="color:red">"strawberries.jpg"</i></b>,
          upload_url: <b class="hl-string"><i style="color:red">"http://strawberriesweb.com/three-strawberries.jpg"</i></b>
        }
      ]
    });

    view = <b class="hl-keyword">new</b> ExampleApp.Views.TaskShow({ model: task });
    $el = $(view.render().el);
  });

  it(<b class="hl-string"><i style="color:red">"displays attachments"</i></b>, <b class="hl-keyword">function</b>() {
    expect($el).toContain(<b class="hl-string"><i style="color:red">".attachments img[src='http://www.realblueberries.com/images/Blueberry-Cluster-1.jpg']"</i></b>)
    expect($el).toContain(<b class="hl-string"><i style="color:red">".attachments img[src='http://strawberriesweb.com/three-strawberries.jpg']"</i></b>)
  });

  it(<b class="hl-string"><i style="color:red">"displays attachment filenames"</i></b>, <b class="hl-keyword">function</b>() {
    expect($el.find(<b class="hl-string"><i style="color:red">".attachments p"</i></b>).first()).toHaveText(<b class="hl-string"><i style="color:red">'Attached: blueberries.jpg'</i></b>);
    expect($el.find(<b class="hl-string"><i style="color:red">".attachments p"</i></b>).last()).toHaveText(<b class="hl-string"><i style="color:red">'Attached: strawberries.jpg'</i></b>);
  });
});</pre>
<p>This depends on parsing the JSON from the client side, so test drive that for
the ExampleApp.Models.Tasks Jasmine spec:</p>
<div class="itemizedlist"><ul type="disc">
<li>
Include spec/javascripts/models/task_spec.js
</li>
<li>
Implement in task.js
</li>
<li>
TDD Attachments collection and Attachment model
</li>
<li>
Implement Attachments collection and Attachment model
</li>
<li>
Green?
</li>
</ul></div>
</div>
</div>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a id="ftn.d0e2886" href="#d0e2886" class="simpara">1</a>] </sup>At least, we
have a guarantee at the application level - database integrity and the
possibility of skew between Rails models and DB content is another discussion
entirely.</p></div>
</div>
</div>

    </div>

    <hr/>

    <div class="nav" id="navfooter">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="routers_views_and_templates.html">Prev</a><br/>
         Routers, Views, and Templates
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         Backbone.js on Rails
        
      </td><td width="33%" align="right">
        
          <a href="testing.html">Next</a><br/>
          Testing
        
      </td></tr>
    </table>
    </div>
  </body>
</html>
