<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="master.css" type="text/css" />
    <title>Models and collections</title>
  </head>

  <body>
    <div class="nav" id="navheader">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="routers_views_and_templates.html">Prev</a><br/>
         Routers, Views, and Templates
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         <strong>Backbone.js on Rails</strong>
        
      </td><td width="33%" align="right">
        
          <a href="testing_section_unstarted_.html">Next</a><br/>
          Testing (section unstarted)
        
      </td></tr>
    </table>
    </div>

    <hr/>

    <div class="content">
      <div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a id="_models_and_collections"></a>Models and collections</h2></div></div></div>
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title">
<a id="_naming_conventions_chapter_unstarted"></a>Naming conventions (chapter unstarted)</h3></div></div></div></div>
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title">
<a id="_nested_resources_chapter_unstarted"></a>Nested resources (chapter unstarted)</h3></div></div></div></div>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_model_associations"></a>Model associations</h3></div></div></div>
<p>Backbone.js doesn’t prescribe a way to define associations between models, so
we need to get creative and use the power of JavaScript to set up associations
in such a way that its usage is natural.</p>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_belongs_to_associations"></a>Belongs to associations</h4></div></div></div>
<p>Setting up a <code class="literal">belongs_to</code> association in Backbone is a two step process. Let’s
discuss setting up the association that may occur between a task and a user.
The end result of the approach is a <code class="literal">Task</code> instance having a property called
<code class="literal">user</code> where we store the associated <code class="literal">User</code> object.</p>
<p>To set this up, let’s start by telling Rails to augment the task’s JSON
representation to also send over the associated user attributes:</p>
<pre class="programlisting">class Task &lt; ActiveRecord::Base
  belongs_to :user

  def as_json(options = {})
    super(include: { user: { only: [:name, :email] } })
  end
end</pre>
<p>This means that when Backbone calls <code class="literal">fetch()</code> for a <code class="literal">Task</code> model, it will
include the name and email of the associated user nested within the task JSON
representation. Something like this:</p>
<pre class="programlisting">{
  "title": "Buy more Cheeseburgers",
  "due_date": "2011-03-04",
  "user": {
    "name": "Robert McGraffalon",
    "email": "bobby@themcgraffalons.com"
  }
}</pre>
<p>Now that we receive user data with the task’s JSON representation, let’s tell
our Backbone User model to store the User object. We do that on the task’s
initializer. Here’s a first cut at that:</p>
<pre class="programlisting">var Task = Backbone.Model.extend({
  initialize: function() {
    this.user = new User(this.get('user'));
  }
});</pre>
<p>We can make a couple of improvements to the above. First, you’ll soon realize
that you might be setting the user outside of the initialize as well. Second,
the initializer should check whether there is user data in the first place. To
address the first concern, let’s create a setter for the object. Backbone
provides a handy function called <code class="literal">has</code> that returns true or false depending on
whether the provided option is set for the object:</p>
<pre class="programlisting">var Task = Backbone.Model.extend({
  initialize: function() {
    if (this.has('user')) {
      this.setUser(new User(this.get('user')));
    }
  },

  setUser: function(user) {
    this.user = user;
  }
});</pre>
<p>The final setup allows for a nice clean interface to a task’s user, by
accessing the task property of the user instance.</p>
<pre class="programlisting">var task = Task.fetch(1);
console.log(task.get('title') + ' is being worked on by ' + task.user.get('name'));</pre>
</div>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_has_many_associations"></a>Has many associations</h4></div></div></div>
<p>You can take a similar approach to set up a <code class="literal">has_many</code> association on the
client side models. This time, however, the object’s property will be a
Backbone collection.</p>
<p>Following the example, say we need access to a user’s tasks. Let’s set up the
JSON representation on the Rails side first:</p>
<pre class="programlisting">class User &lt; ActiveRecord::Base
  has_many :tasks

  def as_json(options = {})
    super(include: { tasks: { only: [:body, :due_date] } })
  end
end</pre>
<p>Now, on the Backbone <code class="literal">User</code> model’s initializer, let’s call the <code class="literal">setTasks</code>
function:</p>
<pre class="programlisting">var User = Backbone.Model.extend({
  initialize: function() {
    var tasks = new Tasks.reset(this.get('tasks'));
    this.setTasks(tasks);
  },

  setTasks: function(tasks) {
    this.tasks = tasks;
  }
});</pre>
<p>Note that we are setting the relation to an instance of the <code class="literal">Tasks</code> collection.</p>
<p>TODO: Let’s exapnd upon this, as it isn’t the most flexible solution.  (It is
a good start.) We are setting the JSON representation of the Rails models to
suit the Backbone.js concerns.  Additionally, the <code class="literal">Task#as_json</code> method at the
top is concerned with the User JSON representation.  It should at least delegate
to User#as_json. Going further, the JSON presentation for consumption by
Backbone.js should be completely extracted into the JSON API endpoint controller
action, or even a separate presenter class.</p>
</div>
</div>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_filters_and_sorting"></a>Filters and sorting</h3></div></div></div>
<p>When using our Backbone models and collections, it’s often handy to filter the
collections by reusable criteria, or sort them by several different criteria.</p>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_filters"></a>Filters</h4></div></div></div>
<p>To filter a <code class="literal">Backbone.Collection</code>, like with Rails named scopes, define
functions on your collections that filter by your criteria, using the <code class="literal">select</code>
function from Underscore.js, and return new instances of the collection class. A
first implementation might look like this:</p>
<pre class="programlisting">var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  complete: function() {
    var filteredTasks = this.select(function(task) {
      return task.get('completed_at') !== null;
    });
    return new Tasks(filteredTasks);
  }
});</pre>
<p>Let’s refactor this a bit.  Ideally, the filter functions will reuse logic
already defined in your model class:</p>
<pre class="programlisting">var Task = Backbone.Model.extend({
  isComplete: function() {
    return this.get('completed_at') !== null;
  }
});

var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  complete: function() {
    var filteredTasks = this.select(function(task) {
      return task.isComplete();
    });
    return new Tasks(filteredTasks);
  }
});</pre>
<p>Going further, notice that there are actually two concerns in this function.
The first is the notion of filtering the collection, and the other is the
specific filtering criteria (<code class="literal">task.isComplete()</code>).</p>
<p>Let’s separate the two concerns here, and extract a <code class="literal">filtered</code> function:</p>
<pre class="programlisting">var Task = Backbone.Model.extend({
  isComplete: function() {
    return this.get('completed_at') !== null;
  }
});

var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  complete: function() {
    return this.filtered(function(task) {
      return task.isComplete();
    });
  },

  filtered: function(criteriaFunction) {
    return new Tasks(this.select(criteriaFunction));
  }
});</pre>
<p>We can extract this function into a reusable mixin, abstracting the <code class="literal">Tasks</code>
collection class using <code class="literal">this.constructor</code>:</p>
<pre class="programlisting">FilterableCollectionMixin = {
  filtered: function(criteriaFunction) {
    return new this.constructor(this.select(criteriaFunction));
  }
};

var Task = Backbone.Model.extend({
  isComplete: function() {
    return this.get('completed_at') !== null;
  }
});

var Tasks = Backbone.Collection.extend(_.extend({
  model: Task,
  url: '/tasks',

  complete: function() {
    return this.filtered(function(task) {
      return task.isComplete();
    });
  }
}, FilterableCollectionMixin));</pre>
</div>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_sorting"></a>Sorting</h4></div></div></div>
<p>The simplest way to sort a <code class="literal">Backbone.Collection</code> is to define a <code class="literal">comparator</code>
function.  This functionality is built in:</p>
<pre class="programlisting">var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  comparator: function(task) {
    return task.dueDate;
  }
});</pre>
<p>If you’d like to provide more than one sort order on your collection, you can
use an approach similar to the <code class="literal">filtered</code> function above, and return a new
<code class="literal">Backbone.Collection</code> whose <code class="literal">comparator</code> is overridden.  Call <code class="literal">sort</code> to update
the ordering on the new collection:</p>
<pre class="programlisting">var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  comparator: function(task) {
    return task.dueDate;
  },

  byCreatedAt: function() {
    var sortedCollection = new Tasks(this.models);
    sortedCollection.comparator = function(task) {
      return task.createdAt;
    };
    sortedCollection.sort();
    return sortedCollection;
  }
});</pre>
<p>Similarly, you can extract the reusable concern to another function:</p>
<pre class="programlisting">var Tasks = Backbone.Collection.extend({
  model: Task,
  url: '/tasks',

  comparator: function(task) {
    return task.dueDate;
  },

  byCreatedAt: function() {
    return this.sortedBy(function(task) {
      return task.createdAt;
    });
  },

  byCompletedAt: function() {
    return this.sortedBy(function(task) {
      return task.completedAt;
    });
  },

  sortedBy: function(comparator) {
    var sortedCollection = new Tasks(this.models);
    sortedCollection.comparator = comparator;
    sortedCollection.sort();
    return sortedCollection;
  }
});</pre>
<p>And then into another reusable mixin:</p>
<pre class="programlisting">var SortableCollectionMixin = {
  sortedBy: function(comparator) {
    var sortedCollection = new this.constructor(this.models);
    sortedCollection.comparator = comparator;
    sortedCollection.sort();
    return sortedCollection;
  }
};

var Tasks = Backbone.Collection.extend(_.extend({
  model: Task,
  url: '/tasks',

  comparator: function(task) {
    return task.dueDate;
  },

  byCreatedAt: function() {
    return this.sortedBy(function(task) {
      return task.createdAt;
    });
  },

  byCompletedAt: function() {
    return this.sortedBy(function(task) {
      return task.completedAt;
    });
  }
}, SortableCollectionMixin));</pre>
</div>
</div>
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title">
<a id="_client_server_duplicated_business_logic_chapter_unstarted"></a>Client/Server duplicated business logic (chapter unstarted)</h3></div></div></div></div>
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title">
<a id="_validations_chapter_unstarted"></a>Validations (chapter unstarted)</h3></div></div></div></div>
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title">
<a id="_synchronizing_between_clients_chapter_unstarted"></a>Synchronizing between clients (chapter unstarted)</h3></div></div></div></div>
</div>

    </div>

    <hr/>

    <div class="nav" id="navfooter">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="routers_views_and_templates.html">Prev</a><br/>
         Routers, Views, and Templates
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         Backbone.js on Rails
        
      </td><td width="33%" align="right">
        
          <a href="testing_section_unstarted_.html">Next</a><br/>
          Testing (section unstarted)
        
      </td></tr>
    </table>
    </div>
  </body>
</html>
