<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Testing</title><meta name="generator" content="DocBook XSL Stylesheets V1.74.1"/><link rel="home" href="index.html" title="Backbone.js on Rails"/><link rel="up" href="index.html" title="Backbone.js on Rails"/><link rel="prev" href="ar01s06.html" title="Models and collections"/><link rel="next" href="ar01s08.html" title="Security"/></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Testing</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s06.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s08.html">Next</a></td></tr></table><hr/></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_testing"/>Testing</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_full_stack_integration_testing"/>Full-stack integration testing</h3></div></div></div><p>Your application is built from a collection of loosely coupled modules,
spreading across several layers of the development stack.  To ensure the
application works correctly from the perspective of the end-user, full-stack
integration testing drives your application and verifies correct functionality
from the user interface level.  This is also referred to as acceptance testing.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_introduction_2"/>Introduction</h4></div></div></div><p>Writing a full-stack integration test for a Javascript-driven web application
will always involve some kind of browser, and although writing an application
with Backbone can make a world of difference to you, the tools involved are all
the same as far as your browser is concerned. Because your browser can run
Backbone applications just like any Javascript application, you can write
integration tests for them just like you would for any Javascript application.
Also, because of tools like Capybara that support various drivers, you can
generally test a Javascript-based application just like you’d test a web
application where all the logic lives on the server. This means that having a
powerful, rich-client user interface won’t make your application any harder to
test. If you’re familiar with tools like Capybara, Cucumber, and RSpec, you can
dive right in and start testing your Backbone application. If not, the
following sections should give you a taste of the available tools for
full-stack integration tests written in Ruby.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_capybara"/>Capybara</h4></div></div></div><p>Though there is a host of tools available to you for writing automated
integration tests, we recommend <a class="ulink" href="https://github.com/jnicklas/capybara" target="_top">capybara</a>.
In a hybrid Rails application, where some portions are regular request/response
and other portions are JavaScript, it’s valuable to have a testing framework
that abstracts the difference as much as possible.</p><p>Capybara is a high-level library that allows you to write tests from a user’s
perspective.  Consider this example, which uses RSpec:</p><pre class="programlisting">describe <b class="hl-string"><i style="color:red">"the login process"</i></b>, :type =&gt; :request <b class="hl-keyword">do</b>
  it <b class="hl-string"><i style="color:red">"accepts an email and password"</i></b> <b class="hl-keyword">do</b>
    User.create(:email =&gt; <b class="hl-string"><i style="color:red">'alice@example.com'</i></b>, :password =&gt; <b class="hl-string"><i style="color:red">'password'</i></b>)
    visit <b class="hl-string"><i style="color:red">'/'</i></b>
    fill_in <b class="hl-string"><i style="color:red">'Email'</i></b>, :with =&gt; <b class="hl-string"><i style="color:red">'alice@example.com'</i></b>
    fill_in <b class="hl-string"><i style="color:red">'Password'</i></b>, :with =&gt; <b class="hl-string"><i style="color:red">'password'</i></b>
    click_button <b class="hl-string"><i style="color:red">'Log in'</i></b>
    page.should have_content(<b class="hl-string"><i style="color:red">'You are logged in as alice@example.com'</i></b>)
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre><p>Notice that, as you read the spec, you’re not concerned about whether the login
interface is rendered with JavaScript, or whether the authentication request is
over AJAX or not.  A high-level library like Capybara keeps you from having to
consider the back-end implementation, freeing you to focus on describing the
application’s behavior from an end-user’s perspective.  This perspective of
writing specs is often called behavior-driven development (BDD).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_cucumber"/>Cucumber</h4></div></div></div><p>You can take another step toward natural language tests, using Cucumber to
define mappings.  Cucumber is a test runner and a mapping layer.  The specs you
write in Cucumber are user stories, written in a constrained subset of English.
The individual steps in these stories are mapped to a testing library.  In our
case, and probably most cases, to Capybara.</p><p>This additional layer of abstraction can be helpful for a few reasons.</p><p>Some teams have nontechnical stakeholders writing integration specs as user
stories.  Cucumber sits at a level of abstraction that fits comfortably there:
high level enough for nontechnical stakeholders to write in, but precise enough
to be translated into automated tests.</p><p>On other teams, the person writing the story is the same person who implements
it.  Still, it is valuable to use a tool that reinforces the distinction between
the description phase and the implementation phase of the test.  In the
description phase, you are writing an English description of the software
interaction:</p><pre class="programlisting">Given there is a user account "alice@example.com" with the password "password"
When I go to the home page
And I fill in the login form with "alice@example.com" and "password"
And I click the login button
Then I should see "You are logged in as alice@example.com"</pre><p>In the implementation phase of the test, you define what these steps do.  In
this case, they are defined to run Capybara methods:</p><pre class="programlisting">Given /^there is a user account <b class="hl-string"><i style="color:red">"(.*)"</i></b> with the password <b class="hl-string"><i style="color:red">"(.*)"</i></b>$/ <b class="hl-keyword">do</b> |email, password|
  User.create(:email =&gt; email, :password =&gt; password)
<b class="hl-keyword">end</b>

When <b class="hl-string"><i style="color:red">"I go to the home page"</i></b> <b class="hl-keyword">do</b>
  visit <b class="hl-string"><i style="color:red">"/"</i></b>
<b class="hl-keyword">end</b>

When /^I fill <b class="hl-keyword">in</b> the login form with <b class="hl-string"><i style="color:red">"(.*)"</i></b> <b class="hl-keyword">and</b> <b class="hl-string"><i style="color:red">"(.*)"</i></b>$/ <b class="hl-keyword">do</b> |email, password|
  fill_in <b class="hl-string"><i style="color:red">'Email'</i></b>, :with =&gt; email
  fill_in <b class="hl-string"><i style="color:red">'Password'</i></b>, :with =&gt; password
<b class="hl-keyword">end</b>

When <b class="hl-string"><i style="color:red">"I click the login button"</i></b> <b class="hl-keyword">do</b>
  click_button <b class="hl-string"><i style="color:red">"Login"</i></b>
<b class="hl-keyword">end</b>

Then /^I should see <b class="hl-string"><i style="color:red">"(.*)"</i></b>$/ <b class="hl-keyword">do</b> |text|
  page.should have_content(text)
<b class="hl-keyword">end</b></pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_drivers"/>Drivers</h4></div></div></div><p>Capybara supports multiple drivers through a common API, each with benefits and
drawbacks. We prefer to use either
<a class="ulink" href="https://github.com/thoughtbot/capybara-webkit" target="_top">capybara-webkit</a> or Selenium.</p><p>When possible, we use capybara-webkit. It’s a fast, headless fake browser
written using the WebKit browser engine. It’s generally faster than Selenium
and it’s dependent on your system settings once compiled. This means that
upgrading the browser you use every day won’t ever affect your tests.</p><p>However, capybara-webkit is still young, and sometimes there’s no substitute
for having a real browser to run your tests through. In these situations, we
fall back to using Selenium. Selenium will always support anything you can do
in your actual browser, and supports multiple browsers, including Firefox,
Chrome, Safari, and even Internet Explorer.</p><p>Capybara makes it easy to switch between drivers. Just set your default driver to capybara-webkit:</p><pre class="programlisting">Capybara.javascript_driver = :webkit</pre><p>And then tag a Cucumber scenario as @javascript. If you need to fall back to using Selenium, tag that scenario with @selenium.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_isolated_unit_testing"/>Isolated unit testing</h3></div></div></div><p>Integration testing your application is great for ensuring that the product
functions as intended, and works to mitigate against risk of regressions.
There are additional benefits, though, to writing tests for individual units
of your application in isolation, such as focused failures and decoupled code.</p><p>When an integration test fails, it can be difficult to pin down the exact reason
why; particularly when a regression is introduced in a part of the application
seemingly far away from where you’re working.  With the finer granularity of a
unit test suite, failures are more targeted and help you get to the root of the
problem more quickly.</p><p>Another benefit comes from unit testing when you test-drive code; when you write
the tests before the implementation.  Since you are starting with a piece of
code which is client to your implementation modules, setup and dependency
concerns are brought to your attention at the beginning of implementation,
rather than much later during development when modules are integrated. Thinking
about these concerns earlier helps you design modules which are more loosely
coupled, have smaller interfaces, and are easier to set up.  If code is hard to
test, it will be hard to use.  Writing the test first, you have a clear and
concrete opportunity to make your implementation easier to use.</p><p>Finally, there are some behaviors that are difficult or impossible to test
using a full-stack integration test. Here’s a common example: you want to
display a spinner graphic or disable a UI element while waiting for the server
to respond to a request. You can’t test this with an integration test because
the time the server takes to respond is variable; by the time your test checks
to look for the spinner graphic, the response will probably be finished. Even if
it passes once, it may fail on the next run, or on the run after that. And if
you decide to do an almost-full-stack test and fake out a slow response on the
server, this will slow down your tests and introduce unnecessary indirection
to an otherwise simple component. During isolation tests, it’s easy to use
techniques like dependency injection, stubbing, and mocking to test erratic
behaviors and side effects that are difficult to observe during integration
tests.</p><p>If you’d like to read more on test-driven development, check out Kent Beck’s
<span class="emphasis"><em>Test Driven Development: By Example</em></span> and Gerard Meszaros' <span class="emphasis"><em>xUnit Test Patterns:
Refactoring Test Code</em></span>.</p><p>As there is plentiful content available for testing tools and strategies in
Rails, we’ll focus on isolation testing your Backbone code.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_isolation_testing_in_javascript"/>Isolation testing in JavaScript</h4></div></div></div><p>There are many JavaScript testing frameworks available.  Some run in-browser and
provide facility for setting up DOM fixtures.  Others are designed for
standalone JavaScript code and can run on browserless JavaScript runtimes.</p><p>We’ll use the Jasmine framework for writing our isolation specs.  It integrates
easily into a Rails application, and provides an RSpec-like syntax for writing
specs:</p><pre class="programlisting">describe(<b class="hl-string"><i style="color:red">"ExampleApp.Models.Tasks"</i></b>, <b class="hl-keyword">function</b>() {
  it(<b class="hl-string"><i style="color:red">"knows if it is complete"</i></b>, <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> completeTask = <b class="hl-keyword">new</b> ExampleApp.Models.Task({ complete: true });
    expect(completeTask.isComplete()).toBe(true);
  });

  it(<b class="hl-string"><i style="color:red">"knows if it is not complete"</i></b>, <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> incompleteTask = <b class="hl-keyword">new</b> ExampleApp.Models.Task({ complete: false });
    expect(incompleteTask.isComplete()).toBe(false);
  });
});</pre><p>To ease the use of Jasmine and the Rails 3.1 asset pipeline, we use
<a class="ulink" href="https://github.com/bradphelan/jasminerice" target="_top">Jasminerice</a>.  To run the
Jasmine tests in the example application, simply start up the development
server and visit <a class="ulink" href="http://localhost:3000/jasmine" target="_top">http://localhost:3000/jasmine</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_what_to_test"/>What to test?</h4></div></div></div><p>We frequently found it difficult to test Javascript components in isolation
before we started using Backbone. Although jQuery really takes the pain out of
working with the DOM and communicating with the server, it’s not
object-oriented and provides nothing to help split up your application.
Because most of our HTML was in ERB-based templates, it was generally
difficult to test the Javascript that relied on that HTML without also loading
the web application. This meant that almost all of our early Javascript tests
were full-stack integration tests.</p><p>Using Backbone, it’s much easier to test components in isolation. View code is
restricted to views, and templates contain only HTML or interpolation code
that can be interpreted by the Javascript view layer, such as jst or mustache
templates. Models and collections can be given data in their constructor, and
simple dependency injection allows unit tests to fake out the remote server.
We don’t test routers in isolation as often because they’re very light on
logic, but those are also easy to test by calling action methods directly or
triggering events.</p><p>Since Backbone components are just as easy to test in isolation as they are to
test full-stack, we generally use the same guidelines as we do for all Rails
applications to decide what to test where.</p><p>Start with a top-down, full-stack Cucumber or RSpec scenario to describe the
feature you’re writing from a high level perspective, and begin implementing
behavior from the top as necessary. If you find that the feedback loop between
a test failure and the code to pass it starts to feel too long, start writing
isolated unit tests for the individual components you need to write to get
closer to passing a higher-level assertion. As an example, an assertion from
Capybara that fails because of a missing selector may need new models,
controllers, views, and routes both on the server and in Backbone. Rather than
writing several new componenets without seeing the failure message change,
write a unit test for each piece as you progress down. If it’s clear what
component you need to add from the integration test failure, add that
component without writing an isolated unit test. For example, a failure from a
missing route or view file reveals an obvious next step, but missing text on a
page because a model method doesn’t actually do anything may motivate a unit
test.</p><p>Many features will have edge cases or several logical branches. Anything that
can’t be described from a high-level, business value perspective should be
tested from an isolated unit test. For example, when testing a form, it makes
sense to write a scenario for the success path, where a user enters valid
data that gets accepted and rendered by the application, and one extra
scenario for the failure path, where a user enters invalid data that the
system can’t accept. However, when adding future validations or other reasons
that a user’s data can’t be accepted, it makes sense to just write an extra
isolated unit test, rather than adding a new scenario that largely duplicates
the original failure scenario.</p><p>When writing isolation tests, the developer needs to decide exactly how much
isolation to enforce. For example, when writing a unit test for a model,
you’ll likely decide not to involve an actual web server to provide data.
However, when testing a view that composes other subviews, you’ll likely allow
the actual subview code to run. There are many cases when it will make
sense to just write a unit test that involves a few components working
together, rather than writing a full-stack scenario.</p><p>The overall goals when deciding how much to test via integration vs isolation
are to keep high-level business logic described in top-down tests, to keep
details and edge cases described in unit tests, and to write tests that
exercise the fewest number of components possible while remaining robust and
descriptive without becoming brittle.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_helpful_tools"/>Helpful Tools</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li>
Spy/stub/mock, even your HTTP, with <a class="ulink" href="http://sinonjs.org/" target="_top">sinon.js</a>.
</li><li>
If you’re looking for factory_girl.js, it’s called <a class="ulink" href="https://github.com/bkeepers/rosie" target="_top">Rosie</a>.
</li><li>
Use the Rails 3.1 asset pipeline with <a class="ulink" href="https://github.com/bradphelan/jasminerice" target="_top">jasminerice</a>.
</li><li>
See other examples on James Newbery’s blog: <a class="ulink" href="http://tinnedfruit.com/2011/03/03/testing-backbone-apps-with-jasmine-sinon.html" target="_top">testing Backbone with Jasmine</a> and check out his <a class="ulink" href="https://github.com/froots/backbone-jasmine-examples" target="_top">examples on GitHub</a>.
</li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_example_test_driving_a_task_application"/>Example: Test-driving a Task application</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_setup"/>Setup</h4></div></div></div><p>In this example, we’ll be using Cucumber, Capybara, RSpec, and Jasmine to
test-drive a todo list.</p><p>The Selenium driver comes configured with Capybara and is the quickest driver to
get running. By default it runs your tests in a remote controlled Firefox
session, so you’ll want to install Firefox if you don’t have it already.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If you’d like to test on a WebKit-based browser, you can set up the
<a class="ulink" href="http://code.google.com/p/selenium/wiki/ChromeDriver" target="_top">Selenium ChromeDriver</a> to
run integration tests against Chrome.</p></div><p>The other dependencies you can install by adding them to your Gemfile. The gems
you’ll need for testing are jasminerice, jasmine, cucumber-rails, rspec-rails,
and capybara. You’ll want to add RSpec, Cucumber, and Jasmine to both the test
and development groups so that you can run generators. With all our testing
dependencies in place, the Gemfile in our sample application looks like this:</p><pre class="programlisting">source <b class="hl-string"><i style="color:red">'http://rubygems.org'</i></b>

gem <b class="hl-string"><i style="color:red">'rails'</i></b>, <b class="hl-string"><i style="color:red">'3.1.0'</i></b>
gem <b class="hl-string"><i style="color:red">'sqlite3'</i></b>

gem <b class="hl-string"><i style="color:red">'rails-backbone'</i></b>, <b class="hl-string"><i style="color:red">'~&gt; 0.7.0'</i></b>
gem <b class="hl-string"><i style="color:red">'jquery-rails'</i></b>
gem <b class="hl-string"><i style="color:red">'ejs'</i></b>
gem <b class="hl-string"><i style="color:red">"flutie"</i></b>, <b class="hl-string"><i style="color:red">"~&gt; 1.3.2"</i></b>
gem <b class="hl-string"><i style="color:red">"clearance"</i></b>, <b class="hl-string"><i style="color:red">"~&gt; 0.13.0"</i></b>
gem <b class="hl-string"><i style="color:red">'paperclip'</i></b>
gem <b class="hl-string"><i style="color:red">'rabl'</i></b>
gem <b class="hl-string"><i style="color:red">'backbone-support'</i></b>

group :assets <b class="hl-keyword">do</b>
  gem <b class="hl-string"><i style="color:red">'sass-rails'</i></b>, <b class="hl-string"><i style="color:red">"  ~&gt; 3.1.0"</i></b>
  gem <b class="hl-string"><i style="color:red">'coffee-rails'</i></b>, <b class="hl-string"><i style="color:red">"~&gt; 3.1.0"</i></b>
  gem <b class="hl-string"><i style="color:red">'uglifier'</i></b>
<b class="hl-keyword">end</b>

group :development, :test <b class="hl-keyword">do</b>
  gem <b class="hl-string"><i style="color:red">"rspec-rails"</i></b>, <b class="hl-string"><i style="color:red">"~&gt; 2.6.1"</i></b>
  gem <b class="hl-string"><i style="color:red">"ruby-debug19"</i></b>
  gem <b class="hl-string"><i style="color:red">'jasmine'</i></b>, <b class="hl-string"><i style="color:red">"= 1.1.0.rc4"</i></b>
  gem <b class="hl-string"><i style="color:red">'jasminerice'</i></b>
  gem <b class="hl-string"><i style="color:red">'cucumber-rails'</i></b>, <b class="hl-string"><i style="color:red">"~&gt; 1.0.2"</i></b>, :require =&gt; <b class="hl-keyword">false</b>
<b class="hl-keyword">end</b>

group :test <b class="hl-keyword">do</b>
  gem <b class="hl-string"><i style="color:red">'turn'</i></b>, :require =&gt; <b class="hl-keyword">false</b>
  gem <b class="hl-string"><i style="color:red">"capybara"</i></b>, <b class="hl-string"><i style="color:red">"~&gt; 1.1.1"</i></b>
  gem <b class="hl-string"><i style="color:red">'selenium-webdriver'</i></b>, <b class="hl-string"><i style="color:red">'~&gt; 2.18.0'</i></b>
  gem <b class="hl-string"><i style="color:red">"factory_girl_rails"</i></b>
  gem <b class="hl-string"><i style="color:red">"bourne"</i></b>
  gem <b class="hl-string"><i style="color:red">"database_cleaner"</i></b>
  gem <b class="hl-string"><i style="color:red">"nokogiri"</i></b>
  gem <b class="hl-string"><i style="color:red">"shoulda"</i></b>
  gem <b class="hl-string"><i style="color:red">"launchy"</i></b>
  gem <b class="hl-string"><i style="color:red">"guard-spork"</i></b>
  gem <b class="hl-string"><i style="color:red">"spork"</i></b>, <b class="hl-string"><i style="color:red">"~&gt; 0.9.0.rc"</i></b>
<b class="hl-keyword">end</b></pre><p>If you haven’t already, bootstrap your application for Cucumber and Capybara:</p><pre class="programlisting">rails generate cucumber:install</pre><p>Next, bootstrap the application for Jasmine:</p><pre class="programlisting">rails generate jasmine:install</pre><p>You’ll want to set up Jasminerice to load all your helpers and specs:</p><pre class="programlisting">include::../../example_app/</pre><p>Finally, you need to mount the Jasminerice engine so that you can run your
Jasmine specs. Add the following routes to config/routes.rb:</p><pre class="programlisting"><b class="hl-keyword">if</b> [<b class="hl-string"><i style="color:red">"development"</i></b>, <b class="hl-string"><i style="color:red">"test"</i></b>].include? Rails.env
  mount Jasminerice::Engine =&gt; <b class="hl-string"><i style="color:red">"/jasmine"</i></b>
<b class="hl-keyword">end</b></pre><p>With this configuration, you can run cucumber scenarios with the cucumber
command and you can run Jasmine tests by running the development server with
<code class="literal">bundle exec rails server</code> and accessing <a class="ulink" href="http://localhost:3000/jasmine" target="_top">http://localhost:3000/jasmine</a> in your
browser.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_step_by_step"/>Step by step</h4></div></div></div><p>We’ll go outside in: cucumber first, then rspec or jasmine as needed.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>For an in-depth explanation of outside-in test-driven development, see
<a class="ulink" href="http://pragprog.com/book/achbd/the-rspec-book" target="_top">The RSpec Book</a>.</p></div><p>We’d like to be able to add items to a Todo list.  We know this will involve
two parts: a list of existing tasks, and an interface for adding new items to
the list.  We’ll start with the list of items, and create fixture data with
<a class="ulink" href="https://github.com/thoughtbot/factory_girl/blob/v2.1.0/GETTING_STARTED.md" target="_top">Factory Girl Cucumber steps</a>:</p><pre class="programlisting">Feature: Viewing Tasks
  As a user
  So that I can see what I have to do
  I want to be able to see all my tasks

  Background:
    Given I am signed up as "email@example.com"
    When I sign in as "email@example.com"

  @javascript
  Scenario: View tasks
    Given the following tasks exist:
      | Title                                | user                     |
      | Purchase the backbone on rails ebook | email: email@example.com |
      | Master backbone                      | email: email@example.com |
    And I am on the home page
    Then I should see "Master backbone" within the tasks list
    And I should see "Purchase the backbone on rails ebook" within the tasks list</pre><p>Running this, we see a failure:</p><pre class="programlisting">Then I should see "Master backbone" within the tasks list # features/step_definitions/web_steps.rb:35
  Unable to find css "#tasks table" (Capybara::ElementNotFound)
  (eval):2:in `find'
  ./features/step_definitions/web_steps.rb:29:in `with_scope'
  ./features/step_definitions/web_steps.rb:36:in `/^(.*) within (.*[^:])$/'
  features/view_tasks.feature:13:in `Then I should see "Master backbone" within the tasks list'</pre><p>A common gotcha when testing Backbone.js Rails apps is seeing false
positives in bootstrapped data. Consider that, if we had just written the step
<code class="literal">Then I should see "Master backbone"</code> instead of scoping it with <code class="literal">within the
tasks list</code>, then some test drivers would count the JSON that is used to
bootstrap Backbone collections as visible text on the page, and the test would
pass without us actually rendering the text to the page.</p><p>Since this we are doing outside-in development and testing for user interface,
we will need outline the UI first.  To do this, first we’ll need a page to host
our code.  Let’s create and route a Rails <code class="literal">TasksController</code>. We’ll bootstrap the
Backbone app on <code class="literal">tasks#index</code>.</p><pre class="programlisting">ExampleApp::Application.routes.draw <b class="hl-keyword">do</b>
  resources :tasks <b class="hl-keyword">do</b>
    resources :attachments, :only =&gt; [:create, :show]
  <b class="hl-keyword">end</b>

  root :to =&gt; <b class="hl-string"><i style="color:red">'tasks#index'</i></b>

  <b class="hl-keyword">if</b> [<b class="hl-string"><i style="color:red">"development"</i></b>, <b class="hl-string"><i style="color:red">"test"</i></b>].include? Rails.env
    mount Jasminerice::Engine =&gt; <b class="hl-string"><i style="color:red">"/jasmine"</i></b>
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>You can also see the route for the
<a class="ulink" href="http://rubygems.org/gems/jasminerice" target="_top">jasminerice gem</a>, which makes the Rails
3.1 asset pipeline (and all of our app assets) available to the Jasmine specs.</p></div><pre class="programlisting"><b class="hl-keyword">class</b> TasksController &lt; ApplicationController
  before_filter :authorize
  respond_to :html, :json

  <b class="hl-keyword">def</b> index
    respond_with(@tasks = current_user.tasks)
  <b class="hl-keyword">end</b>

  <b class="hl-keyword">def</b> show
    @task = current_user.tasks.find(params[:id])
  <b class="hl-keyword">end</b>

  <b class="hl-keyword">def</b> create
    respond_with(current_user.tasks.create(params[:task]))
  <b class="hl-keyword">end</b>

  <b class="hl-keyword">def</b> update
    task = current_user.tasks.find(params[:id])
    task.update_attributes(params[:task])
    respond_with(task)
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre><p>To render our tasks, we’ll want a TasksIndex Backbone view class.  But before we
write this class, we’ll motivate it with a Jasmine isolation spec:</p><pre class="programlisting">describe(<b class="hl-string"><i style="color:red">"ExampleApp.Views.TasksIndex"</i></b>, <b class="hl-keyword">function</b>() {
  it(<b class="hl-string"><i style="color:red">"renders a task table"</i></b>, <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> view = <b class="hl-keyword">new</b> ExampleApp.Views.TasksIndex();
    view.render();

    expect(view.$el).toBe(<b class="hl-string"><i style="color:red">"#tasks"</i></b>);
    expect(view.$el).toContain(<b class="hl-string"><i style="color:red">"table"</i></b>);
  });
});</pre><p>We use the <a class="ulink" href="https://github.com/velesin/jasmine-jquery" target="_top">jasmine-jquery</a> library
(provided by jasminerice) to provide DOM matchers for Jasmine like
<code class="literal">toContain()</code>.</p><p>To run the Jasmine spec, run the Rails server and visit <a class="ulink" href="http://localhost:3000/jasmine" target="_top">http://localhost:3000/jasmine</a></p><p>To make this test pass, we’ll add a small template and make the <code class="literal">TasksIndex</code>
view render it:</p><pre class="programlisting">ExampleApp.Views.TasksIndex = Backbone.View.extend({
  tagName: <b class="hl-string"><i style="color:red">'div'</i></b>,
  id: <b class="hl-string"><i style="color:red">'tasks'</i></b>,

  initialize: function() {
  },

  render: function () {
    this.$el.html(JST[<b class="hl-string"><i style="color:red">'tasks/index'</i></b>]({}));
    <b class="hl-keyword">return</b> this;
  }
});</pre><p>The <code class="literal">app/assets/templates/tasks/index.jst.ejs</code> template:</p><pre class="programlisting">&lt;table&gt;&lt;/table&gt;</pre><p>Now our Jasmine specs pass:</p><div class="figure"><a id="d0e3839"/><p class="title"><b>Figure 5. Passing Jasmine spec</b></p><div class="figure-contents"><div class="mediaobject"><img src="testing/jasmine-passing.png" alt="testing/jasmine-passing.png"/></div></div></div><br class="figure-break"/><p>Since the Jasmine specs pass, we’ll pop back up a level and run the Cucumber
story.  Running it again, the failure is slightly different.  The <code class="literal">"#tasks
table"</code> element is present on the page, but doesn’t contain the content we want.</p><pre class="programlisting">@javascript
Scenario: View tasks                                          # features/view_tasks.feature:7
  Given the following tasks exist:                            # factory_girl-2.1.0/lib/factory_girl/step_definitions.rb:99
    | Title                                |
    | Purchase the backbone on rails ebook |
    | Master backbone                      |
  And I am on the home page                                   # features/step_definitions/web_steps.rb:44
  Then I should see "Master backbone" within the tasks list   # features/step_definitions/web_steps.rb:35
    expected there to be content "Master backbone" in "Title Completed" (RSpec::Expectations::ExpectationNotMetError)
    ./features/step_definitions/web_steps.rb:107:in `/^(?:|I )should see "([^"]*)"$/'
    features/view_tasks.feature:13:in `Then I should see "Master backbone" within the tasks list'</pre><p>Drop back down to Jasmine and write a spec motivating the TasksIndex view to
accept a collection and render it.  We’ll rewrite our existing spec, since we
are changing the TasksIndex interface to require that a collection be passed in:</p><pre class="programlisting"><i class="hl-comment" style="color: silver">//= require application</i>

describe(<b class="hl-string"><i style="color:red">"ExampleApp.Views.TasksIndex"</i></b>, <b class="hl-keyword">function</b>() {
  it(<b class="hl-string"><i style="color:red">"renders a collection of tasks"</i></b>, <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> tasksCollection = <b class="hl-keyword">new</b> ExampleApp.Collections.Tasks();
    tasksCollection.reset([
      { title: <b class="hl-string"><i style="color:red">"Wake up"</i></b> },
      { title: <b class="hl-string"><i style="color:red">"Brush your teeth"</i></b> }
    ]);

    <b class="hl-keyword">var</b> view = <b class="hl-keyword">new</b> ExampleApp.Views.TasksIndex({collection: tasksCollection});
    <b class="hl-keyword">var</b> $el = $(view.render().el);

    expect($el).toHaveText(/Wake up/);
    expect($el).toHaveText(/Brush your teeth/);
  });
});</pre><p>This spec fails:</p><pre class="programlisting">1 spec, 1 failure in 0.008sFinished at Thu Sep 22 2011 18:10:26 GMT-0400 (EDT)
ExampleApp.Views.TasksIndex
renders a collection of tasks
TypeError: undefined is not a function
TypeError: undefined is not a function
    at [object Object].&lt;anonymous&gt; (http://localhost:3000/assets/views/tasks_index_spec.js?body=1:4:27)</pre><p>It’s failing because we haven’t defined <code class="literal">ExampleApp.Collections.Tasks</code> yet.  We
need to define a Task model and Tasks collection.  We’ll define the model:</p><pre class="programlisting">ExampleApp.Models.Task = Backbone.Model.extend({
  initialize: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.on(<b class="hl-string"><i style="color:red">"change:attachments"</i></b>, <b class="hl-keyword">this</b>.parseAttachments);
    <b class="hl-keyword">this</b>.parseAttachments();
  },

  parseAttachments: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.attachments = <b class="hl-keyword">new</b> ExampleApp.Collections.Attachments(<b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'attachments'</i></b>));
  },

  schema: {
    title: { type: <b class="hl-string"><i style="color:red">"Text"</i></b> }
  },

  urlRoot: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  isComplete: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'complete'</i></b>);
  }
});</pre><p>write a test to motivate the collection:</p><pre class="programlisting">describe(<b class="hl-string"><i style="color:red">"ExampleApp.Collections.Tasks"</i></b>, <b class="hl-keyword">function</b>() {
  it(<b class="hl-string"><i style="color:red">"contains instances of ExampleApp.Models.Task"</i></b>, <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> collection = <b class="hl-keyword">new</b> ExampleApp.Collections.Tasks();
    expect(collection.model).toEqual(ExampleApp.Models.Task);
  });

  it(<b class="hl-string"><i style="color:red">"is persisted at /tasks"</i></b>, <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> collection = <b class="hl-keyword">new</b> ExampleApp.Collections.Tasks();
    expect(collection.url).toEqual(<b class="hl-string"><i style="color:red">"/tasks"</i></b>);
  });
});</pre><p>and pass the test by implementing the collection:</p><pre class="programlisting">ExampleApp.Collections.Tasks = Backbone.Collection.extend({
  model: ExampleApp.Models.Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>
});</pre><p>Running the Jasmine specs again, we’re making progress.  The TasksIndex view is
accepting a collection of tasks, and now we have to render it:</p><pre class="programlisting">Expected '&lt;div id="tasks"&gt;&lt;table&gt; &lt;tbody&gt;&lt;tr&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;Completed&lt;/th&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/table&gt; &lt;/div&gt;' to have text 'Wake up'.</pre><p>The simplest thing we can do to get the spec passing is to pass the <code class="literal">tasks</code>
collection into the template, and iterate over it there:</p><pre class="programlisting"><i class="hl-comment" style="color: silver">// app/assets/javascripts/views/tasks_index.js:</i>
ExampleApp.Views.TasksIndex = Support.CompositeView.extend({
  initialize: <b class="hl-keyword">function</b>() {
    _.bindAll(<b class="hl-keyword">this</b>, <b class="hl-string"><i style="color:red">"render"</i></b>);
    <b class="hl-keyword">this</b>.collection.on(<b class="hl-string"><i style="color:red">"add"</i></b>, <b class="hl-keyword">this</b>.render);
  },

  render: <b class="hl-keyword">function</b> () {
    <b class="hl-keyword">this</b>.renderTemplate();
    <b class="hl-keyword">this</b>.renderTasks();
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>;
  },

  renderTemplate: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.$el.html(JST[<b class="hl-string"><i style="color:red">'tasks/index'</i></b>]({ tasks: <b class="hl-keyword">this</b>.collection }));
  },

  renderTasks: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> self = <b class="hl-keyword">this</b>;
    <b class="hl-keyword">this</b>.collection.each(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">var</b> row = <b class="hl-keyword">new</b> ExampleApp.Views.TaskItem({ model: task });
      self.renderChild(row);
      self.$(<b class="hl-string"><i style="color:red">'tbody'</i></b>).append(row.el);
    });
  }
});</pre><pre class="programlisting">// app/assets/javascripts/templates/tasks/index.jst.ejs:
&lt;table id="tasks-list"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Title&lt;/th&gt;
      &lt;th&gt;Completed&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;a class="create" href="#new"&gt;Add task&lt;/a&gt;</pre><p>Now, Jasmine passes, but the Cucumber story is still failing.</p><pre class="programlisting">Then I should see "Master backbone" within the tasks list # features/step_definitions/web_steps.rb:35
Unable to find css "#tasks table" (Capybara::ElementNotFound)</pre><p>This is because the Jasmine spec is an isolation spec, and verifies that the
TasksIndex view works in isolation.  There is additional code we need to write
to hook up the data in the Rails test database to the Backbone view.  Adding
this code to bootstrap the Backbone application should wrap up our exercise and
get the tests passing.</p><p>We’ll motivate writing a top-level Backbone application object with a spec.
Note the use of a <code class="literal">sinon.spy</code> for verifying the router instantiation:</p><p>spec/javascripts/example_app_spec.js</p><pre class="programlisting">describe(<b class="hl-string"><i style="color:red">"ExampleApp"</i></b>, <b class="hl-keyword">function</b>(){
  it(<b class="hl-string"><i style="color:red">"has a namespace for Models"</i></b>, <b class="hl-keyword">function</b>() {
    expect(ExampleApp.Models).toBeTruthy();
  });

  it(<b class="hl-string"><i style="color:red">"has a namespace for Collections"</i></b>, <b class="hl-keyword">function</b>() {
    expect(ExampleApp.Collections).toBeTruthy();
  });

  it(<b class="hl-string"><i style="color:red">"has a namespace for Views"</i></b>, <b class="hl-keyword">function</b>() {
    expect(ExampleApp.Views).toBeTruthy();
  });

  it(<b class="hl-string"><i style="color:red">"has a namespace for Routers"</i></b>, <b class="hl-keyword">function</b>() {
    expect(ExampleApp.Routers).toBeTruthy();
  });

  describe(<b class="hl-string"><i style="color:red">"init()"</i></b>, <b class="hl-keyword">function</b>() {
    it(<b class="hl-string"><i style="color:red">"accepts task JSON and instantiates a collection from it"</i></b>, <b class="hl-keyword">function</b>() {
      <b class="hl-keyword">var</b> tasksJSON = {<b class="hl-string"><i style="color:red">"tasks"</i></b>: [{<b class="hl-string"><i style="color:red">"title"</i></b>:<b class="hl-string"><i style="color:red">"thing to do"</i></b>}, {<b class="hl-string"><i style="color:red">"title"</i></b>:<b class="hl-string"><i style="color:red">"another thing"</i></b>}]};
      ExampleApp.init(tasksJSON);

      expect(ExampleApp.tasks).not.toEqual(<b class="hl-keyword">undefined</b>);
      expect(ExampleApp.tasks.length).toEqual(<span class="hl-number">2</span>);
      expect(ExampleApp.tasks.models[<span class="hl-number">0</span>].get(<b class="hl-string"><i style="color:red">'title'</i></b>)).toEqual(<b class="hl-string"><i style="color:red">"thing to do"</i></b>);
      expect(ExampleApp.tasks.models[<span class="hl-number">1</span>].get(<b class="hl-string"><i style="color:red">'title'</i></b>)).toEqual(<b class="hl-string"><i style="color:red">"another thing"</i></b>);
    });

    it(<b class="hl-string"><i style="color:red">"instantiates a Tasks router"</i></b>, <b class="hl-keyword">function</b>() {
      ExampleApp.Routers.Tasks = sinon.spy();
      ExampleApp.init({});
      expect(ExampleApp.Routers.Tasks).toHaveBeenCalled();
    });

    it(<b class="hl-string"><i style="color:red">"starts Backbone.history"</i></b>, <b class="hl-keyword">function</b>() {
      Backbone.history = { start: sinon.spy() };
      ExampleApp.init({});
      expect(Backbone.history.start).toHaveBeenCalled();
    });
  });
});</pre><p>Get it to green:</p><pre class="programlisting">window.ExampleApp = {
  Models: {},
  Collections: {},
  Views: {},
  Routers: {},
  init: <b class="hl-keyword">function</b>(data) {
    <b class="hl-keyword">this</b>.tasks = <b class="hl-keyword">new</b> ExampleApp.Collections.Tasks(data.tasks);

    <b class="hl-keyword">new</b> ExampleApp.Routers.Tasks({ collection: <b class="hl-keyword">this</b>.tasks });
    <b class="hl-keyword">if</b> (!Backbone.history.started) {
      Backbone.history.start();
      Backbone.history.started = true;
    }
  }
};</pre><p>Then we bootstrap the app from the Rails view:</p><pre class="programlisting">&lt;h1&gt;Tasks&lt;/h1&gt;

&lt;div id="tasks"&gt;
&lt;/div&gt;

&lt;script type="text/json" id="bootstrap"&gt;
  { "tasks": &lt;%= @tasks.to_json %&gt; }
&lt;/script&gt;

&lt;%= content_for :javascript do -%&gt;
  &lt;script type="text/javascript"&gt;
    $(function () {
      var div = $('&lt;div&gt;&lt;/div&gt;');
      div.html($('#bootstrap').text());
      var data = JSON.parse(div.text());

      ExampleApp.init(data);
    });
  &lt;/script&gt;
&lt;% end %&gt;</pre><p>And the integration test passes!</p><pre class="programlisting">Feature: Viewing Tasks
  As a user
  So that I can see what I have to do
  I want to be able to see all my tasks

  @javascript
  Scenario: View tasks
    Given the following tasks exist:
      | Title                                |
      | Purchase the backbone on rails ebook |
      | Master backbone                      |
    And I am on the home page
    Then I should see "Master backbone" within the tasks list
    And I should see "Purchase the backbone on rails ebook" within the tasks list

1 scenario (1 passed)
5 steps (5 passed)</pre></div></div></div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s06.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s08.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Models and collections </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Security</td></tr></table></div></body></html>