<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="master.css" type="text/css" />
    <title>Views and Templates</title>
  </head>

  <body>
    <div class="nav" id="navheader">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="rails_integration.html">Prev</a><br/>
         Rails Integration
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         <strong>Backbone.js on Rails</strong>
        
      </td><td width="33%" align="right">
        
          <a href="models_and_collections.html">Next</a><br/>
          Models and collections
        
      </td></tr>
    </table>
    </div>

    <hr/>

    <div class="content">
      <div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a id="_views_and_templates"></a>Views and Templates</h2></div></div></div>
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title">
<a id="_view_explanation_chapter_unstarted"></a>View explanation (chapter unstarted)</h3></div></div></div></div>
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title">
<a id="_templating_strategy_chapter_unstarted"></a>Templating strategy (chapter unstarted)</h3></div></div></div></div>
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title">
<a id="_view_helpers_chapter_unstarted"></a>View helpers (chapter unstarted)</h3></div></div></div></div>
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title">
<a id="_form_helpers_chapter_unstarted"></a>Form helpers (chapter unstarted)</h3></div></div></div></div>
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title">
<a id="_event_binding_chapter_unstarted"></a>Event binding (chapter unstarted)</h3></div></div></div></div>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_cleaning_up_understanding_binding_and_unbinding"></a>Cleaning up: understanding binding and unbinding</h3></div></div></div>
<p>Imagine you’re writing a todo app. Consider two views: an index view which
contains all the tasks, and a detail view that shows detail on one task. The
interface switches between the two views, and both views can modify existing
tasks (say, to indicate that the task is complete or incomplete.)</p>
<div class="figure">
<a id="id36113928"></a><p class="title"><b>Figure 2. Tasks index view</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="views_and_templates/tasks-index.png" alt="views_and_templates/tasks-index.png"></div></div>
</div>
<br class="figure-break"><div class="figure">
<a id="id36113950"></a><p class="title"><b>Figure 3. Tasks detail view</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="views_and_templates/tasks-detail.png" alt="views_and_templates/tasks-detail.png"></div></div>
</div>
<br class="figure-break"><p>The view classes for these pages could be written as follows:</p>
<pre class="programlisting">var TasksIndex = Backbone.View.extend({
  template: JST['tasks/tasks_index'],
  tagName: 'section',
  id: 'tasks',

  initialize: function() {
    _.bindAll(this, "render");
    TaskApp.tasks.bind("change", this.render);
    TaskApp.tasks.bind("add", this.render);
  },

  render: function() {
    $(this.el).html(this.template({tasks: this.collection}));
  }
});</pre>
<pre class="programlisting">var TaskDetail = Backbone.View.extend({
  template: JST['tasks/tasks_detail'],
  tagName: 'section',
  id: 'task',

  events: {
    "click .comments .form-inputs button": "createComment"
  },

  initialize: function() {
    _.bindAll(this, "render");

    this.model.bind("change", this.render);
    this.model.comments.bind("change", this.render);
    this.model.comments.bind("add", this.render);
  },

  render: function() {
    $(this.el).html(this.template({task: this.model}));
  },

  createComment: function() {
    var comment = new Comment({ text: this.$('.new-comment-input').val() });
    this.$('.new-comment-input').val('');
    this.model.comments.create(comment);
  }
});</pre>
<p>Each task on the index page links to the detail view for itself. When a user
follows one of these links and navigates from the index page to the detail
page, then interacts with the detail view to change a model, the <code class="literal">change</code> event
on the <code class="literal">TaskApp.tasks</code> collection is fired. One consequence of this is that
the index view, which is still bound and observing the <code class="literal">change</code> event, will
re-render itself.</p>
<p>This is both a functional bug and a memory leak: not only will the index view
re-render and disrupt the detail display momentarily, but navigating back and
forth between the views without disposing of the previous view will keep
creating more views and binding more events on the associated models or
collections.</p>
<p>These can be extremely tricky to track down on a production application,
especially if you are rendering children views, much like how Rails can render
a partial for each member of a collection. Sadly, there’s no "garbage
collection" for views in Backbone, so your application needs to manage this
itself.</p>
<p>The solution is to make sure you unbind events and remove views when you leave
them. Our approach to this is to use a convention in <code class="literal">Router</code> instances, and reuse
this as a <code class="literal">Router</code> subclass, <code class="literal">SwappingRouter</code>.</p>
</div>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_swapping_router"></a>Swapping router</h3></div></div></div>
<p>When switching from one view to another, we should clean up the previous view.
Let’s augment our view to include the ability to clean itself up by "leaving"
the DOM:</p>
<pre class="programlisting">var MyView = Backbone.View.extend({
  // ...

  leave: function() {
    this.unbind();
    this.remove();
  },

  // ...
});</pre>
<p>The <code class="literal">unbind()</code> and <code class="literal">remove()</code> functions are provided by <code class="literal">Backbone.Events</code> and
<code class="literal">Backbone.View</code>.  <code class="literal">unbind()</code> will remove all callbacks registered on the view,
and <code class="literal">remove()</code> will remove the view’s element from the DOM.</p>
<p>In simple cases, we replace one full page view with another full page (less any
shared layout). We introduce a convention that all actions underneath one
<code class="literal">Router</code> share the same root element, and define it as <code class="literal">el</code> on the router.</p>
<p>Now, a <code class="literal">SwappingRouter</code> can take advantage of the <code class="literal">leave()</code> function, and clean
up any existing views before swapping to a new one.  It swaps into a new view by
rendering that view into its own <code class="literal">el</code>:</p>
<pre class="programlisting">SwappingRouter = function(options) {
  Backbone.Router.apply(this, [options]);
};

_.extend(SwappingRouter.prototype, Backbone.Router.prototype, {
  swap: function(newView) {
    if (this.currentView &amp;&amp; this.currentView.leave) {
      this.currentView.leave();
    }

    this.currentView = newView;
    this.currentView.render();
    $(this.el).empty().append(this.currentView.el);
  }
});

SwappingRouter.extend = Backbone.Router.extend;</pre>
<p>Now all you need to do in a route function is call <code class="literal">swap()</code>, passing in the
new view that should be rendered. The <code class="literal">swap()</code> function’s job is to call
<code class="literal">leave()</code> on the current view, render the new view and append it to the
router’s <code class="literal">el</code>, and finally store who the current view is, so that next time
<code class="literal">swap()</code> is invoked, it can be properly cleaned up as well.</p>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="swapping-internals"></a>SwappingRouter and Backbone internals</h4></div></div></div>
<p>If the code for <code class="literal">SwappingRouter</code> seems a little confusing, don’t fret: it is,
thanks to JavaScript’s object model! Sadly, it’s not as simple to just drop in
the <code class="literal">swap</code> method into <code class="literal">Backbone.Router</code>, or call <code class="literal">Backbone.Router.extend</code> to
mixin the function we need.</p>
<p>Our goal here is essentially to create a subclass of <code class="literal">Backbone.Router</code>, and to
extend it without modifying the original class. This gives us a few benefits:
first, <code class="literal">SwappingRouter</code> should work with Backbone upgrades. Second, it shold be
<span class="strong"><strong>obvious</strong></span>  and <span class="strong"><strong>intention-revealing</strong></span> when a controller needs to swap views. If
we chose to just mix in a <code class="literal">swap</code> method, and called it from a direct descendant
of <code class="literal">Backbone.Router</code>, an unaware (and unlucky) programmer now needs to go on a
deep source dive in an attempt to figure out where that’s coming from. At least
with a subclass, the hunt should start at the file where it was defined.</p>
<p>The procedure used to create <code class="literal">SwappingRouter</code> is onerous thanks to a mix of
Backbone-isms and just how clunky inheritance is in JavaScript. First off, we
need to define the constructor, which delegates to the <code class="literal">Backbone.Router</code>
constructor with the use of <code class="literal">Function#apply</code>. The next block of code uses
Underscore’s <code class="literal">Object#extend</code> to create the set of functions and properties that
will become <code class="literal">SwappingRouter</code>. The <code class="literal">extend</code> function takes a destination, in
this case the empty prototype for <code class="literal">SwappingRouter</code>, and copies in the
properties in the <code class="literal">Backbone.Router</code> prototype along with our new custom object
that includes the <code class="literal">swap</code> function.</p>
<p>Finally, the subclass cake is topped off with some Backbone frosting: setting
<code class="literal">extend</code>, which is a self-propagating function that all Backbone public classes
use. Let’s take a quick look at this function, as of Backbone 0.5.3:</p>
<pre class="programlisting">var extend = function (protoProps, classProps) {
  var child = inherits(this, protoProps, classProps);
  child.extend = this.extend;
  return child;
};

// Helper function to correctly set up the prototype chain, for subclasses.
// Similar to `goog.inherits`, but uses a hash of prototype properties and
// class properties to be extended.
var inherits = function(parent, protoProps, staticProps) {
  // sparing our readers the internals of this function... for a deep dive
  // into the dark realms of JavaScript's prototype system, read the source!
}</pre>
<p>So, it’s a function that calls <code class="literal">inherits</code> to make a new subclass.  The comments
reference <code class="literal">goog.inherits</code> from Google’s Closure Library, which contains similar
utility functions to allow more class-style inheritance.</p>
<p>The end result here is that whenever you make a custom controller, internally
in Backbone, you’re making <span class="strong"><strong>another</strong></span> subclass. The inheritance chain for
<code class="literal">TasksRouter</code> would then look like:</p>
<div class="figure">
<a id="id36114396"></a><p class="title"><b>Figure 4. Router class inheritance</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="views_and_templates/router-diagram.png" alt="views_and_templates/router-diagram.png"></div></div>
</div>
<br class="figure-break"><p>Phew! Hopefully this adventure into Backbone and JavaScript internals has
taught you that although it’s more code, it’s hopefully going to save time down
the road for those maintaining your code.</p>
</div>
</div>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_composite_views"></a>Composite views</h3></div></div></div>
<p>The <code class="literal">SwappingRouter</code> above calls <code class="literal">leave()</code> on the view it currently holds.
This function is not part of Backbone itself, and is part of our extension
library to help make views more modular and maintainable. This section goes
over the Composite View pattern, the <code class="literal">CompositeView</code> class itself, and some
concerns to keep in mind while creating your views.</p>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_refactoring_from_a_large_view"></a>Refactoring from a large view</h4></div></div></div>
<p>One of the first refactorings you find yourself doing in a non-trivial Backbone
app is splitting up large views into composable parts. Let’s take another look
at the <code class="literal">TaskDetail</code> source code from the beginning of this section:</p>
<pre class="programlisting">var TaskDetail = Backbone.View.extend({
  template: JST['tasks/tasks_detail'],
  tagName: 'section',
  id: 'task',

  events: {
    "click .comments .form-inputs button": "createComment"
  },

  initialize: function() {
    _.bindAll(this, "render");

    this.model.bind("change", this.render);
    this.model.comments.bind("change", this.render);
    this.model.comments.bind("add", this.render);
  },

  render: function() {
    $(this.el).html(this.template({task: this.model}));
  },

  createComment: function() {
    var comment = new Comment({ text: this.$('.new-comment-input').val() });
    this.$('.new-comment-input').val('');
    this.model.comments.create(comment);
  }
});</pre>
<p>The view class references a template, which renders out the HTML for this page:</p>
<pre class="programlisting">&lt;section class="task-details"&gt;
  &lt;input type="checkbox"&lt;%= task.isComplete() ? ' checked="checked"' : '' %&gt; /&gt;
  &lt;h2&gt;&lt;%= task.escape("title") %&gt;&lt;/h2&gt;
&lt;/section&gt;

&lt;section class="comments"&gt;
  &lt;ul&gt;
    &lt;% task.comments.each(function(comment) { %&gt;
      &lt;li&gt;
        &lt;h4&gt;&lt;%= comment.user.escape('name') %&gt;&lt;/h4&gt;
        &lt;p&gt;&lt;%= comment.escape('text') %&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;% } %&gt;
  &lt;/ul&gt;

  &lt;div class="form-inputs"&gt;
    &lt;label for="new-comment-input"&gt;Add comment&lt;/label&gt;
    &lt;textarea id="new-comment-input" cols="30" rows="10"&gt;&lt;/textarea&gt;
    &lt;button&gt;Add Comment&lt;/button&gt;
  &lt;/div&gt;
&lt;/section&gt;</pre>
<p>There are clearly several concerns going on here: rendering the task, rendering
the comments that folks have left, and rendering the form to create new
comments. Let’s separate those concerns. A first approach might be to just
break up the template files:</p>
<pre class="programlisting">&lt;!-- tasks/show.jst --&gt;
&lt;section class="task-details"&gt;
  &lt;%= JST['tasks/details']({ task: task }) %&gt;
&lt;/section&gt;

&lt;section class="comments"&gt;
  &lt;%= JST['comments/list']({ task: task }) %&gt;
&lt;/section&gt;</pre>
<pre class="programlisting">&lt;!-- tasks/details.jst --&gt;
&lt;input type="checkbox"&lt;%= task.isComplete() ? ' checked="checked"' : '' %&gt; /&gt;
&lt;h2&gt;&lt;%= task.escape("title") %&gt;&lt;/h2&gt;</pre>
<pre class="programlisting">&lt;!-- comments/list.jst --&gt;
&lt;ul&gt;
  &lt;% task.comments.each(function(comment) { %&gt;
    &lt;%= JST['comments/item']({ comment: comment }) %&gt;
  &lt;% } %&gt;
&lt;/ul&gt;

&lt;%= JST['comments/new']() %&gt;</pre>
<pre class="programlisting">&lt;!-- comments/item.jst --&gt;
&lt;h4&gt;&lt;%= comment.user.escape('name') %&gt;&lt;/h4&gt;
&lt;p&gt;&lt;%= comment.escape('text') %&gt;&lt;/p&gt;</pre>
<pre class="programlisting">&lt;!-- comments/new.jst --&gt;
&lt;div class="form-inputs"&gt;
  &lt;label for="new-comment-input"&gt;Add comment&lt;/label&gt;
  &lt;textarea id="new-comment-input" cols="30" rows="10"&gt;&lt;/textarea&gt;
  &lt;button&gt;Add Comment&lt;/button&gt;
&lt;/div&gt;</pre>
<p>But this is really only half the story. The <code class="literal">TaskDetail</code> view class still
handles multiple concerns: displaying the task, and creating comments. Let’s
split that view class up, using the <code class="literal">CompositeView</code> base class:</p>
<pre class="programlisting">CompositeView = function(options) {
  this.children = [];
  Backbone.View.apply(this, [options]);
};

_.extend(CompositeView.prototype, Backbone.View.prototype, {
  leave: function() {
    this.unbind();
    this.remove();
    this._leaveChildren();
    this._removeFromParent();
  },

  removeChild: function(view) {
    var index = this.children.indexOf(view);
    this.children.splice(index, 1);
  },

  renderChild: function(view) {
    view.render();
    this.children.push(view);
    view.parent = this;
  },

  appendChild: function(view) {
    this.renderChild(view);
    $(this.el).append(view.el);
  },

  renderChildInto: function(view, container) {
    this.renderChild(view);
    $(container).html('').append(view.el);
  },

  _leaveChildren: function() {
    var clonedChildren = this.children.slice(0);
    _.each(clonedChildren, function(view) {
      if (view.leave) {
        view.leave();
      }
    });
  },

  _removeFromParent: function() {
    if (this.parent) {
      this.parent.removeChild(this);
    }
  }
});

CompositeView.extend = Backbone.View.extend;</pre>
<p>Similar to the <code class="literal">SwappingRouter</code>, the <code class="literal">CompositeView</code> base class solves common
housekeeping problems by establishing a convention. See the
<a class="link" href="views_and_templates.html#swapping-internals" title="SwappingRouter and Backbone internals">Swapping Router and Backbone internals</a> section for an
in-depth analysis of how this subclassing pattern works.</p>
<p>Now our <code class="literal">CompositeView</code> maintains an array of its immediate children as
<code class="literal">this.children</code>.  With this reference in place, a parent view’s <code class="literal">leave()</code> method
can invoke <code class="literal">leave()</code> on its children, ensuring that an entire tree of composed
views is cleaned up properly.</p>
<p>For child views that can dismiss themselves, such as dialog boxes, children
maintain a back-reference at <code class="literal">this.parent</code>. This is used to reach up and call
<code class="literal">this.parent.removeChild(this)</code> for these self-dismissing views.</p>
<p>Making use of <code class="literal">CompositeView</code>, we split up the <code class="literal">TaskDetail</code> view class:</p>
<pre class="programlisting">var TaskDetail = Backbone.View.extend({
  tagName: 'section',
  id: 'task',

  initialize: function() {
    _.bindAll(this, "renderDetails");
    this.model.bind("change", this.renderDetails);
  },

  render: function() {
    this.renderLayout();
    this.renderDetail();
    this.renderCommentsList();
  },

  renderLayout: function() {
    $(this.el).html(JST['tasks/show']());
  },

  renderDetails: function() {
    var detailsMarkup = JST['tasks/details']({ task: this.model });
    this.$('.task-details').html(detailsMarkup);
  },

  renderCommentsList: function() {
    var commentsList = new CommentsList({ model: this.model });
    var commentsContainer = this.$('comments');
    this.renderChildInto(commentsList, commentsContainer);
  }
});</pre>
<pre class="programlisting">var CommentsList = CompositeView.extend({
  tagName: 'ul',

  initialize: function() {
    this.model.comments.bind("add", this.renderComments);
  },

  render: function() {
    this.renderLayout();
    this.renderComments();
    this.renderCommentForm();
  },

  renderLayout: function() {
    $(this.el).html(JST['comments/list']());
  },

  renderComments: function() {
    var commentsContainer = this.$('comments-list');
    commentsContainer.html('');

    this.model.comments.each(function(comment) {
      var commentMarkup = JST['comments/item']({ comment: comment });
      commentsContainer.append(commentMarkup);
    });
  },

  renderCommentForm: function() {
    var commentForm = new CommentForm({ model: this.model });
    var commentFormContainer = this.$('.new-comment-form');
    this.renderChildInto(commentForm, commentFormContainer);
  }
});</pre>
<pre class="programlisting">var CommentForm = CompositeView.extend({
  events: {
    "click button": "createComment"
  },

  initialize: function() {
    this.model = this.options.model;
  },

  render: function() {
    $(this.el).html(JST['comments/new']);
  },

  createComment: function() {
    var comment = new Comment({ text: $('.new-comment-input').val() });
    this.$('.new-comment-input').val('');
    this.model.comments.create(comment);
  }
});</pre>
<p>Along with this, remove the <code class="literal">&lt;%= JST(…) %&gt;</code> template nestings, allowing the
view classes to assemble the templates instead. In this case, each template
contains placeholder elements that are used to wrap child views:</p>
<pre class="programlisting">&lt;!-- tasks/show.jst --&gt;
&lt;section class="task-details"&gt;
&lt;/section&gt;

&lt;section class="comments"&gt;
&lt;/section&gt;</pre>
<pre class="programlisting">&lt;!-- tasks/details.jst --&gt;
&lt;input type="checkbox"&lt;%= task.isComplete() ? ' checked="checked"' : '' %&gt; /&gt;
&lt;h2&gt;&lt;%= task.escape("title") %&gt;&lt;/h2&gt;</pre>
<pre class="programlisting">&lt;!-- comments/list.jst --&gt;
&lt;ul class="comments-list"&gt;
&lt;/ul&gt;

&lt;section class="new-comment-form"&gt;
&lt;/section&gt;</pre>
<pre class="programlisting">&lt;!-- comments/item.jst --&gt;
&lt;h4&gt;&lt;%= comment.user.escape('name') %&gt;&lt;/h4&gt;
&lt;p&gt;&lt;%= comment.escape('text') %&gt;&lt;/p&gt;</pre>
<pre class="programlisting">&lt;!-- comments/new.jst --&gt;
&lt;label for="new-comment-input"&gt;Add comment&lt;/label&gt;
&lt;textarea class="new-comment-input" cols="30" rows="10"&gt;&lt;/textarea&gt;
&lt;button&gt;Add Comment&lt;/button&gt;</pre>
<p>There are several advantages to this approach:</p>
<div class="itemizedlist"><ul type="disc">
<li>
Each view class has a smaller and more cohesive set of responsibilities.
</li>
<li>
The comments view code, extracted and decoupled from the task view code, can
  now be reused on other domain objects with comments.
</li>
<li>
The task view performs better, since adding new comments or updating the task
  details will only re-render the pertinent section, instead of re-rendering the
  entire task + comments composite.
</li>
</ul></div>
</div>
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title">
<a id="_cleaning_up_views_properly"></a>Cleaning up views properly</h4></div></div></div></div>
</div>
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title">
<a id="_how_to_use_multiple_views_on_the_same_model_collection_chapter_unstarted"></a>How to use multiple views on the same model/collection (chapter unstarted)</h3></div></div></div></div>
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title">
<a id="_internationalization_chapter_unstarted"></a>Internationalization (chapter unstarted)</h3></div></div></div></div>
</div>

    </div>

    <hr/>

    <div class="nav" id="navfooter">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="rails_integration.html">Prev</a><br/>
         Rails Integration
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         Backbone.js on Rails
        
      </td><td width="33%" align="right">
        
          <a href="models_and_collections.html">Next</a><br/>
          Models and collections
        
      </td></tr>
    </table>
    </div>
  </body>
</html>
