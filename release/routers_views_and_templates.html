<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="master.css" type="text/css" />
    <title>Routers, Views, and Templates</title>
  </head>

  <body>
    <div class="nav" id="navheader">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="rails_integration.html">Prev</a><br/>
         Rails Integration
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         <strong>Backbone.js on Rails</strong>
        
      </td><td width="33%" align="right">
        
          <a href="models_and_collections.html">Next</a><br/>
          Models and collections
        
      </td></tr>
    </table>
    </div>

    <hr/>

    <div class="content">
      <div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a id="_routers_views_and_templates"></a>Routers, Views, and Templates</h2></div></div></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_view_explanation"></a>View explanation</h3></div></div></div>
<p>A Backbone view is a class that is responsible for rendering the display of
a logical element on the page. A view can also bind to events which may cause
it to be re-rendered.</p>
<p>It’s important to note that a Rails view is not directly analogous to a
Backbone view. A Rails view is more like a Backbone template, and
Backbone views are often more like Rails controllers, in that they are
responsible for deciding what should be rendered and how, and for rendering the
actual template file. This can cause confusion with developers just starting
with Backbone.</p>
<p>A basic Backbone view appears as follows.</p>
<pre class="programlisting">ExampleApp.Views.ExampleView = Backbone.View.extend({
  tagName: <b class="hl-string"><i style="color:red">"li"</i></b>,
  className: <b class="hl-string"><i style="color:red">"example"</i></b>,
  id: <b class="hl-string"><i style="color:red">"example_view"</i></b>,

  events: {
    <b class="hl-string"><i style="color:red">"click a.save"</i></b>: <b class="hl-string"><i style="color:red">"save"</i></b>
  },

  render: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.$el.html(JST[<b class="hl-string"><i style="color:red">'example/view'</i></b>]({ model: <b class="hl-keyword">this</b>.model }));
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>;
  },

  save: <b class="hl-keyword">function</b>() {
    <i class="hl-comment" style="color: silver">// do something</i>
  }
};</pre>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_initialization"></a>Initialization</h4></div></div></div>
<p>Backbone views could also include an <code class="literal">initialize</code> function which will
be called when the view is instantiated.</p>
<p>You only need to specify the initialize function if you wish to do something
custom. For example, some views call the <code class="literal">render()</code> function upon
instantiation. It’s not necessary to immediately render that way,
but it’s relatively common to do so.</p>
<p>You create a new view by instantiating it with <code class="literal">new</code>. For example <code class="literal">new
ExampleView()</code>. It is possible to pass in a hash of options with <code class="literal">new
ExampleView(options)</code>. Any options you pass into the constructor will be
available inside of the view in <code class="literal">this.options</code>.</p>
<p>There are a few special options that, when passed, will be assigned as
properties of view. These are <code class="literal">model</code>, <code class="literal">collection</code>, <code class="literal">el</code>, <code class="literal">id</code>,
<code class="literal">className</code>, and <code class="literal">tagName</code>. For example, if you create a new view and give it
a model option using <code class="literal">new ExampleView({ model: someTask })</code>, then inside of the view
<code class="literal">someTask</code> will be available as <code class="literal">this.model</code>.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_the_view_8217_s_element"></a>The View’s Element</h4></div></div></div>
<p>Each Backbone view has an element which it stores in <code class="literal">this.el</code>. This element
can be populated with content, but isn’t on the page until placed there by
you. Using this strategy it is then possible to render views outside of the
current DOM at any time, and then later in your code, insert the new elements all
at once. In this way, high performance rendering of views can be achieved with as
few reflows and repaints as possible.</p>
<p>A jQuery or Zepto object of the view’s element is available in <code class="literal">this.$el</code>.
This is useful so you don’t need to repeatedly call <code class="literal">$(this.el)</code>. This jQuery
or Zepto call is also cached, so it should be a performance improvement over
repeatedly calling <code class="literal">$(this.el)</code>.</p>
<p>It is possible to create a view that references an element already in the DOM,
instead of a new element. To do this, pass in the existing element as an
option to the view constructor with <code class="literal">new ExampleView({ el: existingElement })</code>.</p>
<p>You can also set this after the fact with the <code class="literal">setElement()</code> function.</p>
<pre class="programlisting"><b class="hl-keyword">var</b> view = <b class="hl-keyword">new</b> ExampleView();
view.setElement(existingElement);</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_customizing_the_view_8217_s_element"></a>Customizing the View’s Element</h4></div></div></div>
<p>You can use <code class="literal">tagName</code>, <code class="literal">className</code>, and <code class="literal">id</code> to customize the new element
created for the view. If no customization is done, the element is an empty
<code class="literal">div</code>.</p>
<p><code class="literal">tagName</code>, <code class="literal">className</code>, and <code class="literal">id</code> can either be specified directly on the view
or passed in as options at instantiation time. Since <code class="literal">id</code> will usually to correspond
to the <code class="literal">id</code> of each model, it will likely be passed in as an option rather
than declared statically in the view.</p>
<p><code class="literal">tagName</code> will change the element that is created from a <code class="literal">div</code> to something
else that you specify. For example, setting <code class="literal">tagName: "li"</code> will result in the
view’s element being an <code class="literal">li</code> rather than a <code class="literal">div</code>.</p>
<p><code class="literal">className</code> will add an additional class to the element that is created for
the view. For example, setting <code class="literal">className: "example"</code> in the view will result
in that view’s element having that additional class like <code class="literal">&lt;div class="example"&gt;</code>.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_rendering"></a>Rendering</h4></div></div></div>
<p>The <code class="literal">render</code> function above renders the <code class="literal">example/view</code> template. Template
rendering is covered in depth in the "Templating strategy" chapter. Suffice to
say, nearly every view’s render function will render some form of template. Once
that template is rendered, other actions to modify the view may be taken.</p>
<p>In addition to rendering a template, typical responsibilities of the <code class="literal">render</code> function
could include adding additional classes or attributes to <code class="literal">this.el</code>, or firing or
binding other events.</p>
<p>Backbone, when used with jQuery (or Zepto) provides a convenience function
of <code class="literal">this.$</code> that can be used for selecting elements inside of the view.
<code class="literal">this.$(selector)</code> is equivalent to the jQuery function call <code class="literal">$(selector,
this.el)</code></p>
<p>A nice convention of the render function is to return <code class="literal">this</code> at the end of
render to enable chained calls on the view - usually fetching the element.
For example:</p>
<pre class="programlisting">render: <b class="hl-keyword">function</b>() {
  <b class="hl-keyword">this</b>.$el.html(<b class="hl-keyword">this</b>.childView.render().el);
  <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>;
}</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_events"></a>Events</h4></div></div></div>
<p>The view’s <code class="literal">events</code> hash specifies a mapping of the events and elements that
should have events bound, and the functions that should be bound to those
events. In the example above the <code class="literal">click</code> event is being bound to the
element(s) that match the selector <code class="literal">a.save</code> within the view’s element. When
that event fires, the <code class="literal">save</code> function will be called on the view.</p>
<p>When event bindings are delcared with the <code class="literal">events</code> hash, the DOM events are bound
with the <code class="literal">$.delegate()</code> function. Backbone also takes care of binding the
event handlers' <code class="literal">this</code> to the view instance using <code class="literal">_.on()</code>.</p>
<p>Event binding is covered in great detail in the "Event binding" chapter.</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_templating_strategy"></a>Templating strategy</h3></div></div></div>
<p>There’s no shortage of templating options for JavaScript.</p>
<p>They generally fall into three categories:</p>
<div class="itemizedlist"><ul type="disc">
<li>
HTML with JavaScript expressions interpolated. Examples: <code class="literal">_.template</code>, EJS.
</li>
<li>
HTML with other expressions interpolated, often logic-free. Examples: mustache, handlebars, <code class="literal">jQuery.tmpl</code>
</li>
<li>
Selector-based content declarations. Examples: PURE, just using jQuery from view classes.
</li>
</ul></div>
<p>To quickly compare the different approaches, we will work with creating a
template that renders the following HTML:</p>
<pre class="programlisting"><b class="hl-tag" style="color: #000096">&lt;ul</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"tasks"</span><b class="hl-tag" style="color: #000096">&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;li&gt;</b><b class="hl-tag" style="color: #000096">&lt;span</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"title"</span><b class="hl-tag" style="color: #000096">&gt;</b>Buy milk<b class="hl-tag" style="color: #000096">&lt;/span&gt;</b> Get the good kind <b class="hl-tag" style="color: #000096">&lt;/li&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;li&gt;</b><b class="hl-tag" style="color: #000096">&lt;span</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"title"</span><b class="hl-tag" style="color: #000096">&gt;</b>Buy cheese<b class="hl-tag" style="color: #000096">&lt;/span&gt;</b> Sharp cheddar <b class="hl-tag" style="color: #000096">&lt;/li&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;li&gt;</b><b class="hl-tag" style="color: #000096">&lt;span</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"title"</span><b class="hl-tag" style="color: #000096">&gt;</b>Eat cheeseburger<b class="hl-tag" style="color: #000096">&lt;/span&gt;</b> Make with above cheese <b class="hl-tag" style="color: #000096">&lt;/li&gt;</b>
<b class="hl-tag" style="color: #000096">&lt;/ul&gt;</b></pre>
<p>Assuming we have a TasksCollection instance containing the three elements
displayed in the above HTML snippet, let’s look at how different templating
libraries accomplish the same goal of rendering the above.</p>
<p>Since you’re already familiar with underscore templates, let’s start there.</p>
<p>An underscore template may look like so:</p>
<pre class="programlisting"><b class="hl-tag" style="color: #000096">&lt;ul</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"tasks"</span><b class="hl-tag" style="color: #000096">&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;%</b> <span class="hl-attribute" style="color: #F5844C">tasks.each(function(task)</span> <span class="hl-attribute" style="color: #F5844C">{</span> <span class="hl-attribute" style="color: #F5844C">%&gt;</span>
    <span class="hl-attribute" style="color: #F5844C">&lt;li&gt;</span>
        <span class="hl-attribute" style="color: #F5844C">&lt;span</span> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"title"</span><b class="hl-tag" style="color: #000096">&gt;</b> <b class="hl-tag" style="color: #000096">&lt;%=</b> <span class="hl-attribute" style="color: #F5844C">task.escape("title")</span> <span class="hl-attribute" style="color: #F5844C">%&gt;</span> <span class="hl-attribute" style="color: #F5844C">&lt;/span&gt;</span>
        <span class="hl-attribute" style="color: #F5844C">&lt;%</span>= <span class="hl-value" style="color: #993300">task.escape("body")</span> <span class="hl-attribute" style="color: #F5844C">%&gt;</span>
    <span class="hl-attribute" style="color: #F5844C">&lt;/li&gt;</span>
  <span class="hl-attribute" style="color: #F5844C">&lt;%</span> <span class="hl-attribute" style="color: #F5844C">})</span> <span class="hl-attribute" style="color: #F5844C">%&gt;</span>
<span class="hl-attribute" style="color: #F5844C">&lt;/ul&gt;</span></pre>
<p>Here we interpolate a bit of javascript logic in order to iterate
through the collection and render the desired markup. Also note
that we must fetch escaped values from the task objects, as underscore
templates do not perform any escaping on their own.</p>
<p>This is probably the path of least resistance on a Rails Backbone app.
Since Backbone depends on underscore.js, it is already available in
your app. As has already been shown on earlier chapters, its usage
is very similar to ERB. It has the same <code class="literal">&lt;%=</code> and <code class="literal">%&gt;</code> syntax as ERB,
and you can pass it an options object that is made available to the
template when it’s rendered.</p>
<p>While we’ve found underscore’s templating to be useful and sufficient to
build large backbone applications, there are other templating libraries
that are worth mentioning here because they either provide richer
functionality or take a different approach to templating.</p>
<p>Handlebars is one such example. One major difference with underscore is
that it allows you to define and register helpers that can be used when
rendering a template, providing a framework for writing helpers similar
to those found in ActionView::Helpers, like <code class="literal">domID</code> or other generic
rendering logic. It also alows you to write what are called "block helpers",
which are functions that are executed on a different, supplied context during
rendering. Handlebars itself exploits this functionality by providing
a few helpers out of the box. These helpers are <code class="literal">with</code>, <code class="literal">each</code>, <code class="literal">if</code>
and <code class="literal">unless</code>, and simply provide control structures for rendering logic.</p>
<p>The above template would look like so in Handlebars:</p>
<pre class="programlisting"><b class="hl-tag" style="color: #000096">&lt;ul</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"title"</span><b class="hl-tag" style="color: #000096">&gt;</b>
  {{#each tasks}}
    <b class="hl-tag" style="color: #000096">&lt;li&gt;</b>
        <b class="hl-tag" style="color: #000096">&lt;span</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"title"</span><b class="hl-tag" style="color: #000096">&gt;</b> {{ this.get("title") }} <b class="hl-tag" style="color: #000096">&lt;/span&gt;</b>
        {{ this.get("body") }} %&gt;
    <b class="hl-tag" style="color: #000096">&lt;/li&gt;</b>
  {{/each}}
<b class="hl-tag" style="color: #000096">&lt;ul&gt;</b></pre>
<p>Of note:</p>
<div class="itemizedlist"><ul type="disc">
<li>
Use of <code class="literal">{{#each}}</code>, which iterates over the collection
</li>
<li>
Within the <code class="literal">{{#each}}</code> block, the javascript context is
  the task itself, so you access it’s properties via <code class="literal">this</code>.
</li>
<li>
There’s no need to escape HTML output, as handlebars escapes
  by default.
</li>
</ul></div>
<p>A similar library is Mustache.js. Mustache is a templating system
that has been ported to a number of languages including javascript. The
promise of Mustache is "logic-less templates". Instead of requiring you to write
logic in pure javascript, using <code class="literal">if</code> for example, Mustache provides a set of tags
that take on different meanings. They can render values or not render anything at
all.</p>
<p>Both Handlebars and Mustache HTML escape rendered values by default.</p>
<p>You can learn more about handlebars at the
<a class="ulink" href="http://www.handlebarsjs.com/" target="_top">project’s home on the web</a>,
and mustache at
<a class="ulink" href="http://mustache.github.com/mustache.5.html" target="_top">the project’s man page</a>
and <a class="ulink" href="https://github.com/janl/mustache.js:" target="_top">javascript implementation</a></p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_choosing_a_strategy"></a>Choosing a strategy</h3></div></div></div>
<p>Like any technology choice, there are trade-offs to evaluate and external forces
to consider when choosing a templating approach.</p>
<p>One of the common questions we’ve found ourselves asking is: Do I
already have server-side templates written that I’d like to "Backbone-ify," or
am I writing new Backbone functionality from scratch? Each of these scenarios
is described in more detail in the following sections.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_when_you_are_adding_backbone_to_existing_rails_views"></a>When you are adding Backbone to existing Rails views</h4></div></div></div>
<p>If you are replacing existing Rails app pages with Backbone, you are already
using a templating engine, and it’s likely ERb. When making the switch to
Backbone, change as few things as possible at a time, and stick with your
existing templating approach.</p>
<p>If you’re using ERb, give <code class="literal">_.template</code> a shot. It defaults to the same
delimiters as ERb for interpolation and evaluation, <code class="literal">&lt;%= %&gt;</code> and <code class="literal">&lt;% %&gt;</code>,
which can be a boon or can be confusing. If you’d like to change them,
you can update <code class="literal">.templateSettings</code> - check the Underscore.js docs.</p>
<p>If you’re using Haml, check out the <code class="literal">jquery-haml</code> and <code class="literal">haml-js</code> projects.</p>
<p>If you’re using Mustache.rb or Handlebars.rb, you’re likely aware that
Javascript implementations of these both exist, and that your existing
templates can be moved over much like the ERb case.</p>
<p>Ultimately you should choose a templating strategy that your entire team is
comfortable with, while minimizing the cost of rewriting templates.  Make sure
that designers' considerations are taken into account because it will affect how
they work with that area of the app as well.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_when_you_are_writing_new_backbone_functionality_from_scratch"></a>When you are writing new Backbone functionality from scratch</h4></div></div></div>
<p>If you’re not migrating from existing server-side view templates,
you have more freedom of choice. Strongly consider the option of no templating
at all, but rather using plain HTML templates, and then decorating the DOM from
your view class.</p>
<p>You can build static HTML mockups of the application first, and pull these
mockups directly in as templates, without modifying them.</p>
<pre class="programlisting"><i class="hl-comment" style="color: silver">&lt;!-- snip --&gt;</i>
<b class="hl-tag" style="color: #000096">&lt;div</b> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"song-player"</span><b class="hl-tag" style="color: #000096">&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;nav&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;a</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"home"</span>    <span class="hl-attribute" style="color: #F5844C">href</span>=<span class="hl-value" style="color: #993300">"#/"</span><b class="hl-tag" style="color: #000096">&gt;</b>Home<b class="hl-tag" style="color: #000096">&lt;/a&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;a</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"profile"</span> <span class="hl-attribute" style="color: #F5844C">href</span>=<span class="hl-value" style="color: #993300">"/profile.html"</span><b class="hl-tag" style="color: #000096">&gt;</b>My Profile<b class="hl-tag" style="color: #000096">&lt;/a&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;/nav&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;h2&gt;</b>Song title<b class="hl-tag" style="color: #000096">&lt;/h2&gt;</b>

  <b class="hl-tag" style="color: #000096">&lt;audio</b> <span class="hl-attribute" style="color: #F5844C">controls</span>=<span class="hl-value" style="color: #993300">"controls"</span><b class="hl-tag" style="color: #000096">&gt;</b>
    <b class="hl-tag" style="color: #000096">&lt;source</b> <span class="hl-attribute" style="color: #F5844C">src</span>=<span class="hl-value" style="color: #993300">"/test.ogg"</span> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"audio/ogg"</span><b class="hl-tag" style="color: #000096"> /&gt;</b>
    Your browser does not support the audio element.
  <b class="hl-tag" style="color: #000096">&lt;/audio&gt;</b>
<b class="hl-tag" style="color: #000096">&lt;/div&gt;</b>
<i class="hl-comment" style="color: silver">&lt;!-- snip --&gt;</i></pre>
<pre class="programlisting">MyView = Backbone.View.extend({
  render: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.renderTemplate();
    <b class="hl-keyword">this</b>.fillTemplate();
  },

  renderTemplate: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.$el.html(JST[<b class="hl-string"><i style="color:red">'songs/index'</i></b>]();
  },

  fillTemplate: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'nav a.profile'</i></b>).text(App.currentUser().fullName());
    <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'h2'</i></b>).html(<b class="hl-keyword">this</b>.model.escape(<b class="hl-string"><i style="color:red">'title'</i></b>));

    <b class="hl-keyword">var</b> audio = <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'audio'</i></b>);
    audio.empty();
    <b class="hl-keyword">this</b>.model.formats.each(<b class="hl-keyword">function</b>(format) {
      $(<b class="hl-string"><i style="color:red">"&lt;source&gt;&lt;/source&gt;"</i></b>)
        .attr(<b class="hl-string"><i style="color:red">"src"</i></b>,  format.get(<b class="hl-string"><i style="color:red">'src'</i></b>))
        .attr(<b class="hl-string"><i style="color:red">"type"</i></b>, format.get(<b class="hl-string"><i style="color:red">'type'</i></b>))
        .appendTo(audio);
    });
  }
});</pre>
<p>You can see an example of this in the example application’s <code class="literal">TaskItem</code> view
class, at <code class="literal">app/assets/javascripts/views/task_item.js</code>.</p>
<p>The only disadvantage of this is that your view’s <code class="literal">render()</code> functions become
more coupled to the structure of the HTML. This means that a major change in the
markup may break the rendering because the selectors used to replace parts
of the DOM may no longer find the same elements, or may not find any elements
at all.</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_routers"></a>Routers</h3></div></div></div>
<p>Routers are an important part of the Backbone infrastructure. Backbone
routers provide methods for routing application flow based on client-side URL
fragments (<code class="literal">yourapp.com/tasks#fragment</code>).</p>
<p>Routes are meant to represent serializable, bookmarkable entry points into your
Backbone application.  This means that the pertinent application state is
serialized into the route fragment and that, given a route, you can completely
restore that application state.  They serve as navigational checkpoints, and
determine the granularity at which users nagivate "Back" in your application.</p>
<p>As an aside, it’s worth pointing out that, quite likely, there will be many
states in your application that you don’t want represented by a route - modes
in your application that users don’t really care about returning exactly to, or
where the cost of building the code that reconstructs the state is too
expensive to justify it.  For example, you may have a tabbed navigation,
expandable information panes, modal dialog boxes, or resizable display ports
that all go untracked by routes.</p>
<p>Anecdotally, one recent client application we developed has around 100 Backbone
view classes, but fewer than twenty routes.  Additionally, many of the view
classes are displayed in parallel and have multiple internal states of their own,
providing for far more than 100 different interfaces states.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>Backbone now includes support for pushState, which can use real, full URLs
instead of url fragments for routing.</p>
<p>However, pushState support in Backbone is fully opt-in due to lack of
browser support and that additional server-side work is required to support it.</p>
<p>pushState support is current limited to the latest versions of Firefox,
Chrome, and Safari and Mobile Safari. For a full listing of support and more
information about the History API, of which pushState is a part, visit
<a class="ulink" href="http://diveintohtml5.info/history.html#how" target="_top">http://diveintohtml5.info/history.html#how</a></p>
<p>Thankfully, if you opt-in to pushState in Backbone, browsers that don’t
support pushState will continue to use hash-based URL fragments, and if a hash
URL is visited by a pushState-capable browser, it will be transparently
upgraded to the true URL.</p>
<p>In addition to browser support, another hurdle to seamless use of pushState is
that because the URL used are real URLs, your server must know how to render
each of the URLs. For example, if your Backbone application has a route of
<code class="literal">/tasks/1</code>, your server-side application must be able to respond to that page if
the browser visits that URL directly.</p>
<p>For most applications, you can handle this by just rendering the content you
would have for the root URL and letting Backbone handle the rest of the
routing to the proper location. But for full search-engine crawlability, your
server-side application will need to render the entire HTML of the requested page.</p>
<p>For all the reasons and complications above, the examples in this book all
currently use URL fragments and not pushState.</p>
</div>
<p>A typical Backbone router will appear as shown below.</p>
<pre class="programlisting">ExampleApp.Routers.ExampleRouter = Backbone.Router.extend({
  routes: {
    <b class="hl-string"><i style="color:red">""</i></b>         : <b class="hl-string"><i style="color:red">"index"</i></b>
    <b class="hl-string"><i style="color:red">"show/:id"</i></b> : <b class="hl-string"><i style="color:red">"show"</i></b>
  },

  index: <b class="hl-keyword">function</b>() {
    <i class="hl-comment" style="color: silver">// Instantiate and render the index view</i>
  }

  show: <b class="hl-keyword">function</b>(id) {
    <i class="hl-comment" style="color: silver">// Instantiate and render the show view</i>
  }
});</pre>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_the_routes_hash"></a>The Routes Hash</h4></div></div></div>
<p>The basic router consists of a routes hash which is a mapping between URL
fragments and methods on the router. If the current URL fragment, or one that
is being visited matches one of the routes in the hash, its method will be
called.</p>
<p>Like Rails routes, Backbone routes can contain parameter parts, as seen in
the <code class="literal">show</code> route in the example above. In this route, the part of the fragment
after <code class="literal">show/</code> will then be based as an argument to the <code class="literal">show</code> method.</p>
<p>Multiple parameters are possible, as well. For example, a route of
<code class="literal">search/:query/p:page</code> will match a fragment of <code class="literal">search/completed/p2</code> passing
<code class="literal">completed</code> and <code class="literal">2</code> to the action.</p>
<p>In the routes, <code class="literal">/</code> is the natural separator. For example, a route of
<code class="literal">show/:id</code> will not match a fragment of <code class="literal">show/1/2</code>. To allow you to match
fragments like this, Backbone provides the concept of splat parts,
identified by <code class="literal">*</code> instead of <code class="literal">:</code>. For example, a route of <code class="literal">show/*id</code> would
match the previous fragment, and <code class="literal">1/2</code> would be passed to the action as the
<code class="literal">id</code> variable.</p>
<p>Routing occurs when the browser’s URL changes. This can occur when a link is clicked,
when a URL is entered into the browser’s URL bar, or when the back button is clicked.
In all of those cases, Backbone will look to see if the new URL fragment
matches an existing route. If it does, the specified function will be called
with any parameters extracted from the URL fragment.</p>
<p>In addition, an event with the name of "route" and the function will be
triggered. For example, when the router’s <code class="literal">show</code> function above is triggered, an event of
<code class="literal">route:show</code> will be fired. This is so that other objects can listen to the
router, and be notified when the router responds to certain routes.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_initializing_a_router"></a>Initializing a Router</h4></div></div></div>
<p>It is possible to specify an <code class="literal">initialize</code> function in a Router which will be
called when the Router is instantiated. Any arguments passed to the router’s
constructor will be passed to this <code class="literal">initialize</code> function.</p>
<p>Additionally, it is possible to pass the routes for a router via the
constructor like <code class="literal">new ExampleRouter({ routes: { "" : "index" }}</code>. But note
that this will override any routes defined in the routes hash on the router
itself.</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_event_binding"></a>Event binding</h3></div></div></div>
<p>A big part of writing snappy rich client applications is building models and
views that update in real-time with respect to one another. With Backbone
you accomplish this with events.</p>
<p>Client-side applications are asynchronous by nature. At the heart of a Backbone
application lie events binding and triggering. Your application is written
using event-driven programming where components emit and handle events,
achieving non-blocking UIs.</p>
<p>With Backbone, it’s very easy to write such applications. Backbone provides
the <code class="literal">Backbone.Events</code> mixin, which can be included in any other class.</p>
<p>Here’s a quick example of a very simple game engine, where things happen in the
system and an event is triggered, which in turn invokes any event handlers that
are bound to that event.</p>
<pre class="programlisting"><b class="hl-keyword">var</b> gameEngine = {};
_.extend(gameEngine, Backbone.Events);

gameEngine.on(<b class="hl-string"><i style="color:red">"user_registered"</i></b>, <b class="hl-keyword">function</b>(user) {
  user.points += <span class="hl-number">10</span>
});

gameEngine.trigger(<b class="hl-string"><i style="color:red">"user_registered"</i></b>, User.<b class="hl-keyword">new</b>({ points: <span class="hl-number">0</span> }));</pre>
<p>In the example above, <code class="literal">on</code> subscribes the gameEngine to listen for the
"user_registered" event, and then <code class="literal">trigger</code> broadcasts that event to all
subscribed listeners, which invokes the function that adds points to the user.
Any arguments passed to <code class="literal">trigger</code> after the name of the event are in turn
passed to the event handler.  So in this case the output of <code class="literal">User.new()</code> is
received as <code class="literal">user</code> in the handler.</p>
<p><code class="literal">Backbone.Views</code>, <code class="literal">Backbone.Model</code> and <code class="literal">Backbone.Collection</code> are all extended
with <code class="literal">Backbone.Events</code>. There are some events that are triggered by Backbone at
particular convenient moments. These are common events that many user interface
flows need to react to.  For example, when a Backbone model’s attributes are
changed, that model will trigger the <code class="literal">change</code> event. It is still up to you to
bind a handler on those events.  More on that later.</p>
<p>As you can see from the example though, it is possible to bind and trigger
arbitrary events on any object that extends <code class="literal">Backbone.Events</code>. Additionally,
if an event handler should always trigger regardless of which event got fired,
you can bind to the special <code class="literal">all</code> event.</p>
<p>There are three primary kinds of events that your views will bind to:</p>
<div class="itemizedlist"><ul type="disc">
<li>
DOM events within the view’s <code class="literal">this.el</code> element
</li>
<li>
Events triggered by closely associated objects, such as the view’s model or
collection
</li>
<li>
Events your view itself publishes
</li>
</ul></div>
<p>Event bindings declared on your view will need to be cleaned when your view is
disposed of. Events that your view publishes will need to be handled a
different way. Each of these three categories of events is discussed in more
detail below.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_binding_to_dom_events_within_the_view_element"></a>Binding to DOM events within the view element</h4></div></div></div>
<p>The primary function of a view class is to provide behavior for its markup’s
DOM elements. You can attach event listeners by hand if you like:</p>
<pre class="programlisting"><i class="hl-comment" style="color: silver">&lt;!-- templates/soundboard.jst --&gt;</i>
<b class="hl-tag" style="color: #000096">&lt;a</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"sound"</span><b class="hl-tag" style="color: #000096">&gt;</b>Honk<b class="hl-tag" style="color: #000096">&lt;/a&gt;</b>
<b class="hl-tag" style="color: #000096">&lt;a</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"sound"</span><b class="hl-tag" style="color: #000096">&gt;</b>Beep<b class="hl-tag" style="color: #000096">&lt;/a&gt;</b></pre>
<pre class="programlisting"><b class="hl-keyword">var</b> SoundBoard = Backbone.View.extend({
  render: <b class="hl-keyword">function</b>() {
    $(<b class="hl-keyword">this</b>.el).html(JST[<b class="hl-string"><i style="color:red">'soundboard'</i></b>]());
    <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">"a.sound"</i></b>).bind(<b class="hl-string"><i style="color:red">"click"</i></b>, <b class="hl-keyword">this</b>.playSound);
  },

  playSound: <b class="hl-keyword">function</b>() {
    <i class="hl-comment" style="color: silver">// play sound for this element</i>
  }
});</pre>
<p>But Backbone provides an easier and more declarative approach with the <code class="literal">events</code> hash:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> SoundBoard = Backbone.View.extend({
  events: {
    <b class="hl-string"><i style="color:red">"click a.sound"</i></b>: <b class="hl-string"><i style="color:red">"playSound"</i></b>
  },

  render: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.$el.html(JST[<b class="hl-string"><i style="color:red">'soundboard'</i></b>]());
  },

  playSound: <b class="hl-keyword">function</b>() {
    <i class="hl-comment" style="color: silver">// play sound for this element</i>
  }
});</pre>
<p>Backbone will bind the events with the
<a class="ulink" href="http://documentcloud.github.com/backbone/#View-delegateEvents" target="_top">Backbone.View.prototype.delegateEvents()</a>
function.  It binds DOM events with <code class="literal">$.delegate()</code>, whether you’re using the
<a class="ulink" href="http://api.jquery.com/delegate/" target="_top">jQuery</a> or
<a class="ulink" href="https://github.com/madrobby/zepto/blob/v0.7/src/event.js#L96-108" target="_top">Zepto</a>
<code class="literal">.delegate()</code> function.</p>
<p>It also takes care of binding the event handlers' <code class="literal">this</code> to the view instance
using <code class="literal">_.on()</code>.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_events_observed_by_your_view"></a>Events Observed by Your View</h4></div></div></div>
<p>In almost every view you write, the view will be bound to a <code class="literal">Backbone.Model</code> or
a <code class="literal">Backbone.Collection</code>, most often with the convenience properties <code class="literal">this.model</code>
or <code class="literal">this.collection</code>.</p>
<p>Consider a view that displays a collection of <code class="literal">Task</code> models. It will re-render
itself when any model in the collection is changed or removed, or when a new
model is added:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> TasksIndexView = Backbone.View.extend({
  template: JST[<b class="hl-string"><i style="color:red">'tasks/tasks_index'</i></b>],
  tagName: <b class="hl-string"><i style="color:red">'section'</i></b>,
  id: <b class="hl-string"><i style="color:red">'tasks'</i></b>,

  initialize: <b class="hl-keyword">function</b>() {
    _.bindAll(<b class="hl-keyword">this</b>, <b class="hl-string"><i style="color:red">"render"</i></b>);

    <b class="hl-keyword">this</b>.collection.bind(<b class="hl-string"><i style="color:red">"change"</i></b>, <b class="hl-keyword">this</b>.render);
    <b class="hl-keyword">this</b>.collection.bind(<b class="hl-string"><i style="color:red">"add"</i></b>,    <b class="hl-keyword">this</b>.render);
    <b class="hl-keyword">this</b>.collection.bind(<b class="hl-string"><i style="color:red">"remove"</i></b>, <b class="hl-keyword">this</b>.render);
  },

  render: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.$el.html(<b class="hl-keyword">this</b>.template({tasks: <b class="hl-keyword">this</b>.collection}));
  }
});</pre>
<p>Note how we bind to the collection’s <code class="literal">change</code>, <code class="literal">add</code> and <code class="literal">remove</code> events.
The <code class="literal">add</code> and <code class="literal">remove</code> events are triggered when you either <code class="literal">add()</code> or <code class="literal">remove()</code>
a model from that collection as expected. The <code class="literal">change</code> event requires special
mention; it will trigger when any of the underlying models' <code class="literal">change</code> event triggers.
Backbone just bubbles up that event to the containing collection for convenience.</p>
<p>While the most common view bindings will be to events from its associated
models and collections, your view can bind to any events to which it wants to
listen.  The life-cycle for the binding and unbinding, and the handling of
these events will be the same as those for Model and Collections.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_events_your_view_publishes"></a>Events Your View Publishes</h4></div></div></div>
<p>With sufficiently complex views, you may encounter a situation where you want
one view to change in response to another.</p>
<p>This can be accomplished with events. Your view can trigger an event to which
the other view has bindings.</p>
<p>Consider a simple example with a table of users and a toggle control that
filters the users to a particular gender:</p>
<pre class="programlisting">GenderPicker = Backbone.View.extend({
  render: {
    <i class="hl-comment" style="color: silver">// render template</i>
  },
  events: {
    <b class="hl-string"><i style="color:red">"click .show-male"</i></b>:   <b class="hl-string"><i style="color:red">"showMale"</i></b>,
    <b class="hl-string"><i style="color:red">"click .show-female"</i></b>: <b class="hl-string"><i style="color:red">"showFemale"</i></b>,
    <b class="hl-string"><i style="color:red">"click .show-both"</i></b>:   <b class="hl-string"><i style="color:red">"showBoth"</i></b>
  },

  showMale: <b class="hl-keyword">function</b>()   { <b class="hl-keyword">this</b>.trigger(<b class="hl-string"><i style="color:red">"changed"</i></b>, <b class="hl-string"><i style="color:red">"male"</i></b>);   },
  showFemale: <b class="hl-keyword">function</b>() { <b class="hl-keyword">this</b>.trigger(<b class="hl-string"><i style="color:red">"changed"</i></b>, <b class="hl-string"><i style="color:red">"female"</i></b>); },
  showBoth: <b class="hl-keyword">function</b>()   { <b class="hl-keyword">this</b>.trigger(<b class="hl-string"><i style="color:red">"changed"</i></b>, <b class="hl-string"><i style="color:red">"both"</i></b>);   }
});

UsersTable = Backbone.View.extend({
  initialize: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.genderPicker = <b class="hl-keyword">new</b> GenderPicker();
    <b class="hl-keyword">this</b>.genderPicker.on(<b class="hl-string"><i style="color:red">"changed"</i></b>, <b class="hl-keyword">this</b>.filterByGender);
    <b class="hl-keyword">this</b>.collectionToRender = <b class="hl-keyword">this</b>.collection;
    <b class="hl-keyword">this</b>.render();
  },

  render: {
    <b class="hl-keyword">this</b>.genderPicker.render();
    <b class="hl-keyword">this</b>.$el.html(JST[<b class="hl-string"><i style="color:red">'users'</i></b>]({ users: <b class="hl-keyword">this</b>.collectionToRender }));
  }

  filterByGender: <b class="hl-keyword">function</b>(gender) {
    <b class="hl-keyword">this</b>.collectionToRender = <b class="hl-keyword">this</b>.collection.byGender(gender);
    <b class="hl-keyword">this</b>.render();
  }
});</pre>
<p>In the above snippet, the <code class="literal">GenderPicker</code> is responsible for the filter
control. When a the appropriate elements are clicked, a custom <code class="literal">changed</code> event
is triggered on itself. Note how it is also possible to pass arbitrary
parameters to the <code class="literal">trigger()</code> function.</p>
<p>On the other hand, we have a <code class="literal">UsersTable</code> which is responsible for
rendering a collection of users. It also observes this event via the call to
<code class="literal">on()</code>, where it invokes the <code class="literal">filterByGender</code> function.</p>
<p>While your views will generally bind to events on models and collections, a
situation like the above may arise where it is handy to trigger and bind to
custom events at the view layer. However, it’s always a good idea to step
back and think through whether you should instead be binding to events on the
underlying components.</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_cleaning_up_unbinding"></a>Cleaning Up: Unbinding</h3></div></div></div>
<p>In the last section, we discussed three different kinds of event binding in
your <code class="literal">Backbone.Views</code> classes: DOM events, model/collection events, and custom
view events.  Next we’ll discuss unbinding these events: why it’s a good idea,
and how to do it.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_why_unbind_events"></a>Why unbind events?</h4></div></div></div>
<p>Consider two views in a Todo app: an index view which contains all the tasks
that need to be done:</p>
<div class="figure">
<a id="d0e1738"></a><p class="title"><b>Figure 2. Tasks index view</b></p>
<div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="65%"><tr><td align="center"><img src="views_and_templates/tasks-index.png" align="middle" width="100%" alt="views_and_templates/tasks-index.png"></td></tr></table></div></div>
</div>
<br class="figure-break"><p>and a detail view that shows detail on one task:</p>
<div class="figure">
<a id="d0e1749"></a><p class="title"><b>Figure 3. Tasks detail view</b></p>
<div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="65%"><tr><td align="center"><img src="views_and_templates/task-detail.png" align="middle" width="100%" alt="views_and_templates/task-detail.png"></td></tr></table></div></div>
</div>
<br class="figure-break"><p>The interface switches between the two views.</p>
<p>Here’s the source for the aggregate index view:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> TasksIndexView = Backbone.View.extend({
  template: JST[<b class="hl-string"><i style="color:red">'tasks/tasks_index'</i></b>],
  tagName: <b class="hl-string"><i style="color:red">'section'</i></b>,
  id: <b class="hl-string"><i style="color:red">'tasks'</i></b>,

  initialize: <b class="hl-keyword">function</b>() {
    _.bindAll(<b class="hl-keyword">this</b>, <b class="hl-string"><i style="color:red">"render"</i></b>);

    <b class="hl-keyword">this</b>.collection.bind(<b class="hl-string"><i style="color:red">"change"</i></b>, <b class="hl-keyword">this</b>.render);
    <b class="hl-keyword">this</b>.collection.bind(<b class="hl-string"><i style="color:red">"add"</i></b>,    <b class="hl-keyword">this</b>.render);
    <b class="hl-keyword">this</b>.collection.bind(<b class="hl-string"><i style="color:red">"remove"</i></b>, <b class="hl-keyword">this</b>.render);
  },

  render: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.$el.html(<b class="hl-keyword">this</b>.template({tasks: <b class="hl-keyword">this</b>.collection}));
  }
});</pre>
<p>and the source for the individual task detail view:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> TaskDetail = Backbone.View.extend({
  template: JST[<b class="hl-string"><i style="color:red">'tasks/task_detail'</i></b>],
  tagName: <b class="hl-string"><i style="color:red">'section'</i></b>,
  id: <b class="hl-string"><i style="color:red">'task'</i></b>,

  events: {
    <b class="hl-string"><i style="color:red">"click .comments .form-inputs button"</i></b>: <b class="hl-string"><i style="color:red">"createComment"</i></b>
  },

  initialize: <b class="hl-keyword">function</b>() {
    _.bindAll(<b class="hl-keyword">this</b>, <b class="hl-string"><i style="color:red">"render"</i></b>);

    <b class="hl-keyword">this</b>.model.on(<b class="hl-string"><i style="color:red">"change"</i></b>, <b class="hl-keyword">this</b>.render);
    <b class="hl-keyword">this</b>.model.comments.on(<b class="hl-string"><i style="color:red">"change"</i></b>, <b class="hl-keyword">this</b>.render);
    <b class="hl-keyword">this</b>.model.comments.on(<b class="hl-string"><i style="color:red">"add"</i></b>,    <b class="hl-keyword">this</b>.render);
  },

  render: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.$el.html(<b class="hl-keyword">this</b>.template({task: <b class="hl-keyword">this</b>.model}));
  },

  createComment: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> comment = <b class="hl-keyword">new</b> Comment({ text: <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'.new-comment-input'</i></b>).val() });
    <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'.new-comment-input'</i></b>).val(<b class="hl-string"><i style="color:red">''</i></b>);
    <b class="hl-keyword">this</b>.model.comments.create(comment);
  }
});</pre>
<p>Each task on the index page links to the detail view for itself. When a user
follows one of these links and navigates from the index page to the detail
page, then interacts with the detail view to change a model, the <code class="literal">change</code> event
on the <code class="literal">TaskApp.tasks</code> collection is fired. One consequence of this is that
the index view, which is still bound and observing the <code class="literal">change</code> event, will
re-render itself.</p>
<p>This is both a functional bug and a memory leak: not only will the index view
re-render and disrupt the detail display momentarily, but navigating back and
forth between the views without disposing of the previous view will keep
creating more views and binding more events on the associated models or
collections.</p>
<p>These can be extremely tricky to track down on a production application,
especially if you are nesting child views. Sadly, there’s no "garbage
collection" for views in Backbone, so your application needs to manage this
itself.  Luckily, it’s not too hard to keep track of and correctly maintain our
bindings.</p>
<p>Let’s take a look at how to unbind three kinds of events: DOM events, model
and collection events, and events you trigger in your views.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_unbinding_dom_events"></a>Unbinding DOM events</h4></div></div></div>
<p>DOM events are the simple case - they more or less get cleaned up for you.
When you call <code class="literal">this.remove()</code> in your view, it delegates to <code class="literal">jQuery.remove()</code>
by invoking <code class="literal">$(this.el).remove()</code>.  This means that jQuery takes care of
cleaning up any events bound on DOM elements within your view, regardless of
whether you bound them with the Backbone <code class="literal">events</code> hash or by hand; for example,
with <code class="literal">$.bind()</code>, <code class="literal">$.delegate()</code>, <code class="literal">live()</code> or <code class="literal">$.on()</code>.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_unbinding_model_and_collection_events"></a>Unbinding model and collection events</h4></div></div></div>
<p>If your view binds to events on a model or collection with <code class="literal">on()</code>, you are
responsible for unbinding these events.  You do this with a simple call to
<code class="literal">this.model.off()</code> or <code class="literal">this.collection.off()</code>; the
<a class="ulink" href="http://documentcloud.github.com/backbone/#Events-off" target="_top"><code class="literal">Backbone.Events.off()</code>
function</a> removes all callbacks on that object.</p>
<p>When should we unbind these handlers?  Whenever the view is going away.  This
means that any pieces of code that create new instances of this view become
responsible for cleaning up after it’s gone. That isn’t a very cohesive
approach, so let’s include the cleanup responsibility on the view itself.</p>
<p>Let’s write a <code class="literal">leave()</code> function on our view that wraps <code class="literal">remove()</code> and handles
any additional event unbinding we need to do.  As a convention, when we use
this view elsewhere, we’ll call <code class="literal">leave()</code> instead of <code class="literal">remove()</code> when we’re
done:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> SomeCollectionView = Backbone.View.extend({
  <i class="hl-comment" style="color: silver">// snip...</i>

  initialize: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.collection.bind(<b class="hl-string"><i style="color:red">"change"</i></b>, <b class="hl-keyword">this</b>.render);
  },

  leave: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.collection.unbind(<b class="hl-string"><i style="color:red">"change"</i></b>, <b class="hl-keyword">this</b>.render);
    <b class="hl-keyword">this</b>.remove();
  }

  <i class="hl-comment" style="color: silver">// snip...</i>
});</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_keep_track_of_literal_on_literal_calls_to_unbind_more_easily"></a>Keep track of <code class="literal">on()</code> calls to unbind more easily</h4></div></div></div>
<p>In the example above, unbinding the collection change event isn’t too much
hassle; since we’re only observing one thing, we only have to unbind one
thing.  But even the addition of one line to <code class="literal">leave()</code> is easy to forget, and
if you bind to multiple events then it only gets more verbose.</p>
<p>Let’s add a step of indirection in event binding so that we can automatically
clean up all the events with one call.  We’ll add and use a <code class="literal">bindTo()</code>
function that keeps track of all the event handlers we bind, and then issue a
single call to <code class="literal">unbindFromAll()</code> to unbind them:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> SomeCollectionView = Backbone.View.extend({
  initialize: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.bindings = [];
    <b class="hl-keyword">this</b>.bindTo(<b class="hl-keyword">this</b>.collection, <b class="hl-string"><i style="color:red">"change"</i></b>, <b class="hl-keyword">this</b>.render);
  },

  leave: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.unbindFromAll();
    <b class="hl-keyword">this</b>.remove();
  },

  bindTo: <b class="hl-keyword">function</b>(source, event, callback) {
    source.on(event, callback, <b class="hl-keyword">this</b>);
    <b class="hl-keyword">this</b>.bindings.push({ source: source, event: event, callback: callback });
  },

  unbindFromAll: <b class="hl-keyword">function</b>() {
    _.each(<b class="hl-keyword">this</b>.bindings, <b class="hl-keyword">function</b>(binding) {
      binding.source.off(binding.event, binding.callback);
    });
    <b class="hl-keyword">this</b>.bindings = [];
  }
});</pre>
<p>These functions, <code class="literal">bindTo()</code> and <code class="literal">unbindFromAll()</code>, can be extracted into a
reusable mixin or superclass.  Then, we just have to use <code class="literal">bindTo()</code> instead of
<code class="literal">model.on()</code> and be assured that the handlers will be cleaned up during
<code class="literal">leave()</code>.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_unbinding_view_triggered_events"></a>Unbinding view-triggered events</h4></div></div></div>
<p>With the first two kinds of event binding that we discussed, DOM and
model/collection, the view is the observer.  The responsibility to clean up is
on the observer, and here the responsibility consists of unbinding the event
handler when the view is being removed.</p>
<p>But other times, our view classes will trigger (emit) events of their own.  In
this case, other objects are the observer, and are responsible for cleaning up
the event binding when they are disposed.  See "Events Your View Publishes" in
the earlier "Event Binding" section for more details.</p>
<p>However, additionally, when the view itself is disposed of with <code class="literal">leave()</code>, it
should clean up any event handlers bound on <span class="strong"><strong>itself</strong></span> for events that it
triggers.</p>
<p>This is handled by invoking <code class="literal">Backbone.Events.off()</code>:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> FilteringView = Backbone.View.extend({
  <i class="hl-comment" style="color: silver">// snip...</i>

  events: {
    <b class="hl-string"><i style="color:red">"click a.filter"</i></b>: <b class="hl-string"><i style="color:red">"changeFilter"</i></b>
  },

  changeFilter: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">if</b> (someLogic()) {
      <b class="hl-keyword">this</b>.trigger(<b class="hl-string"><i style="color:red">"filtered"</i></b>, { some: options });
    }
  },

  leave: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.off(); <i class="hl-comment" style="color: silver">// Clean up any event handlers bound on this view</i>
    <b class="hl-keyword">this</b>.remove();
  }

  <i class="hl-comment" style="color: silver">// snip...</i>
});</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_establish_a_convention_for_consistent_and_correct_unbinding"></a>Establish a convention for consistent and correct unbinding</h4></div></div></div>
<p>There’s no built-in garbage collection for Backbone’s event bindings, and
forgetting to unbind can cause bugs and memory leaks. The solution is to make
sure you unbind events and remove views when you leave them. Our approach to
this is two-fold: write a set of reusable functions that manage cleaning up a
view’s bindings, and use these functions whereever views are instantiated: in
<code class="literal">Router</code> instances, and in composite views.  We’ll take a look at these
concrete, reusable approaches in the next two sections about <code class="literal">SwappingRouter</code>
and <code class="literal">CompositeView</code>.</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_swapping_router"></a>Swapping router</h3></div></div></div>
<p>When switching from one view to another, we should clean up the previous view.
We discussed previously a convention of writing a <code class="literal">view.leave()</code>
Let’s augment our view to include the ability to clean itself up by "leaving"
the DOM:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> MyView = Backbone.View.extend({
  <i class="hl-comment" style="color: silver">// ...</i>

  leave: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.off();
    <b class="hl-keyword">this</b>.remove();
  },

  <i class="hl-comment" style="color: silver">// ...</i>
});</pre>
<p>The <code class="literal">off()</code> and <code class="literal">remove()</code> functions are provided by <code class="literal">Backbone.Events</code> and
<code class="literal">Backbone.View</code> respectively. <code class="literal">Backbone.Events.off()</code> will remove all
callbacks registered on the view, and <code class="literal">remove()</code> will remove the view’s
element from the DOM, equivalent to calling <code class="literal">this.$el.remove()</code>.</p>
<p>In simple cases, we replace one full page view with another full page (less any
shared layout). We introduce a convention that all actions underneath one
<code class="literal">Router</code> share the same root element, and define it as <code class="literal">el</code> on the router.</p>
<p>Now, a <code class="literal">SwappingRouter</code> can take advantage of the <code class="literal">leave()</code> function, and clean
up any existing views before swapping to a new one.  It swaps into a new view by
rendering that view into its own <code class="literal">el</code>:</p>
<pre class="programlisting">Support.SwappingRouter = <b class="hl-keyword">function</b>(options) {
  Backbone.Router.apply(<b class="hl-keyword">this</b>, [options]);
};

_.extend(Support.SwappingRouter.<b class="hl-keyword">prototype</b>, Backbone.Router.<b class="hl-keyword">prototype</b>, {
  swap: <b class="hl-keyword">function</b>(newView) {
    <b class="hl-keyword">if</b> (<b class="hl-keyword">this</b>.currentView &amp;&amp; <b class="hl-keyword">this</b>.currentView.leave) {
      <b class="hl-keyword">this</b>.currentView.leave();
    }

    <b class="hl-keyword">this</b>.currentView = newView;
    <b class="hl-keyword">this</b>.currentView.render();
    $(<b class="hl-keyword">this</b>.el).empty().append(<b class="hl-keyword">this</b>.currentView.el);
  }
});

Support.SwappingRouter.extend = Backbone.Router.extend;</pre>
<p>Now all you need to do in a route function is call <code class="literal">swap()</code>, passing in the
new view that should be rendered. The <code class="literal">swap()</code> function’s job is to call
<code class="literal">leave()</code> on the current view, render the new view appending it to the
router’s <code class="literal">el</code>, and finally store who the current view is, so that next time
<code class="literal">swap()</code> is invoked, it can be properly cleaned up as well.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="swapping-internals"></a>SwappingRouter and Backbone internals</h4></div></div></div>
<p>If the code for <code class="literal">SwappingRouter</code> seems a little confusing, don’t fret: it is,
thanks to JavaScript’s object model! Sadly, it’s not as simple to just drop in
the <code class="literal">swap</code> method into <code class="literal">Backbone.Router</code>, or call <code class="literal">Backbone.Router.extend</code> to
mixin the function we need.</p>
<p>Our goal here is essentially to create a subclass of <code class="literal">Backbone.Router</code>, and to
extend it without modifying the original class. This gives us a few benefits:
first, <code class="literal">SwappingRouter</code> should work with Backbone upgrades. Second, it should be
<span class="strong"><strong>obvious</strong></span> and <span class="strong"><strong>intention-revealing</strong></span> when a controller needs to swap views. If
we chose to just mix in a <code class="literal">swap</code> method, and called it from a direct descendant
of <code class="literal">Backbone.Router</code>, an unaware (and unlucky) programmer now needs to go on a
deep source dive in an attempt to figure out where that’s coming from. At least
with a subclass, the hunt should start at the file where it was defined.</p>
<p>The procedure used to create <code class="literal">SwappingRouter</code> is onerous thanks to a mix of
Backbone-isms and just how clunky inheritance is in JavaScript. First off, we
need to define the constructor, which delegates to the <code class="literal">Backbone.Router</code>
constructor with the use of <code class="literal">Function#apply</code>. The next block of code uses
Underscore’s <code class="literal">Object#extend</code> to create the set of functions and properties that
will become <code class="literal">SwappingRouter</code>. The <code class="literal">extend</code> function takes a destination, in
this case the empty prototype for <code class="literal">SwappingRouter</code>, and copies in the
properties in the <code class="literal">Backbone.Router</code> prototype along with our new custom object
that includes the <code class="literal">swap</code> function.</p>
<p>Finally, the subclass cake is topped off with some Backbone frosting: setting
<code class="literal">extend</code>, which is a self-propagating function that all Backbone public classes
use. Let’s take a quick look at this function, as of Backbone 0.5.3:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> extend = <b class="hl-keyword">function</b> (protoProps, classProps) {
  <b class="hl-keyword">var</b> child = inherits(<b class="hl-keyword">this</b>, protoProps, classProps);
  child.extend = <b class="hl-keyword">this</b>.extend;
  <b class="hl-keyword">return</b> child;
};

<i class="hl-comment" style="color: silver">// Helper function to correctly set up the prototype chain, for subclasses.</i>
<i class="hl-comment" style="color: silver">// Similar to `goog.inherits`, but uses a hash of prototype properties and</i>
<i class="hl-comment" style="color: silver">// class properties to be extended.</i>
<b class="hl-keyword">var</b> inherits = <b class="hl-keyword">function</b>(parent, protoProps, staticProps) {
  <i class="hl-comment" style="color: silver">// sparing our readers the internals of this function... for a deep dive</i>
  <i class="hl-comment" style="color: silver">// into the dark realms of JavaScript's prototype system, read the source!</i>
}</pre>
<p>So, it’s a function that calls <code class="literal">inherits</code> to make a new subclass.  The comments
reference <code class="literal">goog.inherits</code> from Google’s Closure Library, which contains similar
utility functions to allow more class-style inheritance.</p>
<p>The end result here is that whenever you make a custom controller, internally
in Backbone, you’re making <span class="strong"><strong>another</strong></span> subclass. The inheritance chain for
<code class="literal">TasksRouter</code> would then look like:</p>
<div class="figure">
<a id="d0e2085"></a><p class="title"><b>Figure 4. Router class inheritance</b></p>
<div class="figure-contents"><div class="mediaobject" align="center"><img src="views_and_templates/router-diagram.png" align="middle" height="200" alt="views_and_templates/router-diagram.png"></div></div>
</div>
<br class="figure-break"><p>Phew! Hopefully this adventure into Backbone and JavaScript internals has
taught you that although it’s more code, it’s hopefully going to save time down
the road for those maintaining your code.</p>
<p>You can find an example of a <code class="literal">SwappingRouter</code> on the example app under
<code class="literal">app/assets/javascripts/routers/tasks.js</code>. Note how each of the actions
in that Router use <code class="literal">SwappingRouter.swap()</code> to invoke rendering of views,
freeing itself from the complexities of cleaning them up.</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_composite_views"></a>Composite views</h3></div></div></div>
<p>The <code class="literal">SwappingRouter</code> above calls <code class="literal">leave()</code> on the view it currently holds.
This function is not part of Backbone itself, and is part of our extension
library to help make views more modular and maintainable. This section goes
over the Composite View pattern, the <code class="literal">CompositeView</code> class itself, and some
concerns to keep in mind while creating your views.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_refactoring_from_a_large_view"></a>Refactoring from a large view</h4></div></div></div>
<p>One of the first refactorings you find yourself doing in a non-trivial Backbone
app is splitting up large views into composable parts. Let’s take another look
at the <code class="literal">TaskDetail</code> source code from the beginning of this section:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> TaskDetail = Backbone.View.extend({
  template: JST[<b class="hl-string"><i style="color:red">'tasks/task_detail'</i></b>],
  tagName: <b class="hl-string"><i style="color:red">'section'</i></b>,
  id: <b class="hl-string"><i style="color:red">'task'</i></b>,

  events: {
    <b class="hl-string"><i style="color:red">"click .comments .form-inputs button"</i></b>: <b class="hl-string"><i style="color:red">"createComment"</i></b>
  },

  initialize: <b class="hl-keyword">function</b>() {
    _.bindAll(<b class="hl-keyword">this</b>, <b class="hl-string"><i style="color:red">"render"</i></b>);

    <b class="hl-keyword">this</b>.model.on(<b class="hl-string"><i style="color:red">"change"</i></b>, <b class="hl-keyword">this</b>.render);
    <b class="hl-keyword">this</b>.model.comments.on(<b class="hl-string"><i style="color:red">"change"</i></b>, <b class="hl-keyword">this</b>.render);
    <b class="hl-keyword">this</b>.model.comments.on(<b class="hl-string"><i style="color:red">"add"</i></b>,    <b class="hl-keyword">this</b>.render);
  },

  render: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.$el.html(<b class="hl-keyword">this</b>.template({task: <b class="hl-keyword">this</b>.model}));
  },

  createComment: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> comment = <b class="hl-keyword">new</b> Comment({ text: <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'.new-comment-input'</i></b>).val() });
    <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'.new-comment-input'</i></b>).val(<b class="hl-string"><i style="color:red">''</i></b>);
    <b class="hl-keyword">this</b>.model.comments.create(comment);
  }
});</pre>
<p>The view class references a template, which renders out the HTML for this page:</p>
<pre class="programlisting">include::task_detail.html.jst</pre>
<p>There are clearly several concerns going on here: rendering the task, rendering
the comments that folks have left, and rendering the form to create new
comments. Let’s separate those concerns. A first approach might be to just
break up the template files:</p>
<pre class="programlisting"><i class="hl-comment" style="color: silver">&lt;!-- tasks/show.jst --&gt;</i>
<b class="hl-tag" style="color: #000096">&lt;section</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"task-details"</span><b class="hl-tag" style="color: #000096">&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;%=</b> <span class="hl-attribute" style="color: #F5844C">JST['tasks/details']({</span> <span class="hl-attribute" style="color: #F5844C">task:</span> <span class="hl-attribute" style="color: #F5844C">task</span> <span class="hl-attribute" style="color: #F5844C">})</span> <span class="hl-attribute" style="color: #F5844C">%&gt;</span>
<span class="hl-attribute" style="color: #F5844C">&lt;/section&gt;</span>

<span class="hl-attribute" style="color: #F5844C">&lt;section</span> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"comments"</span><b class="hl-tag" style="color: #000096">&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;%=</b> <span class="hl-attribute" style="color: #F5844C">JST['comments/list']({</span> <span class="hl-attribute" style="color: #F5844C">task:</span> <span class="hl-attribute" style="color: #F5844C">task</span> <span class="hl-attribute" style="color: #F5844C">})</span> <span class="hl-attribute" style="color: #F5844C">%&gt;</span>
<span class="hl-attribute" style="color: #F5844C">&lt;/section&gt;</span></pre>
<pre class="programlisting"><i class="hl-comment" style="color: silver">&lt;!-- tasks/details.jst --&gt;</i>
<b class="hl-tag" style="color: #000096">&lt;input</b> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"checkbox"</span><span class="hl-attribute" style="color: #F5844C">&lt;%</span>= <span class="hl-value" style="color: #993300">task.isComplete()</span> <span class="hl-attribute" style="color: #F5844C">?</span> <span class="hl-attribute" style="color: #F5844C">'</span> <span class="hl-attribute" style="color: #F5844C">checked</span>=<span class="hl-value" style="color: #993300">"checked"</span><span class="hl-attribute" style="color: #F5844C">'</span> <span class="hl-attribute" style="color: #F5844C">:</span> <span class="hl-attribute" style="color: #F5844C">''</span> <span class="hl-attribute" style="color: #F5844C">%&gt;</span><b class="hl-tag" style="color: #000096"> /&gt;</b>
<b class="hl-tag" style="color: #000096">&lt;h2&gt;</b><b class="hl-tag" style="color: #000096">&lt;%=</b> <span class="hl-attribute" style="color: #F5844C">task.escape("title")</span> <span class="hl-attribute" style="color: #F5844C">%&gt;&lt;/h2&gt;</span></pre>
<pre class="programlisting"><i class="hl-comment" style="color: silver">&lt;!-- comments/list.jst --&gt;</i>
<b class="hl-tag" style="color: #000096">&lt;ul&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;%</b> <span class="hl-attribute" style="color: #F5844C">task.comments.each(function(comment)</span> <span class="hl-attribute" style="color: #F5844C">{</span> <span class="hl-attribute" style="color: #F5844C">%&gt;</span>
    <span class="hl-attribute" style="color: #F5844C">&lt;%</span>= <span class="hl-value" style="color: #993300">JST['comments</span><b class="hl-tag" style="color: #000096">/i</b>tem']({ comment: comment }) %&gt;
  <b class="hl-tag" style="color: #000096">&lt;%</b> <span class="hl-attribute" style="color: #F5844C">}</span> <span class="hl-attribute" style="color: #F5844C">%&gt;</span>
<span class="hl-attribute" style="color: #F5844C">&lt;/ul&gt;</span>

<span class="hl-attribute" style="color: #F5844C">&lt;%</span>= <span class="hl-value" style="color: #993300">JST['comments</span><b class="hl-tag" style="color: #000096">/n</b>ew']() %&gt;</pre>
<pre class="programlisting"><i class="hl-comment" style="color: silver">&lt;!-- comments/item.jst --&gt;</i>
<b class="hl-tag" style="color: #000096">&lt;h4&gt;</b><b class="hl-tag" style="color: #000096">&lt;%=</b> <span class="hl-attribute" style="color: #F5844C">comment.user.escape('name')</span> <span class="hl-attribute" style="color: #F5844C">%&gt;&lt;/h4&gt;</span>
<span class="hl-attribute" style="color: #F5844C">&lt;p&gt;&lt;%</span>= <span class="hl-value" style="color: #993300">comment.escape('text')</span> <span class="hl-attribute" style="color: #F5844C">%&gt;&lt;/p&gt;</span></pre>
<pre class="programlisting"><i class="hl-comment" style="color: silver">&lt;!-- comments/new.jst --&gt;</i>
<b class="hl-tag" style="color: #000096">&lt;div</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"form-inputs"</span><b class="hl-tag" style="color: #000096">&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;label</b> <span class="hl-attribute" style="color: #F5844C">for</span>=<span class="hl-value" style="color: #993300">"new-comment-input"</span><b class="hl-tag" style="color: #000096">&gt;</b>Add comment<b class="hl-tag" style="color: #000096">&lt;/label&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;textarea</b> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"new-comment-input"</span> <span class="hl-attribute" style="color: #F5844C">cols</span>=<span class="hl-value" style="color: #993300">"30"</span> <span class="hl-attribute" style="color: #F5844C">rows</span>=<span class="hl-value" style="color: #993300">"10"</span><b class="hl-tag" style="color: #000096">&gt;</b><b class="hl-tag" style="color: #000096">&lt;/textarea&gt;</b>
  <b class="hl-tag" style="color: #000096">&lt;button&gt;</b>Add Comment<b class="hl-tag" style="color: #000096">&lt;/button&gt;</b>
<b class="hl-tag" style="color: #000096">&lt;/div&gt;</b></pre>
<p>But this is really only half the story. The <code class="literal">TaskDetail</code> view class still
handles multiple concerns: displaying the task, and creating comments. Let’s
split that view class up, using the <code class="literal">CompositeView</code> base class:</p>
<pre class="programlisting">Support.CompositeView = <b class="hl-keyword">function</b>(options) {
  <b class="hl-keyword">this</b>.children = _([]);
  Backbone.View.apply(<b class="hl-keyword">this</b>, [options]);
};

_.extend(Support.CompositeView.<b class="hl-keyword">prototype</b>, Backbone.View.<b class="hl-keyword">prototype</b>, {
  leave: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.unbind();
    <b class="hl-keyword">this</b>.remove();
    <b class="hl-keyword">this</b>._leaveChildren();
    <b class="hl-keyword">this</b>._removeFromParent();
  },

  renderChild: <b class="hl-keyword">function</b>(view) {
    view.render();
    <b class="hl-keyword">this</b>.children.push(view);
    view.parent = <b class="hl-keyword">this</b>;
  },

  appendChild: <b class="hl-keyword">function</b>(view) {
    <b class="hl-keyword">this</b>.renderChild(view);
    $(<b class="hl-keyword">this</b>.el).append(view.el);
  },

  renderChildInto: <b class="hl-keyword">function</b>(view, container) {
    <b class="hl-keyword">this</b>.renderChild(view);
    $(container).empty().append(view.el);
  },

  _leaveChildren: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.children.chain().clone().each(<b class="hl-keyword">function</b>(view) {
      <b class="hl-keyword">if</b> (view.leave)
        view.leave();
    });
  },

  _removeFromParent: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">if</b> (<b class="hl-keyword">this</b>.parent)
      <b class="hl-keyword">this</b>.parent._removeChild(<b class="hl-keyword">this</b>);
  },

  _removeChild: <b class="hl-keyword">function</b>(view) {
    <b class="hl-keyword">var</b> index = <b class="hl-keyword">this</b>.children.indexOf(view);
    <b class="hl-keyword">this</b>.children.splice(index, <span class="hl-number">1</span>);
  }
});

Support.CompositeView.extend = Backbone.View.extend;</pre>
<p>Similar to the <code class="literal">SwappingRouter</code>, the <code class="literal">CompositeView</code> base class solves common
housekeeping problems by establishing a convention. See the "SwappingRouter and
Backbone internals" section for an in-depth analysis of how this subclassing
pattern works.</p>
<p>Now our <code class="literal">CompositeView</code> maintains an array of its immediate children as
<code class="literal">this.children</code>.  With this reference in place, a parent view’s <code class="literal">leave()</code> method
can invoke <code class="literal">leave()</code> on its children, ensuring that an entire tree of composed
views is cleaned up properly.</p>
<p>For child views that can dismiss themselves, such as dialog boxes, children
maintain a back-reference at <code class="literal">this.parent</code>. This is used to reach up and call
<code class="literal">this.parent.removeChild(this)</code> for these self-dismissing views.</p>
<p>Making use of <code class="literal">CompositeView</code>, we split up the <code class="literal">TaskDetail</code> view class:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> TaskDetail = CompositeView.extend({
  tagName: <b class="hl-string"><i style="color:red">'section'</i></b>,
  id: <b class="hl-string"><i style="color:red">'task'</i></b>,

  initialize: <b class="hl-keyword">function</b>() {
    _.bindAll(<b class="hl-keyword">this</b>, <b class="hl-string"><i style="color:red">"renderDetails"</i></b>);
    <b class="hl-keyword">this</b>.model.on(<b class="hl-string"><i style="color:red">"change"</i></b>, <b class="hl-keyword">this</b>.renderDetails);
  },

  render: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.renderLayout();
    <b class="hl-keyword">this</b>.renderDetails();
    <b class="hl-keyword">this</b>.renderCommentsList();
  },

  renderLayout: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.$el.html(JST[<b class="hl-string"><i style="color:red">'tasks/show'</i></b>]());
  },

  renderDetails: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> detailsMarkup = JST[<b class="hl-string"><i style="color:red">'tasks/details'</i></b>]({ task: <b class="hl-keyword">this</b>.model });
    <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'.task-details'</i></b>).html(detailsMarkup);
  },

  renderCommentsList: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> commentsList = <b class="hl-keyword">new</b> CommentsList({ model: <b class="hl-keyword">this</b>.model });
    <b class="hl-keyword">var</b> commentsContainer = <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'comments'</i></b>);
    <b class="hl-keyword">this</b>.renderChildInto(commentsList, commentsContainer);
  }
});</pre>
<pre class="programlisting"><b class="hl-keyword">var</b> CommentsList = CompositeView.extend({
  tagName: <b class="hl-string"><i style="color:red">'ul'</i></b>,

  initialize: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.model.comments.on(<b class="hl-string"><i style="color:red">"add"</i></b>, <b class="hl-keyword">this</b>.renderComments);
  },

  render: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.renderLayout();
    <b class="hl-keyword">this</b>.renderComments();
    <b class="hl-keyword">this</b>.renderCommentForm();
  },

  renderLayout: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.$el.html(JST[<b class="hl-string"><i style="color:red">'comments/list'</i></b>]());
  },

  renderComments: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> commentsContainer = <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'comments-list'</i></b>);
    commentsContainer.html(<b class="hl-string"><i style="color:red">''</i></b>);

    <b class="hl-keyword">this</b>.model.comments.each(<b class="hl-keyword">function</b>(comment) {
      <b class="hl-keyword">var</b> commentMarkup = JST[<b class="hl-string"><i style="color:red">'comments/item'</i></b>]({ comment: comment });
      commentsContainer.append(commentMarkup);
    });
  },

  renderCommentForm: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> commentForm = <b class="hl-keyword">new</b> CommentForm({ model: <b class="hl-keyword">this</b>.model });
    <b class="hl-keyword">var</b> commentFormContainer = <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'.new-comment-form'</i></b>);
    <b class="hl-keyword">this</b>.renderChildInto(commentForm, commentFormContainer);
  }
});</pre>
<pre class="programlisting"><b class="hl-keyword">var</b> CommentForm = CompositeView.extend({
  events: {
    <b class="hl-string"><i style="color:red">"click button"</i></b>: <b class="hl-string"><i style="color:red">"createComment"</i></b>
  },

  initialize: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.model = <b class="hl-keyword">this</b>.options.model;
  },

  render: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.$el.html(JST[<b class="hl-string"><i style="color:red">'comments/new'</i></b>]);
  },

  createComment: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> comment = <b class="hl-keyword">new</b> Comment({ text: $(<b class="hl-string"><i style="color:red">'.new-comment-input'</i></b>).val() });
    <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'.new-comment-input'</i></b>).val(<b class="hl-string"><i style="color:red">''</i></b>);
    <b class="hl-keyword">this</b>.model.comments.create(comment);
  }
});</pre>
<p>Along with this, remove the <code class="literal">&lt;%= JST(…) %&gt;</code> template nestings, allowing the
view classes to assemble the templates instead. In this case, each template
contains placeholder elements that are used to wrap child views:</p>
<pre class="programlisting"><i class="hl-comment" style="color: silver">&lt;!-- tasks/show.jst --&gt;</i>
<b class="hl-tag" style="color: #000096">&lt;section</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"task-details"</span><b class="hl-tag" style="color: #000096">&gt;</b>
<b class="hl-tag" style="color: #000096">&lt;/section&gt;</b>

<b class="hl-tag" style="color: #000096">&lt;section</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"comments"</span><b class="hl-tag" style="color: #000096">&gt;</b>
<b class="hl-tag" style="color: #000096">&lt;/section&gt;</b></pre>
<pre class="programlisting"><i class="hl-comment" style="color: silver">&lt;!-- tasks/details.jst --&gt;</i>
<b class="hl-tag" style="color: #000096">&lt;input</b> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"checkbox"</span><span class="hl-attribute" style="color: #F5844C">&lt;%</span>= <span class="hl-value" style="color: #993300">task.isComplete()</span> <span class="hl-attribute" style="color: #F5844C">?</span> <span class="hl-attribute" style="color: #F5844C">'</span> <span class="hl-attribute" style="color: #F5844C">checked</span>=<span class="hl-value" style="color: #993300">"checked"</span><span class="hl-attribute" style="color: #F5844C">'</span> <span class="hl-attribute" style="color: #F5844C">:</span> <span class="hl-attribute" style="color: #F5844C">''</span> <span class="hl-attribute" style="color: #F5844C">%&gt;</span><b class="hl-tag" style="color: #000096"> /&gt;</b>
<b class="hl-tag" style="color: #000096">&lt;h2&gt;</b><b class="hl-tag" style="color: #000096">&lt;%=</b> <span class="hl-attribute" style="color: #F5844C">task.escape("title")</span> <span class="hl-attribute" style="color: #F5844C">%&gt;&lt;/h2&gt;</span></pre>
<pre class="programlisting"><i class="hl-comment" style="color: silver">&lt;!-- comments/list.jst --&gt;</i>
<b class="hl-tag" style="color: #000096">&lt;ul</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"comments-list"</span><b class="hl-tag" style="color: #000096">&gt;</b>
<b class="hl-tag" style="color: #000096">&lt;/ul&gt;</b>

<b class="hl-tag" style="color: #000096">&lt;section</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"new-comment-form"</span><b class="hl-tag" style="color: #000096">&gt;</b>
<b class="hl-tag" style="color: #000096">&lt;/section&gt;</b></pre>
<pre class="programlisting"><i class="hl-comment" style="color: silver">&lt;!-- comments/item.jst --&gt;</i>
<b class="hl-tag" style="color: #000096">&lt;h4&gt;</b><b class="hl-tag" style="color: #000096">&lt;%=</b> <span class="hl-attribute" style="color: #F5844C">comment.user.escape('name')</span> <span class="hl-attribute" style="color: #F5844C">%&gt;&lt;/h4&gt;</span>
<span class="hl-attribute" style="color: #F5844C">&lt;p&gt;&lt;%</span>= <span class="hl-value" style="color: #993300">comment.escape('text')</span> <span class="hl-attribute" style="color: #F5844C">%&gt;&lt;/p&gt;</span></pre>
<pre class="programlisting"><i class="hl-comment" style="color: silver">&lt;!-- comments/new.jst --&gt;</i>
<b class="hl-tag" style="color: #000096">&lt;label</b> <span class="hl-attribute" style="color: #F5844C">for</span>=<span class="hl-value" style="color: #993300">"new-comment-input"</span><b class="hl-tag" style="color: #000096">&gt;</b>Add comment<b class="hl-tag" style="color: #000096">&lt;/label&gt;</b>
<b class="hl-tag" style="color: #000096">&lt;textarea</b> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"new-comment-input"</span> <span class="hl-attribute" style="color: #F5844C">cols</span>=<span class="hl-value" style="color: #993300">"30"</span> <span class="hl-attribute" style="color: #F5844C">rows</span>=<span class="hl-value" style="color: #993300">"10"</span><b class="hl-tag" style="color: #000096">&gt;</b><b class="hl-tag" style="color: #000096">&lt;/textarea&gt;</b>
<b class="hl-tag" style="color: #000096">&lt;button&gt;</b>Add Comment<b class="hl-tag" style="color: #000096">&lt;/button&gt;</b></pre>
<p>There are several advantages to this approach:</p>
<div class="itemizedlist"><ul type="disc">
<li>
Each view class has a smaller and more cohesive set of responsibilities.
</li>
<li>
The comments view code, extracted and decoupled from the task view code, can
  now be reused on other domain objects with comments.
</li>
<li>
The task view performs better, since adding new comments or updating the task
  details will only re-render the pertinent section, instead of re-rendering the
  entire task + comments composite.
</li>
</ul></div>
<p>In the example app, we make use of a composite view on TasksIndex located at
<code class="literal">app/assets/javascripts/views/tasks_index.js</code>. The situation is similar to
what has been discussed here. The view responsible for rendering the list of
children will actually render them as children. Note how the <code class="literal">renderTasks</code>
function iterates over the  collection of tasks, instantiates a <code class="literal">TaskItem</code>
view for each, renders it as a child with <code class="literal">renderChild</code>, and finally appends
it to table’s body. Now when the router cleans up the <code class="literal">TasksIndex</code> with <code class="literal">leave</code>,
it will also clean up all of its children.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_cleaning_up_views_properly"></a>Cleaning up views properly</h4></div></div></div>
<p>You’ve learned how leaving lingering events bound on views that are no longer
on the page can cause both UI bugs, or what’s probably worse, memory leaks.
A slight flickering of the interface is annoying at best, but prolonged usage
of your app could in fact make the user’s browser to start consuming massive
amounts of memory, potentially causing browser crashes, data loss and unhappy
users and angry developers.</p>
<p>We now have a full set of tools to clean up views properly. To summarize, the
big picture tools are:</p>
<div class="itemizedlist"><ul type="disc">
<li>
A <span class="strong"><strong>Swapping Router</strong></span> that keeps track of the current view so it can tell it
to clean up before it swaps in a new view.
</li>
<li>
A <span class="strong"><strong>Composite View</strong></span> that keeps track of its child views so it can tell them to
clean up when it is cleaning itself up.
</li>
</ul></div>
<p>The <code class="literal">leave()</code> function ties this all together. A call to <code class="literal">leave()</code> can either
come from a <code class="literal">SwappingRouter</code> or from a parent <code class="literal">CompositeView</code>.  A <code class="literal">CompositeView</code>
will respond to <code class="literal">leave()</code> by passing that call down to its children. At each
level, in addition to propagating the call, <code class="literal">leave()</code> handles the task of
completely cleaning up after a view by removing the corresponding element from
the DOM via jQuery’s <code class="literal">remove()</code> function, and removing all event bindings via a
call to <code class="literal">Backbone.Events.off()</code>. In this way a single call at the top level
cleans the slate for an entirely new view.</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_forms"></a>Forms</h3></div></div></div>
<p>Who likes writing form code by hand?  Rails' form builder API greatly helps
reduce application code.  We aim to maintain a similar level of abstraction in
our Backbone application code.  Let’s take a look at what we need from form
building code to achieve this.</p>
<p>We have a few requirements when it comes to handling forms.  We need to:</p>
<div class="itemizedlist"><ul type="disc">
<li>
Build form markup and populate it with model values
</li>
<li>
Serialize a form into a model for validation and persistence
</li>
<li>
Display error messages
</li>
</ul></div>
<p>Additionally, it’s nice to:</p>
<div class="itemizedlist"><ul type="disc">
<li>
Reduce boilerplate
</li>
<li>
Render consistent and stylable markup
</li>
<li>
Automatically build form structure from data structure
</li>
</ul></div>
<p>Let’s look at the requirements one-by-one and compare approaches.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_building_markup"></a>Building markup</h4></div></div></div>
<p>Our first requirement is the ability to build markup.  For example, consider a
Rails model <code class="literal">User</code> that has a username and password.  We might want to build
form markup that looks like this:</p>
<pre class="programlisting">&lt;form&gt;
  &lt;li&gt;
    &lt;label for="email"&gt;Email&lt;/label&gt;
    &lt;input type="text" id="email" name="email"&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;label for="password"&gt;Password&lt;/label&gt;
    &lt;input type="password" id="password" name="password"&gt;
  &lt;/li&gt;
&lt;/form&gt;</pre>
<p>One approach you could take is writing the full form markup by hand.  You could
create a template available to Backbone via JST that contains the raw HTML.  If
you took the above markup and saved it into <code class="literal">app/templates/users/form.jst</code> then
it would be accessible as <code class="literal">JST["users/form"]()</code>.</p>
<p>You <span class="strong"><strong>could</strong></span> write all the HTML by hand, but we’d like to avoid that.</p>
<p>Another route that might seem appealing is reusing the Rails form builders
through the 3.1 asset pipeline.  Consider <code class="literal">app/templates/users/form.jst.ejs.erb</code>
which is processed first with ERb, and then made available as a JST template.
There are a few concerns to address, such as including changing the EJS or ERb template
delimiters <code class="literal">&lt;% %&gt;</code> to not conflict and mixing the Rails helper modules into the
Tilt::ERbTemplate rendering context.  Yet, this approach still only generates
markup; it doesn’t serialize forms into data hashes or Backbone models.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_serializing_forms"></a>Serializing forms</h4></div></div></div>
<p>The second requirement is to serialize forms into objects suitable for setting
Backbone model attributes.  Assuming the markup we discussed above, you could
approach this manually:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> serialize = <b class="hl-keyword">function</b>(form) {
  <b class="hl-keyword">var</b> elements = $(<b class="hl-string"><i style="color:red">'input, select, textarea'</i></b>, form);

  <b class="hl-keyword">var</b> serializer = <b class="hl-keyword">function</b>(attributes, element) {
    <b class="hl-keyword">var</b> element = $(element);
    attributes[element.attr(<b class="hl-string"><i style="color:red">'name'</i></b>)] = element.val();
  };

  <b class="hl-keyword">return</b> _.inject(elements, serializer, []);
};

<b class="hl-keyword">var</b> form = $(<b class="hl-string"><i style="color:red">'form'</i></b>);
<b class="hl-keyword">var</b> model = <b class="hl-keyword">new</b> MyApp.Models.User();
<b class="hl-keyword">var</b> attributes = serialize(form);
model.set(attributes);</pre>
<p>This gets you started, but has a few shortcomings.  It doesn’t handle nested
attributes, doesn’t handle typing (consider a date picker input; ideally it
would set a Backbone model’s attribute to a JavaScript Date instance), and will
include any <code class="literal">&lt;input type="submit"&gt;</code> elements when constructing the attribute
hash.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_a_backbone_forms_library"></a>A Backbone forms library</h4></div></div></div>
<p>If you want to avoid writing form markup by hand, your best bet is to use a
JavaScript form builder.  Since the model data is being read and written by
Backbone views and models, it’s ideal to have markup construction and form
serialization implemented on the client-side.</p>
<p>One solid implementation is
<a class="ulink" href="https://github.com/powmedia/backbone-forms" target="_top"><code class="literal">backbone-forms</code> by Charles
Davison</a>.  It provides markup construction and serialization, as well as a
method for declaring a typed schema to support both of those facilities.  It
provides a flexible system for adding custom editor types, and supports
configuring your form markup structure by providing HTML template fragments.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_display_server_errors"></a>Display server errors</h4></div></div></div>
<p>We are assuming, with a hybrid Rails/Backbone application, that at least some of
your business logic resides on the server.  Let’s take a look at the client/server
interaction when a user of the example application creates a task.</p>
<p>The client side interface for creating a new task is structure similarly to a
traditional Rails form.  Although moderated by Backbone views and models,
essentially there is a form whose contents is submitted to the Rails server,
where attributes are processed and a response is generated.</p>
<p>Let’s add a validation to the Task Rails model, ensuring each task has something
entered for the title:</p>
<pre class="programlisting">  validates :title, :presence =&gt; <b class="hl-keyword">true</b></pre>
<p>Now, if you create a task without a title, the Rails <code class="literal">TasksController</code> still
delivers a response:</p>
<pre class="programlisting"><b class="hl-keyword">def</b> create
  respond_with(current_user.tasks.create(params[:task]))
<b class="hl-keyword">end</b></pre>
<p>but the response now returns with an HTTP response code of 422 and a JSON
response body of <code class="literal">{"title":["can't be blank"]}</code>.</p>
<p>Establishing a few conventions, we can display these per-field errors alongside
their corresponding form inputs.  We’ll</p>
<p>We will establish a few conventions that, when we can adhere to them, allow us
to render the Rails validation errors inline on the form.  Depending on how you
structure markup in your application, you can employ a variation on this
approach.</p>
<p>For an example, let’s examine a form field modeled after Formtastic conventions:</p>
<pre class="programlisting">&lt;form id="example_form"&gt;
  &lt;ol&gt;
    &lt;li id="task_title_input"&gt;
      &lt;label for="task_title"&gt;Title&lt;/label&gt;
      &lt;input id="task_title" name="title" type="text"&gt;
      &lt;!--
        &lt;p class="inline_errors"&gt;
          The error for this field will be rendered here.
        &lt;/p&gt;
      --&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/form&gt;</pre>
<p>Elsewhere, likely in a view class, when a user triggers a save action in the
interface, we save the form’s corresponding model.  If the <code class="literal">save()</code> fails,
we’ll parse the model attributes and corresponding error(s) from the server’s
response and render an <code class="literal">ErrorView</code>.</p>
<pre class="programlisting"><b class="hl-keyword">var</b> formField = $(<b class="hl-string"><i style="color:red">'form#example_form'</i></b>);

model.on(<b class="hl-string"><i style="color:red">'error'</i></b>, <b class="hl-keyword">function</b>(model, response, options) {
  <b class="hl-keyword">var</b> attributesWithErrors = JSON.parse(response.responseText);

  <b class="hl-keyword">new</b> ErrorView({
    el: formField,
    attributesWithErrors: attributesWithErrors
  }).render();
});

model.save();</pre>
<p>The <code class="literal">ErrorView</code> iterates over the response attributes and their errors (there
may be more than one error per model attribute), rendering them inline into
the form.  The <code class="literal">ErrorView</code> also adds the <code class="literal">error</code> CSS class to the <code class="literal">&lt;li&gt;</code> field
container.</p>
<pre class="programlisting">ErrorView = Backbone.View.extend({
  initialize: <b class="hl-keyword">function</b>(options) {
    <b class="hl-keyword">this</b>.attributesWithErrors = <b class="hl-keyword">this</b>.options.attributesWithErrors;
    _.bindAll(<b class="hl-keyword">this</b>, <b class="hl-string"><i style="color:red">"clearErrors"</i></b>, <b class="hl-string"><i style="color:red">"renderErrors"</i></b>, <b class="hl-string"><i style="color:red">"renderError"</i></b>, <b class="hl-string"><i style="color:red">"fieldFor"</i></b>);
  },

  render: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.clearOldErrors();
    <b class="hl-keyword">this</b>.renderErrors();
  },

  clearOldErrors: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">".error"</i></b>).removeClass(<b class="hl-string"><i style="color:red">"error"</i></b>);
    <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">"p.inline_errors"</i></b>).remove();
  },

  renderErrors: <b class="hl-keyword">function</b>() {
    _.each(<b class="hl-keyword">this</b>.attributesWithErrors, <b class="hl-keyword">this</b>.renderError);
  },

  renderError: <b class="hl-keyword">function</b>(errors, attribute) {
    <b class="hl-keyword">var</b> errorString = errors.join(<b class="hl-string"><i style="color:red">", "</i></b>);
    <b class="hl-keyword">var</b> field = <b class="hl-keyword">this</b>.fieldFor(attribute);
    <b class="hl-keyword">var</b> errorTag = $(<b class="hl-string"><i style="color:red">'&lt;p&gt;'</i></b>).addClass(<b class="hl-string"><i style="color:red">'inline_errors'</i></b>).text(errorString);
    field.append(errorTag);
    field.addClass(<b class="hl-string"><i style="color:red">"error"</i></b>);
  },

  fieldFor: <b class="hl-keyword">function</b>(attribute) {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'li[id*="_'</i></b> + attribute + <b class="hl-string"><i style="color:red">'_input"]'</i></b>);
  }
});</pre>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_internationalization"></a>Internationalization</h3></div></div></div>
<p>When you move your application’s view logic onto the client, such as with
Backbone, you quickly find that the library support for views is not as
comprehensive as what you have on the server. The
<a class="ulink" href="http://guides.rubyonrails.org/i18n.html" target="_top">Rails internationalization (i18n) API</a>,
provided via the <a class="ulink" href="https://rubygems.org/gems/i18n" target="_top">i18n gem</a>, is not automatically
available to client-side view rendering.  We’d like to take advantage of that
framework, as well as any localization work you’ve done if you are adding
Backbone into an existing app.</p>
<p>There is a JavaScript library, available with Rails support as a Ruby gem
<a class="ulink" href="https://github.com/fnando/i18n-js" target="_top"><code class="literal">i18n-js</code></a>, that provides access to your i18n
content as a JavaScript object, similar to how the JST object provides access
to your templates.</p>
<p>From the documentation, you can link the locale to the server-side locale:</p>
<pre class="programlisting">&lt;script type="text/javascript"&gt;
  I18n.defaultLocale = "&lt;%= I18n.default_locale %&gt;";
  I18n.locale = "&lt;%= I18n.locale %&gt;";
&lt;/script&gt;</pre>
<p>and then use the <code class="literal">I18n</code> JavaScript object to provide translations:</p>
<pre class="programlisting"><i class="hl-comment" style="color: silver">// translate with your default locale</i>
I18n.t(<b class="hl-string"><i style="color:red">"some.scoped.translation"</i></b>);

<i class="hl-comment" style="color: silver">// translate with explicit setting of locale</i>
I18n.t(<b class="hl-string"><i style="color:red">"some.scoped.translation"</i></b>, {locale: <b class="hl-string"><i style="color:red">"fr"</i></b>});</pre>
<p>You can use the <code class="literal">I18n.t()</code> function inside your templates, too:</p>
<pre class="programlisting">&lt;nav&gt;
  &lt;a href="#/"&gt;&lt;%= I18n.t("nav.links.home") %&gt;&lt;/a&gt;
  &lt;a href="#/projects"&gt;&lt;%= I18n.t("nav.links.projects") %&gt;&lt;/a&gt;
  &lt;a href="#/settings"&gt;&lt;%= I18n.t("nav.links.settings") %&gt;&lt;/a&gt;
&lt;/nav&gt;</pre>
<p>Number, currency, and date formatting is available with <code class="literal">i18n.js</code> as well - see
the <a class="ulink" href="https://github.com/fnando/i18n-js" target="_top">documentation</a> for further usage
information.</p>
</div>
</div>

    </div>

    <hr/>

    <div class="nav" id="navfooter">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="rails_integration.html">Prev</a><br/>
         Rails Integration
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         Backbone.js on Rails
        
      </td><td width="33%" align="right">
        
          <a href="models_and_collections.html">Next</a><br/>
          Models and collections
        
      </td></tr>
    </table>
    </div>
  </body>
</html>
