=== Uploading attachments

While Ruby gems such as paperclip make the API for attaching files to models
very similar to the standard ActiveModel attribute persistence API, attaching
files to Backbone models is not quite as straightforward.  In this section,
we'll take a look at the general approach for attaching files, and then examine
the specific implementation used in the example application.

==== How to attach files to Backbone models

If you upload to a backbone model, you can't do it in a typical async request.
Meaning, `model.save()` can't just send a file to the server like other
attributes.  Instead, we save the attachment in a separate request, and then
just swap in an attachment id on the model. This does mean that you can have
unclaimed attachments if the end user leaves the page before saving the parent
model, but those can be periodically cleaned out if the disk usage is an issue.

When modeling this from the Rails side, you can choose to persist the file
upload identifier (e.g. the local path or S3 URL) on one of your models
directly, or you can break the attachment out into its own ActiveRecord model.
It's generally more straightforward to break the attachment out into its own
model, because this can greatly simplify grabbing a reference to 

There are quite a few approaches to uploading files asynchronously, and browser
support varies.  There are features like multiple file upload and drag-and-drop 
to consider, too.

We'll use the HTML5 File API because it's a straightforward approach that is
supported by modern browsers.  The API is small and the wrapper code that we
start with:

https://github.com/mockenoff/HTML5-AJAX-File-Uploader

is easy to read.  This approach requires XHR2 and FormData:

* https://developer.mozilla.org/en/XMLHttpRequest/FormData

If you would like to provide fallback support for older
browsers, using Flash or iframes, you can do so with plugins like (TODO:
recommend plugins).

==== Example: Attaching images to Tasks

In our example task management app, we'd like for the owner of a task to attach
several images to each task.  We want uploads to happen in the task detail view,
and for the uploads to appear in-page as soon as they are uploaded.  We don't
need to display uploads on the index view.

First, let's write an acceptance test to drive the functionality:

[text]
source~~~~
include::../../example_app/features/users/attach_file_to_task.feature[]
source~~~~

The first failures we get are from the lack of upload UI.  We'll drop down to
unit tests to drive this out:

[javascript]
source~~~~
include::../../example_app/spec/javascripts/views/task_show_spec.js
source~~~~

Then, we'll add the upload form to the TaskShow view to the `tasks/show.jst.ejs`
template, so the UI elements are in place:

[html]
source~~~~
include::../../example_app/app/assets/templates/tasks/show.jst.ejs
source~~~~

Once our units pass, we run the acceptance tests again. The next failure we see
is that nothing happens upon upload.  We'll drop down to Jasmine here to write
unit tests for the uploading:

[javascript]
source~~~~
include::../../example_app/spec/javascripts/views/task_show_uploading_spec.js
source~~~~

TODO: Finish outline:

* NB: You can't overwrite input.files (a FileList instance), so you'll have to
provide a point of fake injection; in our case, TaskShow#uploadInput().
* Make it pass by adding uploader.js and adding uploader logic to TaskShow view
* Now we are uploading, but the server isn't accepting/persisting
* Test-drive persistence on server side:
** Add paperclip gem
** Create Attachment model, route, controller.  Test-drive the units.
** NB on integration point: XHR requests from BB to Rails needs CSRF tokens, so inject
   as uploader.prefilter, analagous to $.ajaxPrefilter http://api.jquery.com/extending-ajax/
* Next, display existing attachments to the user.

For structuring the attachments in Backbone, we want to be able to do something
like the following:

[html]
source~~~~
<% this.task.attachments.each(function(attachment) { %>
  Attached: <img src="<%= attachment.get('upload_url')" /> %>
<% }); %>
source~~~~

So, the Task model will have attachments property that is instantiates with an
AttachmentsCollection instance.

NOTE: This is written assuming that the model_relationships.asc chapter came
first and discusses how to structure the JSON, which is bundling the comments
and attachments associations under the Task's JSON representation.  It should
introduce and discuss using Rabl, too. Depending on how in-depth that section
is, we may need to write more here to contextualize.

We're providing a JSON represenatation using Rabl, rooted at the Task:

[ruby]
source~~~~
include::../../example_app/app/views/tasks/show.json.rabl
source~~~~

Note that you have to have to tell Rabl to suppress the root JSON node, just
like we suppress the root JSON node in ActiveRecord with
`ActiveRecord::Base.include_root_in_json = false`:

[ruby]
source~~~~
# config/initializers/rabl_init.rb
Rabl.configure do |config|
  config.include_json_root = false
end
source~~~~

We can test drive the attachment display from Jasmine, see task_show_spec.js:

[javascript]
source~~~~
include::../../example_app/spec/javascripts/views/task_show_with_attachments_spec.js
source~~~~

This depends on parsing the JSON from the client side, so test drive that for
the ExampleApp.Models.Tasks Jasmine spec:

* Include spec/javascripts/models/task_spec.js
* Implement in task.js
* TDD Attachments collection and Attachment model
* Implement Attachments collection and Attachment model
* Green?
