<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Models and collections</title><meta name="generator" content="DocBook XSL Stylesheets V1.74.1"/><link rel="home" href="index.html" title="Backbone.js on Rails"/><link rel="up" href="index.html" title="Backbone.js on Rails"/><link rel="prev" href="ar01s05.html" title="Routers, Views, and Templates"/><link rel="next" href="ar01s07.html" title="Testing"/></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Models and collections</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s05.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s07.html">Next</a></td></tr></table><hr/></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_models_and_collections"/>Models and collections</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_model_associations"/>Model associations</h3></div></div></div><p>Backbone.js doesn’t prescribe a way to define associations between models, so
we need to get creative and use the power of JavaScript to set up associations
in such a way that its usage is natural.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_belongs_to_associations"/>Belongs to associations</h4></div></div></div><p>Setting up a <code class="literal">belongs_to</code> association in Backbone is a two step process. Let’s
discuss setting up the association that may occur between a task and a user.
The end result of the approach is a <code class="literal">Task</code> instance having a property called
<code class="literal">user</code> where we store the associated <code class="literal">User</code> object.</p><p>To set this up, let’s start by telling Rails to augment the task’s JSON
representation to also send over the associated user attributes:</p><pre class="programlisting"><b class="hl-keyword">class</b> Task &lt; ActiveRecord::Base
  belongs_to :user

  <b class="hl-keyword">def</b> as_json(options = <b class="hl-keyword">nil</b>)
    <b class="hl-keyword">super</b>((options || {}).merge(include: { user: { only: [:name, :email] } }))
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre><p>This means that when Backbone calls <code class="literal">fetch()</code> for a <code class="literal">Task</code> model, it will
include the name and email of the associated user nested within the task JSON
representation. Something like this:</p><pre class="programlisting">{
  <b class="hl-string"><i style="color:red">"title"</i></b>: <b class="hl-string"><i style="color:red">"Buy more Cheeseburgers"</i></b>,
  <b class="hl-string"><i style="color:red">"due_date"</i></b>: <b class="hl-string"><i style="color:red">"2011-03-04"</i></b>,
  <b class="hl-string"><i style="color:red">"user"</i></b>: {
    <b class="hl-string"><i style="color:red">"name"</i></b>: <b class="hl-string"><i style="color:red">"Robert McGraffalon"</i></b>,
    <b class="hl-string"><i style="color:red">"email"</i></b>: <b class="hl-string"><i style="color:red">"bobby@themcgraffalons.com"</i></b>
  }
}</pre><p>Now that we receive user data with the task’s JSON representation, let’s tell
our Backbone User model to store the User object. We do that on the task’s
initializer. Here’s a first cut at that:</p><pre class="programlisting"><b class="hl-keyword">var</b> Task = Backbone.Model.extend({
  initialize: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.user = <b class="hl-keyword">new</b> User(<b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'user'</i></b>));
  }
});</pre><p>We can make a couple of improvements to the above. First, you’ll soon realize
that you might be setting the user outside of the initialize as well. Second,
the initializer should check whether there is user data in the first place. To
address the first concern, let’s create a setter for the object. Backbone
provides a handy function called <code class="literal">has</code> that returns true or false depending on
whether the provided attribute is set for the object:</p><pre class="programlisting"><b class="hl-keyword">var</b> Task = Backbone.Model.extend({
  initialize: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">if</b> (<b class="hl-keyword">this</b>.has(<b class="hl-string"><i style="color:red">'user'</i></b>)) {
      <b class="hl-keyword">this</b>.setUser(<b class="hl-keyword">new</b> User(<b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'user'</i></b>)));
    }
  },

  setUser: <b class="hl-keyword">function</b>(user) {
    <b class="hl-keyword">this</b>.user = user;
  }
});</pre><p>The final setup allows for a nice clean interface to a task’s user, by
accessing the task property of the user instance.</p><pre class="programlisting"><b class="hl-keyword">var</b> task = Task.fetch(<span class="hl-number">1</span>);
console.log(task.get(<b class="hl-string"><i style="color:red">'title'</i></b>) + <b class="hl-string"><i style="color:red">' is being worked on by '</i></b> + task.user.get(<b class="hl-string"><i style="color:red">'name'</i></b>));</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_has_many_associations"/>Has many associations</h4></div></div></div><p>You can take a similar approach to set up a <code class="literal">has_many</code> association on the
client side models. This time, however, the object’s property will be a
Backbone collection.</p><p>Following the example, say we need access to a user’s tasks. Let’s set up the
JSON representation on the Rails side first:</p><pre class="programlisting"><b class="hl-keyword">class</b> User &lt; ActiveRecord::Base
  has_many :tasks

  <b class="hl-keyword">def</b> as_json(options = <b class="hl-keyword">nil</b>)
    <b class="hl-keyword">super</b>((options || {}).merge(include: { tasks: { only: [:body, :due_date] } }))
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre><p>Now, on the Backbone <code class="literal">User</code> model’s initializer, let’s call the <code class="literal">setTasks</code>
function:</p><pre class="programlisting"><b class="hl-keyword">var</b> User = Backbone.Model.extend({
  initialize: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> tasks = <b class="hl-keyword">new</b> Tasks.reset(<b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'tasks'</i></b>));
    <b class="hl-keyword">this</b>.setTasks(tasks);
  },

  setTasks: <b class="hl-keyword">function</b>(tasks) {
    <b class="hl-keyword">this</b>.tasks = tasks;
  }
});</pre><p>Note that we are setting the relation to an instance of the <code class="literal">Tasks</code> collection.</p><p>TODO: Let’s exapnd upon this, as it isn’t the most flexible solution.  (It is
a good start.) We are setting the JSON representation of the Rails models to
suit the Backbone.js concerns.  Additionally, the <code class="literal">Task#as_json</code> method at the
top is concerned with the User JSON representation.  It should at least delegate
to User#as_json. Going further, the JSON presentation for consumption by
Backbone.js should be completely extracted into the JSON API endpoint controller
action, or even a separate presenter class.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_filters_and_sorting"/>Filters and sorting</h3></div></div></div><p>When using our Backbone models and collections, it’s often handy to filter the
collections by reusable criteria, or sort them by several different criteria.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_filters"/>Filters</h4></div></div></div><p>To filter a <code class="literal">Backbone.Collection</code>, like with Rails named scopes, define
functions on your collections that filter by your criteria, using the <code class="literal">select</code>
function from Underscore.js, and return new instances of the collection class. A
first implementation might look like this:</p><pre class="programlisting"><b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  complete: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> filteredTasks = <b class="hl-keyword">this</b>.select(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.get(<b class="hl-string"><i style="color:red">'completed_at'</i></b>) !== null;
    });
    <b class="hl-keyword">return</b> <b class="hl-keyword">new</b> Tasks(filteredTasks);
  }
});</pre><p>Let’s refactor this a bit.  Ideally, the filter functions will reuse logic
already defined in your model class:</p><pre class="programlisting"><b class="hl-keyword">var</b> Task = Backbone.Model.extend({
  isComplete: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'completed_at'</i></b>) !== null;
  }
});

<b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  complete: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> filteredTasks = <b class="hl-keyword">this</b>.select(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.isComplete();
    });
    <b class="hl-keyword">return</b> <b class="hl-keyword">new</b> Tasks(filteredTasks);
  }
});</pre><p>Going further, notice that there are actually two concerns in this function.
The first is the notion of filtering the collection, and the other is the
specific filtering criteria (<code class="literal">task.isComplete()</code>).</p><p>Let’s separate the two concerns here, and extract a <code class="literal">filtered</code> function:</p><pre class="programlisting"><b class="hl-keyword">var</b> Task = Backbone.Model.extend({
  isComplete: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'completed_at'</i></b>) !== null;
  }
});

<b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  complete: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.filtered(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.isComplete();
    });
  },

  filtered: <b class="hl-keyword">function</b>(criteriaFunction) {
    <b class="hl-keyword">return</b> <b class="hl-keyword">new</b> Tasks(<b class="hl-keyword">this</b>.select(criteriaFunction));
  }
});</pre><p>We can extract this function into a reusable mixin, abstracting the <code class="literal">Tasks</code>
collection class using <code class="literal">this.constructor</code>:</p><pre class="programlisting"><b class="hl-keyword">var</b> FilterableCollectionMixin = {
  filtered: <b class="hl-keyword">function</b>(criteriaFunction) {
    <b class="hl-keyword">return</b> <b class="hl-keyword">new</b> <b class="hl-keyword">this</b>.constructor(<b class="hl-keyword">this</b>.select(criteriaFunction));
  }
};

<b class="hl-keyword">var</b> Task = Backbone.Model.extend({
  isComplete: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'completed_at'</i></b>) !== null;
  }
});

<b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend(_.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  complete: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.filtered(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.isComplete();
    });
  }
}, FilterableCollectionMixin));</pre><p>TODO: Update syntax, use a separate _.extend invocation above.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_propagating_collection_changes"/>Propagating collection changes</h4></div></div></div><p>The <code class="literal">FilterableCollectionMixin</code>, as we’ve written it, will produce a filtered
collection that does not update when the original collection is changed.  To do
so, bind to the change, add, and remove events on the source collection,
reapply the filter function, and repopulate the filtered collection:</p><pre class="programlisting"><b class="hl-keyword">var</b> FilterableCollectionMixin = {
  filtered: <b class="hl-keyword">function</b>(criteriaFunction) {
    <b class="hl-keyword">var</b> sourceCollection = <b class="hl-keyword">this</b>;
    <b class="hl-keyword">var</b> filteredCollection = <b class="hl-keyword">new</b> <b class="hl-keyword">this</b>.constructor;

    <b class="hl-keyword">var</b> applyFilter = <b class="hl-keyword">function</b>() {
      filteredCollection.reset(sourceCollection.select(criteriaFunction));
    };

    <b class="hl-keyword">this</b>.bind(<b class="hl-string"><i style="color:red">"change"</i></b>, applyFilter);
    <b class="hl-keyword">this</b>.bind(<b class="hl-string"><i style="color:red">"add"</i></b>,    applyFilter);
    <b class="hl-keyword">this</b>.bind(<b class="hl-string"><i style="color:red">"remove"</i></b>, applyFilter);

    applyFilter();

    <b class="hl-keyword">return</b> filteredCollection;
  }
};</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_sorting"/>Sorting</h4></div></div></div><p>The simplest way to sort a <code class="literal">Backbone.Collection</code> is to define a <code class="literal">comparator</code>
function.  This functionality is built in:</p><pre class="programlisting"><b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  comparator: <b class="hl-keyword">function</b>(task) {
    <b class="hl-keyword">return</b> task.dueDate;
  }
});</pre><p>If you’d like to provide more than one sort order on your collection, you can
use an approach similar to the <code class="literal">filtered</code> function above, and return a new
<code class="literal">Backbone.Collection</code> whose <code class="literal">comparator</code> is overridden.  Call <code class="literal">sort</code> to update
the ordering on the new collection:</p><pre class="programlisting"><b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  comparator: <b class="hl-keyword">function</b>(task) {
    <b class="hl-keyword">return</b> task.dueDate;
  },

  byCreatedAt: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> sortedCollection = <b class="hl-keyword">new</b> Tasks(<b class="hl-keyword">this</b>.models);
    sortedCollection.comparator = <b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.createdAt;
    };
    sortedCollection.sort();
    <b class="hl-keyword">return</b> sortedCollection;
  }
});</pre><p>Similarly, you can extract the reusable concern to another function:</p><pre class="programlisting"><b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  comparator: <b class="hl-keyword">function</b>(task) {
    <b class="hl-keyword">return</b> task.dueDate;
  },

  byCreatedAt: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.sortedBy(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.createdAt;
    });
  },

  byCompletedAt: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.sortedBy(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.completedAt;
    });
  },

  sortedBy: <b class="hl-keyword">function</b>(comparator) {
    <b class="hl-keyword">var</b> sortedCollection = <b class="hl-keyword">new</b> Tasks(<b class="hl-keyword">this</b>.models);
    sortedCollection.comparator = comparator;
    sortedCollection.sort();
    <b class="hl-keyword">return</b> sortedCollection;
  }
});</pre><p>And then into another reusable mixin:</p><pre class="programlisting"><b class="hl-keyword">var</b> SortableCollectionMixin = {
  sortedBy: <b class="hl-keyword">function</b>(comparator) {
    <b class="hl-keyword">var</b> sortedCollection = <b class="hl-keyword">new</b> <b class="hl-keyword">this</b>.constructor(<b class="hl-keyword">this</b>.models);
    sortedCollection.comparator = comparator;
    sortedCollection.sort();
    <b class="hl-keyword">return</b> sortedCollection;
  }
};

<b class="hl-keyword">var</b> Tasks = Backbone.Collection.extend(_.extend({
  model: Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  comparator: <b class="hl-keyword">function</b>(task) {
    <b class="hl-keyword">return</b> task.dueDate;
  },

  byCreatedAt: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.sortedBy(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.createdAt;
    });
  },

  byCompletedAt: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.sortedBy(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">return</b> task.completedAt;
    });
  }
}, SortableCollectionMixin));</pre><p>TODO: Update syntax, use a separate _.extend invocation above.</p><p>Just as with the <code class="literal">FilterableCollectionMixin</code> before, the
<code class="literal">SortableCollectionMixin</code> should observe its source if updates are to propagate
from one collection to another:</p><pre class="programlisting"><b class="hl-keyword">var</b> SortableCollectionMixin = {
  sortedBy: <b class="hl-keyword">function</b>(comparator) {
    <b class="hl-keyword">var</b> sourceCollection = <b class="hl-keyword">this</b>;
    <b class="hl-keyword">var</b> sortedCollection = <b class="hl-keyword">new</b> <b class="hl-keyword">this</b>.constructor;
    sortedCollection.comparator = comparator;

    <b class="hl-keyword">var</b> applySort = <b class="hl-keyword">function</b>() {
      sortedCollection.reset(sourceCollection.models);
      sortedCollection.sort();
    };

    <b class="hl-keyword">this</b>.bind(<b class="hl-string"><i style="color:red">"change"</i></b>, applySort);
    <b class="hl-keyword">this</b>.bind(<b class="hl-string"><i style="color:red">"add"</i></b>,    applySort);
    <b class="hl-keyword">this</b>.bind(<b class="hl-string"><i style="color:red">"remove"</i></b>, applySort);

    applySort();

    <b class="hl-keyword">return</b> sortedCollection;
  }
};</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_validations"/>Validations</h3></div></div></div><p>The server is the authoritative place for verifying whether data that is being
stored is valid. Even though backbone.js
<a class="ulink" href="http://documentcloud.github.com/backbone/#Model-validate" target="_top">exposes an API</a>
for performing client side validations, when it comes to validating user data
in a backbone.js application we want to continue to use the very same
mechanisms on the server side that we’ve used in Rails all along: the
ActiveModel validations API.</p><p>The challenge is tying the two together: letting your ActiveRecord objects
reject invalid user data, and having the errors bubble up all the way to the
interface for user feedback - and having it all be seamless to the user and
easy for the developer.</p><p>Let’s wire this up. To get started, we’ll add a validation on the task’s title
attribute on the ActiveRecord model like so:</p><pre class="programlisting"><b class="hl-keyword">class</b> Task &lt; ActiveRecord::Base
  validates :title, presence: <b class="hl-keyword">true</b>
<b class="hl-keyword">end</b></pre><p>On the backbone side of the world, we have a Backbone task called
YourApp.Models.Task:</p><pre class="programlisting">YourApp.Models.Task = Backbone.Model.extend({
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>
});</pre><p>We also have a place where users enter new tasks - just a form on the task
list.</p><pre class="programlisting">&lt;form&gt;
  &lt;ul&gt;
     &lt;li <b class="hl-keyword">class</b>=<b class="hl-string"><i style="color:red">"task_title_input"</i></b>&gt;
       &lt;label <b class="hl-keyword">for</b>=<b class="hl-string"><i style="color:red">"title"</i></b>&gt;Title&lt;/label&gt;
       &lt;input id=<b class="hl-string"><i style="color:red">"title"</i></b> maxlength=<b class="hl-string"><i style="color:red">"255"</i></b> name=<b class="hl-string"><i style="color:red">"title"</i></b> type=<b class="hl-string"><i style="color:red">"text"</i></b>&gt;
     &lt;/li&gt;
     &lt;button <b class="hl-keyword">class</b>=<b class="hl-string"><i style="color:red">"submit"</i></b> id=<b class="hl-string"><i style="color:red">"create-task"</i></b>&gt;Create task&lt;/button&gt;
  &lt;/ul&gt;
&lt;/form&gt;</pre><p>On the NewTask backbone view, we bind the button’s click event to a new
function that we’ll call createTask.</p><pre class="programlisting">YourApp.Views.NewTask = Backbone.View.extend({
  events: {
    <b class="hl-string"><i style="color:red">"click #create-task"</i></b>: <b class="hl-string"><i style="color:red">"createTask"</i></b>
  },

  createTask: {
    <i class="hl-comment" style="color: silver">// grab attribute values from the form</i>
    <i class="hl-comment" style="color: silver">// storing them on the attributes hash</i>
    <b class="hl-keyword">var</b> attributes = {};
    _.each(<b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'form input, form select'</i></b>), <b class="hl-keyword">function</b>(element) {
      <b class="hl-keyword">var</b> element = $(element);
      <b class="hl-keyword">if</b>(element.attr(<b class="hl-string"><i style="color:red">'name'</i></b>) != <b class="hl-string"><i style="color:red">"commit"</i></b>) {
        attributes[element.attr(<b class="hl-string"><i style="color:red">'name'</i></b>)] = element.val();
      }
    });

    <b class="hl-keyword">var</b> self = <b class="hl-keyword">this</b>;
    <i class="hl-comment" style="color: silver">// create a new task and save it to the server</i>
    <b class="hl-keyword">new</b> YourApp.Models.Task(attributes).save({
        success: <b class="hl-keyword">function</b>() { <i class="hl-comment" style="color: silver">/* handle success */</i> }
        error:   <b class="hl-keyword">function</b>() { <i class="hl-comment" style="color: silver">/* validation error occurred, show user */</i> }
      });
    <b class="hl-keyword">return</b> false;
  }
})</pre><p>When you call save() on a backbone model, Backbone will delegate to .sync() and
create a POST request on the model’s URL where the payload are the attributes
that you’ve passed onto the save() call.</p><p>The easiest way to handle this in Rails is to use respond_to/respond_with
available in Rails 3 applciations:</p><pre class="programlisting"><b class="hl-keyword">class</b> TasksController &lt; ApplicationController
  respond_to :json
  <b class="hl-keyword">def</b> create
    task = Task.create(params)
    respond_with task
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre><p>When the task is created successfully, Rails will render the show action using
the object that you’ve passed to the respond_with call, so make sure the show
action is defined in your routes:</p><pre class="programlisting">resources :tasks, only: [:create, :show]</pre><p>When the task cannot be created successfully because some validation constraint
is not met, the the Rails responder will render the model’s errors as a JSON
object, and use an HTTP status code of 422, which will alert backbone that it
there was an error in the request and it was not processed.</p><p>The response from Rails in that case looks something like this:</p><pre class="programlisting">{ <b class="hl-string"><i style="color:red">"title"</i></b>: [<b class="hl-string"><i style="color:red">"can't be blank"</i></b>] }</pre><p>So that two line action in a Rails controller is all we need to talk to our
backbone models and handle error cases.</p><p>Back to the backbone model’s save() call, Backbone will invoke one of two
callbacks when it receives a response from the rails app, so we simply pass in
a hash containing a function to run both for the success and the error cases.</p><p>In the success case, we may want to add the new model instance to a global
collection of tasks. Backbone will trigger the add event on that collection, so
there’s your chance for some other view to bind to that event and rerender
itself so that the new task appears on the page.</p><p>In the error case, however, we want to display inline errors on the form. When
backbone triggers the error callback, it passes along two parameters: the model
being saved and the raw response. We have to parse the JSON response and
iterate through it rendering an inline error on the form corresponding to each
of the errors. Let’s introduce a couple of new classes that will help along the</p><p>First off is the ErrorList. An ErrorList encapsulates parsing of the raw JSON
that came in from the server and provides an iterator to easily loop through
errors:</p><pre class="programlisting">ErrorList = <b class="hl-keyword">function</b> (response) {
  <b class="hl-keyword">if</b> (response &amp;&amp; response.responseText) {
    <b class="hl-keyword">this</b>.attributesWithErrors = JSON.parse(response.responseText);
  }
};

_.extend(ErrorList.<b class="hl-keyword">prototype</b>, {
  each: <b class="hl-keyword">function</b> (iterator) {
    _.each(attributesWithErrors, iterator);
  },

  size: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> _.size(attributesWithErrors);
  }
});</pre><p>Next up is the ErrorView, who’s in charge of taking the errorlist, and
appending each inline error in the form, providing feedback to the user that
their input is invalid.</p><pre class="programlisting">ErrorView = Backbone.View.extend({
  initialize: <b class="hl-keyword">function</b>() {
    _.bindAll(<b class="hl-keyword">this</b>, <b class="hl-string"><i style="color:red">"renderError"</i></b>);
  },

  render: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">".error"</i></b>).removeClass(<b class="hl-string"><i style="color:red">"error"</i></b>);
    <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">"p.inline-errors"</i></b>).remove();
    <b class="hl-keyword">this</b>.options.errors.each(<b class="hl-keyword">this</b>.renderError);
  },

  renderError: <b class="hl-keyword">function</b>(errors, attribute) {
    <b class="hl-keyword">var</b> errorString = errors.join(<b class="hl-string"><i style="color:red">", "</i></b>);
    <b class="hl-keyword">var</b> field = <b class="hl-keyword">this</b>.fieldFor(attribute);
    <b class="hl-keyword">var</b> errorTag = $(<b class="hl-string"><i style="color:red">'&lt;p&gt;'</i></b>).addClass(<b class="hl-string"><i style="color:red">'inline-errors'</i></b>).text(errorString);
    field.append(errorTag);
    field.addClass(<b class="hl-string"><i style="color:red">"error"</i></b>);
  },

  fieldFor: <b class="hl-keyword">function</b>(attribute) {
    <b class="hl-keyword">return</b> $(<b class="hl-keyword">this</b>.options.el).find(<b class="hl-string"><i style="color:red">'[id*="_'</i></b> + attribute + <b class="hl-string"><i style="color:red">'_input"]'</i></b>).first();
  }
});</pre><p>Note the fieldFor function. It expects a field with an id containing a certain
format. Therefore, in order for this to work the form’s HTML must contain a
matching element. In our case, it was the list item with an id of
task_title_input.</p><p>When a backbone view’s el is already on the DOM, we need to pass it into the
view’s constructor. In the case of the ErrorView class, we want to operate on
the view that contains the form that originated the errors.</p><p>To use these classes, we take the response from the server and pass that along
to the ErrorList constructor, which we then pass to the ErrorView that will do
it’s fine job in inserting the inline errors when we call render() on it.
Putting it all together, our save call’s callbacks now look like this:</p><pre class="programlisting"><b class="hl-keyword">var</b> self = <b class="hl-keyword">this</b>;
<b class="hl-keyword">var</b> model = <b class="hl-keyword">new</b> YourApp.Models.Task(attributes);
model.save({
  error: <b class="hl-keyword">function</b>(model, response) {
    <b class="hl-keyword">var</b> errors = <b class="hl-keyword">new</b> ErrorList(response);
    <b class="hl-keyword">var</b> view   = <b class="hl-keyword">new</b> ErrorView( { el: self.el, errors: errors } );
    view.render();
  }
});</pre><p>There still is a part of this action that doesn’t feel quite right, and that’s
the fact that we are looping through the elements in a form in order to build
the attributes hash for the new object, which is an entirely separate concern.
Let’s extend the Backbone.Model prototype so that it can handle saving from
forms and we can reuse it throughout the app.</p><p>TODO: Introduce FormSerializer class or referenceBackbone.Form or some
construct for encapsulating the serialization</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_model_relationships"/>Model relationships</h3></div></div></div><p>In any non-trivial application, you will have relationships in your domain model
that are valuable to express on the client side.  For example, consider a
contact management application where each person in your contact list has many
phone numbers, each of a different kind.</p><p>Or, consider a project planning application where there are Teams, Members, and
Projects as resources (models and collections).  There are relationships between
each of these primary resources, and those relationships in turn may be exposed
as first-class resources: a Membership to link a Team and a Member, or a
Permission to link a Team with a Project.  These relationships are often exposed
as first-class models so they can be created and destroyed the same way as other
models, and so that additional domain information about the relationship, such
as a duration, rate, or quantity, can be described.</p><p>These model relationships don’t have to be persisted by a relational database.
In a chatroom application whose data is persisted in a key-value store, the data
could still be modeled as a Room which has many Messages, as well as Memberships
that link the Room to Users.  A content management application that stores its
data in a document database still has the notion of hierarchy, where a Site
contains many Pages, each of which is constitutes of zero or more Sections.</p><p>In a vanilla Rails application, the object model is describe on the server side
with ActiveRecord subclasses, and exposed to the Backbone.js client through a
JSON HTTP API.  You have a few choices to make when designing this API, largely
focused on the (bundling/locus/concordance/co-habitance/dependency/???) of data — when you handle a request for one resource, which of its associated resources
(if any) do you deliver, too?</p><p>Then, on the client side, you have a wide degree of choice in how to model the
relationships, when to eagerly pre-fetch associations and when to lazily defer
loading, and whether to employ a supporting library to help define your model
relationships.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_relations_in_the_task_app"/>Relations in the Task App</h4></div></div></div><p>In the example application, there are Users which have many Tasks through
Lists. Each Task has many Comments and Attachments.</p><div class="informalfigure"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="65%"><tr><td align="center"><img src="image/TaskAppEntityRelationships.png" align="middle" width="100%" alt="image/TaskAppEntityRelationships.png"/></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_deciding_how_to_deliver_data_to_the_client"/>Deciding how to deliver data to the client</h4></div></div></div><p>Before you decide how to model your JSON API or how to declare, your client-side model
relationships, step back and consider the user experience of your application.
For TaskApp, we decided to have interactions as follows:</p><div class="itemizedlist"><ul type="disc"><li>
A user signs up or logs in
</li><li>
The user is directed to their dashboard
</li><li>
The dashboard shows all lists and the tasks on each list, but not the
  comments or attachments.
</li><li>
When a user views the details of an individual task, the comments and
  attachments for that task are displayed.
</li></ul></div><p>This leads us to see that the Lists and Tasks for a user are used immediately
upon navigating to the dasboard, but the Comment and Attachment data for a Task
are not needed upon initial page load, and are possibly never needed at all.</p><p>Let’s say that we are also planning for the user to have continuous network
access, but not to necessarily have a high speed connection.  Also, users tend
to view their lists of tasks frequently, but rarely view the comments and
attachments.</p><p>Based on this, we will bootstrap the collections of Lists and Tasks inside the
dashboard, and defer loading of associated Comments and Attachments until after
the user clicks through to a task.</p><p>We could have selected from several other alternatives, including:</p><div class="itemizedlist"><ul type="disc"><li>
Don’t preload any information, and deliver only static assets (HTML, CSS, JS)
  on the dashboard request.  Fetch all resources over separate XHR calls.  This
  can provide for a faster initial page load, at the cost of a longer time to
  actual interactivity: although the byte size of the page plus data is roughly
  the same, the overhead of additional HTTP requests incurs the extra load time.
</li><li>
Preload all the information, including Comments and Attachments.  This would
  work well if we expected users to frequently access the comments and
  attachments of many tasks.
</li><li>
Use localStorage as the primary storage engine, and sync to the Rails server
  in the background.  This would be advantageous if we expected network access
  to be intermittent, although it incurs the additional complexity of having to
  resolve conflicts on the server if two clients submit conflicting updates.
</li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_designing_the_http_json_api"/>Designing the HTTP JSON API</h4></div></div></div><p>Now that we know we’ll bootstrap the Lists and Tasks and defer the Comments and
Associations, we should decide how to deliver the deferred content.  We have two
options here.  Our goal is to fetch to comments and attachments for an
individual task.</p><p>One way we could approach this is the issue separate API calls for each
nested resource:</p><pre class="programlisting">$ curl http://tasksapp.local:3000/tasks/78/comments.json | ppjson
[
  {
    "id": 208,
    "user_id": 3,
    "body": "What do you think of this mock? (See attachment)"
  },
  {
    "id": 209,
    "user_id": 1,
    "body": "Looks great!  I'll implement that."
  }
]

$ curl http://tasksapp.local:3000/tasks/78/attachments.json | ppjson
[
  {
    "id": "32",
    "file_url": "https://s3.amazonaws.com/tasksapp/uploads/32/mock.png"
  }
]</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>We will authenticate API requests with cookies, just like normal user
login, so the actual curl request would need to include a cookie from a logged
in user.</p></div><p>This approach has the advantage of adhering more to convention, and requiring
less code in both the server-side JSON presentation and the client-side JSON
parsing.  Its disadvantage is performance: to fetch a task’s associated data, we
need to send 2 HTTP requests.  When more kinds of associated resources are added
in the future, the number of requests will go up.</p><p>Another way we could approach this is to embed the comment and attachment data in
the JSON representation of an individual task, and deliver this data from the
"/tasks/:id" endpoint:</p><pre class="programlisting">$ curl http://tasksapp.local:3000/tasks/78.json | ppjson
{
  "id": 78,
  "user_id": 1,
  "title": "Clean up landing page",
  "comments": [
    {
      "id": 208,
      "user_id": 3,
      "body": "What do you think of this mock? (See attachment)"
    },
    {
      "id": 209,
      "user_id": 1,
      "body": "Looks great!  I'll implement that."
    }
  ]
  "attachments": [
    {
      "id": "32",
      "file_url": "https://s3.amazonaws.com/tasksapp/uploads/32/mock.png"
    }
  ],
  /* some attributes left out for clarity */
}</pre><p>This approach involves additional code in both producing the JSON on the server
side and parsing the JSON on the client side.  We’ll take this approach for the
example application, both because it requires fewer HTTP requests and because
it’s a more interesting example and illustrates the technique of parsing child
models in Backbone.js.</p><p>Now that we know we’ll bootstrap the Lists and Tasks and defer the Comments and
Associations, we know that our HTTP JSON API should support at least the
following Rails routes:</p><pre class="programlisting">resources :lists, :only =&gt; [:create, :update, :delete]
resources :tasks, :only =&gt; [:show, :create, :update, :delete]</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>In some applications, you choose to expose a user-facing API.  It’s often
valuable to dogfood this endpoint by making use of it from your own Backbone
code.  Often these APIs will be scoped under an "/api" namespace, possibly with
an API version namespace as well.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_implementing_the_api_presenting_the_json"/>Implementing the API: presenting the JSON</h4></div></div></div><p>TODO: Expand outline</p><p>Outline: For building the JSON presentation, we have a few options.  The easiest
thing is to override Task#as_json, although this isn’t really where this
presentation concern belongs.  Better options to construct the JSON include: in
the controller, in a builder-like view, in a separate presentation object.
Mention <a class="ulink" href="https://github.com/nesquena/rabl" target="_top">https://github.com/nesquena/rabl</a></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_parsing_the_json_and_instantiating_client_side_models"/>Parsing the JSON and instantiating client-side models</h4></div></div></div><p>TODO: Expand outline</p><p>Outline:  Discuss overriding Backbone Model parse() function.  Talk about how
parsing fits into the fetch/new object lifecycle.  Point out inconsistencies
(parse not invoked during reset, only fetch/set etc)
Discuss <a class="ulink" href="https://github.com/PaulUithol/Backbone-relational" target="_top">https://github.com/PaulUithol/Backbone-relational</a></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_duplicating_business_logic_across_the_client_and_server"/>Duplicating business logic across the client and server</h3></div></div></div><p>When you’re building a multi-tier application where business logic is spread
across tiers, one big challenge you face is to avoid duplicating that logic
across tiers.  There is a tradeoff here, between duplication and performance.
It’s desirable to have one and only one implementation of a partciular concern
in your domain, but it’s also desirable for your application to perform
responsively.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_an_example_model_validations"/>An example: model validations</h4></div></div></div><p>For example, let’s say that a user must have an email address.</p><p>At one end of the scale, there is no duplication: all business logic is defined
in one tier, and other tiers access the logic by remote invocation.  Your Rails
<code class="literal">Member</code> model provides a validation:</p><pre class="programlisting"><b class="hl-keyword">class</b> Member &lt; ActiveRecord::Base
  validate :email, :presence =&gt; <b class="hl-keyword">true</b>
<b class="hl-keyword">end</b></pre><p>The Backbone view attempts to persist the Member as usual, binding to its
<code class="literal">error</code> event to handle the server side error:</p><pre class="programlisting"><b class="hl-keyword">var</b> MemberFormView = Backbone.View.extend({
  events: {
    <b class="hl-string"><i style="color:red">"submit form"</i></b>: <b class="hl-string"><i style="color:red">"submit"</i></b>
  },

  initialize: <b class="hl-keyword">function</b>() {
    _.bindAll(<b class="hl-keyword">this</b>, <b class="hl-string"><i style="color:red">"error"</i></b>);
    <b class="hl-keyword">this</b>.bindTo(<b class="hl-keyword">this</b>.model, <b class="hl-string"><i style="color:red">"error"</i></b>, <b class="hl-keyword">this</b>.error);
  },

  render: <b class="hl-keyword">function</b>() {
    <i class="hl-comment" style="color: silver">// render form...</i>
  },

  submit: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> attributes = <b class="hl-keyword">new</b> FormSerializer(<b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'form'</i></b>)).attributes();
    <b class="hl-keyword">this</b>.model.save(attributes);
  },

  error: <b class="hl-keyword">function</b>(model, errorResponse) {
    <b class="hl-keyword">new</b> ErrorView(errorResponse, <b class="hl-keyword">this</b>.$(<b class="hl-string"><i style="color:red">'form'</i></b>)).render();
  }
});</pre><p>This assumes an <code class="literal">ErrorView</code> class which is able to parse the error hash returned
from Rails, which looks like this when served as JSON:</p><pre class="programlisting">{
  <b class="hl-string"><i style="color:red">"email"</i></b>: [<b class="hl-string"><i style="color:red">"can't be blank"</i></b>]
}</pre><p>An implementation of <code class="literal">ErrorView</code> might look like this:</p><pre class="programlisting"><b class="hl-keyword">var</b> ErrorView = <b class="hl-keyword">function</b>(errorResponse, form) {
  <b class="hl-keyword">this</b>.form = $(form);
  <b class="hl-keyword">this</b>.errors = JSON.parse(errorResponse.responseText);
};

_.extend(ErrorView.<b class="hl-keyword">prototype</b>, {
  render: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">this</b>.form.$(<b class="hl-string"><i style="color:red">".error"</i></b>).removeClass(<b class="hl-string"><i style="color:red">"error"</i></b>);
    <b class="hl-keyword">this</b>.form.$(<b class="hl-string"><i style="color:red">"p.inline-errors"</i></b>).remove();
    <b class="hl-keyword">this</b>.errors.each(<b class="hl-keyword">this</b>.renderError);
  },

  renderError: <b class="hl-keyword">function</b>(errors, attribute) {
    <b class="hl-keyword">var</b> errorString = errors.join(<b class="hl-string"><i style="color:red">", "</i></b>);
    <b class="hl-keyword">var</b> field = <b class="hl-keyword">this</b>.form.fieldFor(attribute);
    <b class="hl-keyword">var</b> errorTag = $(<b class="hl-string"><i style="color:red">'&lt;p&gt;'</i></b>).addClass(<b class="hl-string"><i style="color:red">'inline-errors'</i></b>).text(errorString);
    field.append(errorTag);
    field.addClass(<b class="hl-string"><i style="color:red">"error"</i></b>);
  },

  fieldFor: <b class="hl-keyword">function</b>(attribute) {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.form.find(<b class="hl-string"><i style="color:red">'[id*="_'</i></b> + attribute + <b class="hl-string"><i style="color:red">'_input"]'</i></b>).first();
  }
});</pre><p>In the case of no duplication, your Backbone <code class="literal">Member</code> model does not declare
this validation.  An user fills out a form for a creating a new Member in your
application, submits the form, and, if they forgot to include an email address,
a validation message is displayed.  The application delegates the entire
validation concern to the server, as we saw in the validations section.  TODO:
Link up that reference.</p><p>However, round-tripping validation to the server can be too slow in some cases,
and we’d like to provide feedback to the end-user more quickly.  To do this, we
have to implement the validation concern on the client side as well.  Backbone
provides a facility for validating models during their persistence, so we could
write:</p><pre class="programlisting"><b class="hl-keyword">var</b> Member = Backbone.Model.extend({
  validate: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> errors = {};
    <b class="hl-keyword">if</b> (_.isEmpty(<b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'email'</i></b>))) {
      errors.email = [<b class="hl-string"><i style="color:red">"can't be blank"</i></b>];
    }
    <b class="hl-keyword">return</b> errors;
  }
});</pre><p>Conveniently, we’ve structured the return value of the <code class="literal">validate()</code> function to
mirror the structure of the Rails error JSON we saw returned above.  Now, we
could augment the <code class="literal">ErrorView</code> class’s constructor function to handle either
client-side or server-side errors:</p><pre class="programlisting"><b class="hl-keyword">var</b> ErrorView = <b class="hl-keyword">function</b>(responseOrErrors, form) {
  <b class="hl-keyword">this</b>.form = $(form);

  <b class="hl-keyword">if</b> (responseOrErrors &amp;&amp; responseOrErrors.responseText) {
    <b class="hl-keyword">this</b>.errors = JSON.parse(responseOrErrors.responseText);
  } <b class="hl-keyword">else</b> {
    <b class="hl-keyword">this</b>.errors = responseOrErrors;
  }
};</pre><p>Now, with Backbone, the <code class="literal">validate()</code> function is called for each invocation of
<code class="literal">set()</code>, so as soon as we set the email address on the Member, its presence is
validated.  For the user experience with the quickest response, we could observe
changes on the email form field, updating the model’s <code class="literal">email</code> attribute whenever
it changes, and displaying the inline error message immediately.</p><p>With ErrorView able to handle either client-side or server-side error messages,
we have a server-side guarantee of data correctness, <sup>[<a id="d0e2512" href="#ftn.d0e2512" class="footnote">1</a>]</sup> and a responsive UI that can validate the Member email presence
without round-tripping to the server.</p><p>The tradeoff we’ve made is that of duplication; the concern of "what constituted
a valid Member" is written twice — in two different languages, no less.  In
some cases this is unavoidable.  In others, there are mitigation strategies for
reducing the duplication, or at least its impact on your code quality.</p><p>Let’s take a look at what kinds of logic you might find duplicated, and then
strategies for reducing duplication.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_kinds_of_logic_you_duplicate"/>Kinds of logic you duplicate</h4></div></div></div><p>In Rails applications, our model layer can contain a variety of kinds of
business logic:</p><div class="itemizedlist"><ul type="disc"><li>
Validations - This is pretty straightforward, since there’s a well-defined
  Rails API for validating ActiveModel classes.
</li><li>
Querying - Sorting and filtering fall into this category.  Implementations
  vary slightly, but are often built with <code class="literal">named_scope</code> or class methods
  returning <code class="literal">ActiveRecord::Relation</code> instances.  Occasionally querying is
  delegated to class other than the ActiveRecord instance.
</li><li>
Callbacks - Similar to validations, there’s a well-defined API for callbacks
  (or "lifecycle events") on Rails models; <code class="literal">after_create</code> and such.
</li><li>
Algorithms - Everything else.  Sometimes they’re implemented on the
  ActiveRecord instances, but are often split out into other classes and used via
  composition.  One example from commerce apps would be an <code class="literal">Order</code> summing the
  costs of its <code class="literal">LineItems</code>.  Or consider an example from an agile project planning
  application, where a <code class="literal">ProjectPlan</code> recalculates a <code class="literal">Project</code>'s set of <code class="literal">UserStory</code>
  objects into weekly <code class="literal">Iteration</code> bucket objects.
</li></ul></div><p>There are often other methods on your Rails models, but they either are a mix of
the above categories (a <code class="literal">state_machine</code> implementation could be considered a mix
of validations and callback) and other methods that don’t count as business
logic — methods that are actually implementing presentation concerns are a
frequent example.</p><p>It’s worth considering each of these categories in turn, and how they can be
distributed across client and server to provide a responsive experience.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_validations_2"/>Validations</h4></div></div></div><p>Validations are probably the lowest-hanging fruit.  Since the API for declaring
validations is largely declarative and well-bounded, we can imagine providing an
interface that introspects Rails models and builds a client-side implementation
automatically.  Certainly there are cases which aren’t automatable, such as
custom Ruby validation code or validations which depend on a very large dataset
that would be impractical to deliver to the client (say, a zipcode database).
These cases would need to fall back to either an XHR call to the server-side
implementation, or a custom-written client-side implementation - a duplicate
implementation.</p><p>TODO: This is actually what the
<a class="ulink" href="https://github.com/bcardarella/client_side_validations" target="_top">client_side_validations gem</a>
does…</p><p>TODO: The csv model branch is a wip for Backbone compliance, pretty neat:
<a class="ulink" href="https://github.com/bcardarella/client_side_validations/tree/model" target="_top">https://github.com/bcardarella/client_side_validations/tree/model</a></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_querying"/>Querying</h4></div></div></div><p>TODO: Expand on outline.</p><p>Outline: I think it’s possible to establish conventions here, similar to
validations, so that server-side scopes can be converted to client-side
collection filtering.  However, is this valuable?  Do you actually often
duplicate the same querying (sorting/filter) concerns across client and server?</p><p>Also, since this whole discussion is about perf, consider tradeoff of paginating
anyways, that’s interesting, so can you reduce duplication and generate code
with that too?</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_callbacks"/>Callbacks</h4></div></div></div><p>TODO: Expand on outline.</p><p>Outline: These often depend on server-side persistence, so would you even want
them on the client side?  Perhaps, e.g. same lifecycle events for the analagous
client-side models, but it’s actually likely that your client-side models will
differ sufficiently (since they’re in the presentation tier) from server-side
models that these concerns won’t be duplicates, so it’s less of a worry.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_algorithms"/>Algorithms</h4></div></div></div><p>TODO: Expand on outline.</p><p>Outline: General algorithms are often the trickiest. It’s possibly to write the
logic in JS and then make that available to Ruby, if you have a REALLY large
piece of logic, but weigh the cost of that overhead against the cost of
duplicating the logic.  At some point it probably makes sense, though.  Also
consider JS server-side and wrapping that as a webservice for Rails access…
would that be easier?  Need specific examples to motivate this well.</p><p><a class="ulink" href="http://c2.com/cgi/wiki?HalfObjectPlusProtocol" target="_top">http://c2.com/cgi/wiki?HalfObjectPlusProtocol</a>
<a class="ulink" href="http://c2.com/cgi/wiki?HoppPatternLanguage" target="_top">http://c2.com/cgi/wiki?HoppPatternLanguage</a></p><p>TODO: The ErrorList/ErrorView implementation here isn’t quite consistent with
those in the prior validations chapter.  Refactor for consistency or, if that’s
inappropriate, do a better job explaining the changes.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_synchronizing_between_clients"/>Synchronizing between clients</h3></div></div></div><p>A big driving force behind the move to rich client web apps is to improve the user experience. These applications are more responsive and can support more detailed and stateful interactions.</p><p>One such interaction involves multiple concurrent users interacting with the same resource in realtime. We can deliver a more seamless experience by propagating users' changes to one another as they take place: when we edit the same document, I see your changes on my screen as you type them. If you’ve ever used Google Docs or Google Wave, you’ve seen this in action.</p><p>So, how can we build this functionality into our own applications?</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_the_moving_parts"/>The moving parts</h4></div></div></div><p>There are a few different pieces that we’ll put together for this.  The basic parts are:</p><div class="orderedlist"><ol type="1"><li>
Change events. The fundamental unit of information that we broadcast through our system to keep clients in sync.  Delivered as messages, these events contain enough information for any receiving client to update its own data without needing a full re-fetch from the server.
</li><li>
An event source.  With trusted clients, changes can originate directly from the client.  More often, however, we will want the server to arbitrate changes so that it can apply authorization, data filtering, and validations.
</li><li>
A transport layer that supports pushing to clients.  <a class="ulink" href="http://www.w3.org/TR/websockets/" target="_top">The WebSocket API</a> is such a transport, and is ideal for its low overhead and latency.
</li><li>
Event-driven clients.  Clients should be able to react to incoming change events, ideally handling them with incremental UI updates rather than re-drawing themselves entirely.  Backbone.js helps out in this department, as your client-side application app is likely already set up to handle such events.
</li><li>
A message bus.  Separating the concern of message delivery from our main application helps it stay smaller and helps us scale our messaging and application infrastructure separately. There are already several great off-the-shelf tools we can use for this.
</li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_putting_it_together_a_look_at_the_lifecycle_of_a_change"/>Putting it together: a look at the lifecycle of a change</h4></div></div></div><p>Revisiting our todo application, we’d like to add the ability to collaborate on todo lists.  Different users will be able to work on the same todo list concurrently.  Several users can look at the same list; adding, changing, and checking off items.</p><p>There are a few technical decisions mentioned previously.  For this example, we will:</p><div class="orderedlist"><ol type="1"><li>
Use Rails on the server and Backbone on the client.
</li><li>
Use the server as the canonical event source so that clients do not have to trust one another.  In particular, we’ll employ an <code class="literal">ActiveRecord::Observer</code> that observes Rails model changes and dispatches a change event.
</li><li>
Use <a class="ulink" href="http://faye.jcoglan.com" target="_top">Faye</a> as the messaging backend, which has Ruby and JavaScript implementations for clients and server.  Faye implements the <a class="ulink" href="http://svn.cometd.com/trunk/bayeux/bayeux.html" target="_top">Bayeux protocol</a>, prefers WebSocket for transport (thought it gracefully degrades to long polling, CORS, or JSON-P), and supports a bunch of other goodies like clustering and extensions (inbound- and outbound- message filtering, like Rack middleware).
</li></ol></div><p>In our application, there are several connected clients viewing the same todo list, and one user Alice makes a change to an item on the list.</p><p>Let’s take a look at the lifecycle of one change event.</p><p>TODO: System-partitioned sequence diagram</p><p>Setup:</p><div class="orderedlist"><ol type="1"><li>
An instance of JavaScript class <code class="literal">BackboneSync.FayeSubscriber</code> is instantiated on each client.  It is configured with a channel to listen to, and a collection to update.
</li><li>
The Faye server is started.
</li><li>
The Rails server is started, and several clients are connected and viewing <code class="literal">#todo_lists/1</code>.
</li></ol></div><p>On the Alice’s machine, the client responsible for the change:</p><div class="orderedlist"><ol type="1"><li>
Alice clicks "Save" in her view of the list.
</li><li>
The "save" view event is triggered.
</li><li>
The event handler invokes <code class="literal">this.model.save(attributes)</code>.
</li><li>
<code class="literal">Backbone.Model.prototype.save</code> calls <code class="literal">Backbone.sync</code>.
</li><li>
<code class="literal">Backbone.sync</code> invokes <code class="literal">$.ajax</code> and issues an HTTP PUT request to the server.
</li></ol></div><p>On the server:</p><div class="orderedlist"><ol type="1"><li>
Rails handles the PUT request and calls <code class="literal">#update_attributes</code> on an ActiveRecord model instance.
</li><li>
An <code class="literal">ActiveRecord::Observer</code> observing this model gets its <code class="literal">#after_save</code> method invoked.
</li><li>
The observer dispatches a change event message to Faye.
</li><li>
Faye broadcasts the change event to all subscribers.
</li></ol></div><p>On all clients:</p><div class="orderedlist"><ol type="1"><li>
<code class="literal">FayeSubscriber</code> receives the change event message, likely over a WebSocket.
</li><li>
The subscriber parses the event message, picking out the event (<code class="literal">update</code>), the <code class="literal">id</code> of the model to update, and a new set of attributes to apply.
</li><li>
The <code class="literal">FayeSubscriber</code> fetches the model from the collection, and calls <code class="literal">set</code> on it to update its attributes.
</li></ol></div><p>Now all the clients have received the changeset that Alice made.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_implementation_step_1_faye_server"/>Implementation: Step 1, Faye server</h4></div></div></div><p>We’ll need to run Faye to relay messages from publishers to subscribers.  For
Rails apps that depend on Faye, I like to keep a <code class="literal">faye/</code> subdirectory under the
app root that contains a <code class="literal">Gemfile</code> and <code class="literal">config.ru</code>, and maybe a shell script to
start Faye:</p><pre class="programlisting">$ cat faye/Gemfile

source 'http://rubygems.org'
gem 'faye'

$ cat faye/config.ru

require 'faye'
bayeux = Faye::RackAdapter.new(:mount =&gt; '/faye', :timeout =&gt; 25)
bayeux.listen(9292)

$ cat faye/run.sh

#!/usr/bin/env bash
BASEDIR=$(dirname $0)
BUNDLE_GEMFILE=$BASEDIR/Gemfile
bundle exec rackup $BASEDIR/config.ru -s thin -E production

$ ./faye/run.sh

&gt;&gt; Thin web server (v1.2.11 codename Bat-Shit Crazy)
&gt;&gt; Maximum connections set to 1024
&gt;&gt; Listening on 0.0.0.0:9292, CTRL+C to stop</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_implementing_it_step_2_activerecord_observers"/>Implementing it: Step 2, ActiveRecord observers</h4></div></div></div><p>Now that the message bus is running, let’s walk through the server code.  The
Rails app’s responsibility is this: whenever a Todo model is created, updated,
or deleted, publish a change event message.</p><p>This is implemented with an ActiveRecord::Observer.  We provide the
functionality in a module:</p><pre class="programlisting"><b class="hl-keyword">module</b> BackboneSync
  <b class="hl-keyword">module</b> Rails
    <b class="hl-keyword">module</b> Faye
      mattr_accessor :root_address
      <b class="hl-keyword">self</b>.root_address = <b class="hl-string"><i style="color:red">'http://localhost:9292'</i></b>

      <b class="hl-keyword">module</b> Observer
        <b class="hl-keyword">def</b> after_update(model)
          Event.new(model, :update).publish
        <b class="hl-keyword">end</b>

        <b class="hl-keyword">def</b> after_create(model)
          Event.new(model, :create).publish
        <b class="hl-keyword">end</b>

        <b class="hl-keyword">def</b> after_destroy(model)
          Event.new(model, :destroy).publish
        <b class="hl-keyword">end</b>
      <b class="hl-keyword">end</b>

      <b class="hl-keyword">class</b> Event
        <b class="hl-keyword">def</b> initialize(model, event)
          @model = model
          @event = event
        <b class="hl-keyword">end</b>

        <b class="hl-keyword">def</b> broadcast
          Net::HTTP.post_form(uri, :message =&gt; message)
        <b class="hl-keyword">end</b>

        private

        <b class="hl-keyword">def</b> uri
          URI.parse(<b class="hl-string"><i style="color:red">"#{BackboneSync::Rails::Faye.root_address}/faye"</i></b>)
        <b class="hl-keyword">end</b>

        <b class="hl-keyword">def</b> message
          { :channel =&gt; channel,
            :data =&gt; data          }.to_json
        <b class="hl-keyword">end</b>

        <b class="hl-keyword">def</b> channel
          <b class="hl-string"><i style="color:red">"/sync/#{@model.class.table_name}"</i></b>
        <b class="hl-keyword">end</b>

        <b class="hl-keyword">def</b> data
          { @event =&gt; { @model.id =&gt; @model.as_json } }
        <b class="hl-keyword">end</b>
      <b class="hl-keyword">end</b>
    <b class="hl-keyword">end</b>
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre><p>and then mix it into a concrete Observer class in our application.  In this
case, we name it <code class="literal">TodoObserver</code>:</p><pre class="programlisting"><b class="hl-keyword">class</b> TodoObserver &lt; ActiveRecord::Observer
  include BackboneSync::Rails::Faye::Observer
<b class="hl-keyword">end</b></pre><p>This observer is triggered each time a Rails <code class="literal">Todo</code> model is created, updated,
or destroyed.  When one of these events happen, the Observer sends along a
message to our message bus, indicating the change.</p><p>Let’s say that a <code class="literal">Todo</code> was just created:</p><p>&gt;&gt; Todo.create(title: "Buy some tasty kale juice")
⇒ #&lt;Todo id: 17, title: "Buy some tasty kale juice", created_at: "2011-09-06 20:49:03", updated_at: "2011-09-07 15:01:09"&gt;</p><p>The message looks like this:</p><pre class="programlisting">{
  <b class="hl-string"><i style="color:red">"channel"</i></b>: <b class="hl-string"><i style="color:red">"/sync/todos"</i></b>,
  <b class="hl-string"><i style="color:red">"data"</i></b>: {
    <b class="hl-string"><i style="color:red">"create"</i></b>: {
      <b class="hl-string"><i style="color:red">"17"</i></b>: {
        <b class="hl-string"><i style="color:red">"id"</i></b>: <span class="hl-number">17</span>,
        <b class="hl-string"><i style="color:red">"title"</i></b>: <b class="hl-string"><i style="color:red">"Buy some tasty kale juice"</i></b>,
        <b class="hl-string"><i style="color:red">"created_at"</i></b>: <b class="hl-string"><i style="color:red">"2011-09-06T20:49:03Z"</i></b>,
        <b class="hl-string"><i style="color:red">"updated_at"</i></b>: <b class="hl-string"><i style="color:red">"2011-09-07T15:01:09Z"</i></b>
      }
    }
  }
}</pre><p>Received by Faye, the message is broadcast to all clients subscribing to the
<code class="literal">/sync/todos</code> channel, including our browser-side <code class="literal">FayeSubscriber</code> objects.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_implementing_it_step_3_in_browser_subscribers"/>Implementing it: Step 3, In-browser subscribers</h4></div></div></div><p>In each browser, we want to connect to the Faye server, subscribe to events on
channels that interest us, and update Backbone collections based on those
messages.</p><p>Faye runs an HTTP server, and serves up its own client library, so that’s easy to pull in:</p><pre class="programlisting"><b class="hl-tag" style="color: #000096">&lt;script</b> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"text/javascript"</span> <span class="hl-attribute" style="color: #F5844C">src</span>=<span class="hl-value" style="color: #993300">"http://localhost:9292/faye.js"</span><b class="hl-tag" style="color: #000096">&gt;</b><b class="hl-tag" style="color: #000096">&lt;/script&gt;</b></pre><p>To subscribe to Faye channels, instantiate a <code class="literal">Faye.Client</code> and call <code class="literal">subscribe</code> on it:</p><pre class="programlisting"><b class="hl-keyword">var</b> client = <b class="hl-keyword">new</b> Faye.Client(<b class="hl-string"><i style="color:red">'http://localhost:9292/faye'</i></b>);
client.subscribe(<b class="hl-string"><i style="color:red">'/some/channel'</i></b>, <b class="hl-keyword">function</b>(message) {
  <i class="hl-comment" style="color: silver">// handle message</i>
});</pre><p>When the browser receives messages from Faye, we want to update a Backbone
collection.  Let’s wrap up those two concerns into a <code class="literal">FayeSubscriber</code>:</p><pre class="programlisting"><b class="hl-keyword">this</b>.BackboneSync = <b class="hl-keyword">this</b>.BackboneSync || {};

BackboneSync.RailsFayeSubscriber = (<b class="hl-keyword">function</b>() {
  <b class="hl-keyword">function</b> RailsFayeSubscriber(collection, options) {
    <b class="hl-keyword">this</b>.collection = collection;
    <b class="hl-keyword">this</b>.client = <b class="hl-keyword">new</b> Faye.Client(<b class="hl-string"><i style="color:red">'&lt;%= BackboneSync::Rails::Faye.root_address %&gt;/faye'</i></b>);
    <b class="hl-keyword">this</b>.channel = options.channel;
    <b class="hl-keyword">this</b>.subscribe();
  }

  RailsFayeSubscriber.<b class="hl-keyword">prototype</b>.subscribe = <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.client.subscribe(<b class="hl-string"><i style="color:red">"/sync/"</i></b> + <b class="hl-keyword">this</b>.channel, _.bind(<b class="hl-keyword">this</b>.receive, <b class="hl-keyword">this</b>));
  };

  RailsFayeSubscriber.<b class="hl-keyword">prototype</b>.receive = <b class="hl-keyword">function</b>(message) {
    <b class="hl-keyword">var</b> self = <b class="hl-keyword">this</b>;
    <b class="hl-keyword">return</b> $.each(message, <b class="hl-keyword">function</b>(event, eventArguments) {
      <b class="hl-keyword">return</b> self[event](eventArguments);
    });
  };

  RailsFayeSubscriber.<b class="hl-keyword">prototype</b>.update = <b class="hl-keyword">function</b>(params) {
    <b class="hl-keyword">var</b> self = <b class="hl-keyword">this</b>;
    <b class="hl-keyword">return</b> $.each(params, <b class="hl-keyword">function</b>(id, attributes) {
      <b class="hl-keyword">var</b> model = self.collection.get(id);
      <b class="hl-keyword">return</b> model.set(attributes);
    });
  };

  RailsFayeSubscriber.<b class="hl-keyword">prototype</b>.create = <b class="hl-keyword">function</b>(params) {
    <b class="hl-keyword">var</b> self = <b class="hl-keyword">this</b>;
    <b class="hl-keyword">return</b> $.each(params, <b class="hl-keyword">function</b>(id, attributes) {
      <b class="hl-keyword">var</b> model = <b class="hl-keyword">new</b> self.collection.model(attributes);
      <b class="hl-keyword">return</b> self.collection.add(model);
    });
  };

  RailsFayeSubscriber.<b class="hl-keyword">prototype</b>.destroy = <b class="hl-keyword">function</b>(params) {
    <b class="hl-keyword">var</b> self = <b class="hl-keyword">this</b>;
    <b class="hl-keyword">return</b> $.each(params, <b class="hl-keyword">function</b>(id, attributes) {
      <b class="hl-keyword">var</b> model = self.collection.get(id);
      <b class="hl-keyword">return</b> self.collection.remove(model);
    });
  };

  <b class="hl-keyword">return</b> RailsFayeSubscriber;
})();</pre><p>Now, for each collection that we’d like to keep in sync, we instantiate a
corresponding <code class="literal">FayeSubscriber</code>.  Say, in your application bootstrap code:</p><pre class="programlisting">MyApp.Routers.TodosRouter = Backbone.Router.extend({
  initialize: <b class="hl-keyword">function</b>(options) {
    <b class="hl-keyword">this</b>.todos = <b class="hl-keyword">new</b> Todos.Collections.TodosCollection();
    <b class="hl-keyword">new</b> BackboneSync.FayeSubscriber(<b class="hl-keyword">this</b>.todos, { channel: <b class="hl-string"><i style="color:red">'todos'</i></b> });
    <b class="hl-keyword">this</b>.todos.reset(options.todos);
  },

  <i class="hl-comment" style="color: silver">// ...</i>
});</pre><p>Now run the app, and watch browsers receive push updates!</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_testing_synchronization"/>Testing synchronization</h4></div></div></div><p>TODO: Testing client-client sync.  <code class="literal">Capybara.using_session</code> for multiple concurrent actors.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_more_reading"/>More reading</h4></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Faye implements a messaging protocol called Bayeux: <a class="ulink" href="http://svn.cometd.com/trunk/bayeux/bayeux.html" target="_top">http://svn.cometd.com/trunk/bayeux/bayeux.html</a></p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Read up on idempotent messages.  Check out this solid, readable article <a class="ulink" href="http://devhawk.net/2007/11/09/the-importance-of-idempotence/" target="_top">The Importance of Idempotence</a>.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_uploading_attachments_chapter_unstarted"/>Uploading attachments (Chapter unstarted)</h3></div></div></div><p>Notes:</p><p>If you upload to a backbone model, you can’t do it in a typical async request.
As in, someBackboneModel.save() can’t just send a file to the server like other
attributes. We save the attachment in a separate request, and then just swap in
an attachment id on the model. This does mean that you can have "unclaimed"
attachments if somebody bails before saving the parent model, but that’s not
really an issue.</p><p>Assumes XHR2 (at least FormData) so no IE, but simple impl:
* <a class="ulink" href="https://github.com/mockenoff/HTML5-AJAX-File-Uploader" target="_top">https://github.com/mockenoff/HTML5-AJAX-File-Uploader</a>
* <a class="ulink" href="https://developer.mozilla.org/en/XMLHttpRequest/FormData" target="_top">https://developer.mozilla.org/en/XMLHttpRequest/FormData</a></p></div><div class="footnotes"><br/><hr width="100" align="left"/><div class="footnote"><p><sup>[<a id="ftn.d0e2512" href="#d0e2512" class="simpara">1</a>] </sup>At least, we
have a guarantee at the application level - database integrity and the
possibility of skew between Rails models and DB content is another discussion
entirely.</p></div></div></div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s05.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s07.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Routers, Views, and Templates </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Testing</td></tr></table></div></body></html>