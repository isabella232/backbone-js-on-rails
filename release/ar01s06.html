<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Routers, Views, and Templates</title><link rel="stylesheet" href="stylesheets/handbookish.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.74.1" /><link rel="home" href="index.html" title="Backbone.js on Rails" /><link rel="up" href="index.html" title="Backbone.js on Rails" /><link rel="prev" href="ar01s05.html" title="Rails Integration" /><link rel="next" href="ar01s07.html" title="Models and collections" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Routers, Views, and Templates</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s05.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s07.html">Next</a></td></tr></table><hr /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_routers_views_and_templates"></a>Routers, Views, and Templates</h2></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_view_explanation"></a>View explanation</h3></div></div></div><p>A Backbone.js view is a class that is responsible for rendering the display of
a logical element on the page. A view can also bind to events which may cause
it to be re-rendered.</p><p>Its important to note that a Rails view is not directly analogous to a
Backbone.js view. A Rails view is more like a Backbone.js template, and
Backbone.js views are often more like Rails controllers, in that they are
responsible for logic about what should be rendered and how and rendering the
actual template file. This can cause confusion with developers just started
with Backbone.js.</p><p>A basic Backbone.js view appears as follows.</p><pre class="programlisting">ExampleApp.Views.ExampleView = Backbone.View.extend({
  tagName: "li",

  className: "example",

  id: "example_view",

  events: {
    "click a.save": "save"
  },

  initialize: function() {
    this.render();
  },

  render: function() {
    $(this.el).html(JST['example/view']({ model:  }));
    $('body').html(this.el);

    return this;
  },

  save: function() {
    // do something
  }
};</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_initialization"></a>Initialization</h4></div></div></div><p>The Backbone.js view above has an initialize function which will be called
when the view is instantiated.</p><p>You only need to specify the initialize function if you wish to do something
custom. For example, the above view’s initialize function calls the render
function of the view. It’s not necessary to immediately render upon
initialization, but it’s relatively common to do so.</p><p>You create a new view by instantiating it with <code class="literal">new</code>. For example <code class="literal">new
ExampleView()</code>. It is possible to pass in a hash of options with <code class="literal">new
ExampleView(options)</code>. Any options you pass into the constructor will be
available inside of the view in <code class="literal">this.options</code>.</p><p>There are a few special options that, when passed, will be assigned to other
members in the view directly. These are <code class="literal">model</code>, <code class="literal">collection</code>, <code class="literal">el</code>, <code class="literal">id</code>,
<code class="literal">className</code>, and <code class="literal">tagName</code>. For example, if you create a new view and give it
a model option with <code class="literal">new ExampleView({ model: Task })</code> then inside of the view
the model you passed in as an option will be available in <code class="literal">this.model</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_the_view_8217_s_element"></a>The View’s Element</h4></div></div></div><p>Each Backbone.js view has an element which is stores in <code class="literal">this.el</code>. This element
can be populated with content, but isn’t on the page until placed there by
you. Using this strategy it is then possible to render views outside of the
current DOM at any time, inserting the new elements all at once. In this way,
high performance rendering of views can be achieved with as few reflows and
repaints as possible.</p><p>It is possible to create a view that references an element already in the DOM,
instead of a new element. To do this, pass in the existing element as an
option to the view constructor with <code class="literal">new ExampleView({ el: existingElement })</code>.</p><p>You can use <code class="literal">tagName</code>, <code class="literal">className</code>, and <code class="literal">id</code> to customize the new element
created for the view. If no customization is done, the element is an empty
<code class="literal">div</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_customizing_the_view_8217_s_element"></a>Customizing the View’s Element</h4></div></div></div><p>You can use <code class="literal">tagName</code>, <code class="literal">className</code>, and <code class="literal">id</code> to customize the new element
created for the view. If no customization is done, the element is an empty
<code class="literal">div</code>.</p><p><code class="literal">tagName</code>, <code class="literal">className</code>, and <code class="literal">id</code> can either be specified directly on the view
or passed in as options at instantiation time. Since <code class="literal">id</code> is likely to be
individual to each model, its most likely to pass that in as an option rather
than declaring it statically in the view.</p><p><code class="literal">tagName</code> will change the element that is created from a <code class="literal">div</code> to something
else that you specify. For example, setting <code class="literal">tagName: "li"</code> will result in the
view’s element being an <code class="literal">li</code> rather than a <code class="literal">div</code>.</p><p><code class="literal">className</code> will add an additional class to the element that is created for
the view. For example, setting <code class="literal">className: "example"</code> on the view will result
in view’s element with that additional class like <code class="literal">&lt;div class="example"&gt;</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_rendering"></a>Rendering</h4></div></div></div><p>The <code class="literal">render</code> function above renders the <code class="literal">example/view</code> template. Template
rendering is covered in depth in the "Templating strategy" chapter. Suffice to
say, nearly every view’s render function will render some form of template. Once
that template is rendered, any other actions to modify the view may be taken.</p><p>Typical functionality in <code class="literal">render</code> in addition to rendering a template would be
to add additional classes or attributes to <code class="literal">this.el</code> or fire or bind other
events.</p><p>Backbone.js, when used with jQuery (or Zepto) provides a convenience function
of <code class="literal">this.$</code> that can be used for selecting elements inside of the view.
<code class="literal">this.$(selector)</code> is equivalent to the jQuery function call <code class="literal">$(selector,
this.el)</code></p><p>A nice convention of the render function is to return <code class="literal">this</code> at the end of
render to enable chained calls on the view.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_events"></a>Events</h4></div></div></div><p>The view’s <code class="literal">events</code> hash specifies a mapping of the events and elements that
should have events bound, and the functions that should be bound to those
events. In the example above the <code class="literal">click</code> event is being bound to the
element(s) that match the selector <code class="literal">a.save</code> within the view’s element. When
that event fires, the <code class="literal">save</code> function will be called on the view.</p><p>Events bound automatically with the <code class="literal">events</code> hash, the DOM events are bound
with the <code class="literal">$.delegate()</code> function. Backbone.js also takes care of binding the
event handlers' <code class="literal">this</code> to the view instance using <code class="literal">_.bind()</code>.</p><p>Event binding is covered in great detail in the "Event binding" chapter.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_templating_strategy_chapter_unstarted"></a>Templating strategy (chapter unstarted)</h3></div></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_routers"></a>Routers</h3></div></div></div><p>Routers are an important part of the Backbone.js infrastructure. Backbone.js
routers provide methods for routing application flow based on client-side URL
fragments (#fragment).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Backbone.js now includes support for pushState, which can use real, full URLs
instead of url fragments for routing.</p><p>However, pushState support in Backbone.js is fully opt-in due to lack of
browser support and that additional server-side work is required to support it.</p><p>pushState support is current limited to the latest versions of Firefox,
Chrome, and Safari and Mobile Safari. For a full listing of support and more
information about the History API, of which pushState is a part, visit
<a class="ulink" href="http://diveintohtml5.org/history.html#how" target="_top">http://diveintohtml5.org/history.html#how</a></p><p>Thankfully, if you opt-in to pushState in Backbone.js, browsers that don’t
support pushState will continue to use hash-based URL fragments, and if a hash
URL is visited by a pushState-capable browser, it will be transparently
upgraded to the true URL.</p><p>In addition to browser support, another hurdle to seamless use of pushState is
that because the URL used are real URLs, your server must now how to render
each of the URLs. For example, if your Backbone.js application has a route of
/tasks/1, your server-side application must be able to respond to that page if
the browser visits that URL directly.</p><p>For most applications, you can handle this by just rendering the content you
would have for the root URL and letting Backbone.js handle the rest of the
routing to the proper location. But for full search-engine crawlability, your
server-side application will need to render the entire HTML of the requested page.</p><p>For all the reasons and complications above, the examples in this book all
currently use URL fragments and not pushState.</p></div><p>A typical Backbone.js router will appear as shown below.</p><pre class="programlisting">ExampleApp.Routers.ExampleRouter = Backbone.Router.extend({
  routes: {
    ""         : "index"
    "show/:id" : "show"
  },

  index: function() {
    // Render the index view
  }

  show: function(id) {
    // Render the show view
  }
});</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_the_routes_hash"></a>The Routes Hash</h4></div></div></div><p>The basic router consists of a routes hash which is a mapping between URL
fragments and methods on the router. If the current URL fragment, or one that
is being visited matches one of the routes in the hash, its method will be
called.</p><p>Like Rails routes, Backbone.js routes can contain parameter parts, as seen in
the <code class="literal">show</code> route in the example above. In this route, the part of the fragment
after <code class="literal">show/</code> will then be based as an argument to the <code class="literal">show</code> method.</p><p>Multiple parameters are possible, as well. For example, a route of
<code class="literal">search/:query/p:page</code> will match a fragment of <code class="literal">search/completed/p2</code> passing
passing <code class="literal">completed</code> and <code class="literal">2</code> to the action.</p><p>In the routes, <code class="literal">/</code> is the natural separator. For example, a route of
<code class="literal">show/:id</code> will not match a fragment of <code class="literal">show/1/2</code>. To match through route,
Backbone.js provides the concept of splat parts, identified by <code class="literal">*</code> instead of
<code class="literal">:</code>. For example, a route of <code class="literal">show/*id</code> would match the previous fragment, and
<code class="literal">1/2</code> would be passed to the action as the <code class="literal">id</code> variable.</p><p>Routing occurs when the browser’s URL changes. This can occur when clicking on
a link, entering a URL into the browser’s URL bar, or clicking the back
button. In all of those cases, Backbone.js will look to see if the new URL
matches an existing route. If it does, the specified function will be called
with any parameters.</p><p>In addition, an event with the name of "route" and the function will be
triggered. For example, when the <code class="literal">show</code> route above is routed, an event of
<code class="literal">route:show</code> will be fired. This is so that other objects can listen to the
router, and be notified about certain routes.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_initializing_a_router"></a>Initializing a Router</h4></div></div></div><p>It is possible to specify an <code class="literal">initialize</code> function in a Router which will be
called when the Router is instantiated. Any arguments passed to the Routes
constructor will be passed to this <code class="literal">initialize</code> function.</p><p>Additionally, it is possible to pass the routes for a router via the
constructor like <code class="literal">new ExampleRouter({ routes: { "" : "index" }}</code>. But note
that this will override any routes defined in the routes hash on the router
itself.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_view_helpers_chapter_unstarted"></a>View helpers (chapter unstarted)</h3></div></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_form_helpers_chapter_unstarted"></a>Form helpers (chapter unstarted)</h3></div></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_event_binding"></a>Event binding</h3></div></div></div><p>A big part of writing snappy rich client applications is building models and
views that update in real-time with respect to one another.  With Backbone.js
you accomplish this with events.</p><p>TODO: This is probably the first time we dive into events, unless we touch on
them earlier in the models/collections sections.  Might want to introduce the
topic with a basic example that uses <code class="literal">Backbone.Events</code> without views &amp; models.</p><p>There are three primary kinds of events that your views will bind to:</p><div class="itemizedlist"><ul type="disc"><li>
DOM events within the view’s <code class="literal">this.el</code> element
</li><li>
Backbone events triggered by the view’s model or collection
</li><li>
Custom view events
</li></ul></div><p>TODO: This three-point breakdown is the wrong way to slice this.  Instead of
"DOM, model/collection, custom" it should be "DOM, events I observe, events I
publish".  Events that your view observes need to be cleaned up upon disposing
the view, regardless of where those events are triggered (models, collections,
or other views, or other arbitrary objects).  Events that your view publishes
need to be handled in a different way.</p><p>TODO: Consider promoting events and binding/unbinding to its own top-level
section; this isn’t view-specific, although the view layer is where you’ll be
doing most of your binding.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_binding_to_dom_events_within_the_view_element"></a>Binding to DOM events within the view element</h4></div></div></div><p>The primary function of a view class is to provide behavior for its markup’s DOM elements.  You can attach event listeners by hand if you like:</p><pre class="programlisting">&lt;!-- templates/soundboard.jst --&gt;
&lt;a class="sound"&gt;Honk&lt;/a&gt;
&lt;a class="sound"&gt;Beep&lt;/a&gt;</pre><pre class="programlisting">var SoundBoard = Backbone.View.extend({
  render: function() {
    $(this.el).html(JST['soundboard']());
    this.$("a.sound").bind("click", this.playSound);
  },

  playSound: function() {
    // play sound for this element
  }
});</pre><p>But Backbone provides an easier and more declarative approach with the <code class="literal">events</code> hash:</p><pre class="programlisting">var SoundBoard = Backbone.View.extend({
  events: {
    "click a.sound": "playSound"
  },

  render: function() {
    $(this.el).html(JST['soundboard']());
  },

  playSound: function() {
    // play sound for this element
  }
});</pre><p>Backbone will bind the events with the
<a class="ulink" href="http://documentcloud.github.com/backbone/#View-delegateEvents" target="_top">Backbone.View.prototype.delegateEvents()</a>
function.  It binds DOM events with <code class="literal">$.delegate()</code>, whether you’re using the
<a class="ulink" href="http://api.jquery.com/delegate/" target="_top">jQuery</a> or
<a class="ulink" href="https://github.com/madrobby/zepto/blob/v0.7/src/event.js#L96-108" target="_top">Zepto</a>
<code class="literal">.delegate()</code> function.</p><p>It also takes care of binding the event handlers' <code class="literal">this</code> to the view instance using <code class="literal">_.bind()</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_binding_to_events_triggered_by_literal_this_model_literal_or_literal_this_collection_literal"></a>Binding to events triggered by <code class="literal">this.model</code> or <code class="literal">this.collection</code></h4></div></div></div><p>In almost every view you write, the view will be bound to a <code class="literal">Backbone.Model</code> or
<code class="literal">Backbone.Collection</code>, most often with the convenience properties <code class="literal">this.model</code>
or <code class="literal">this.collection</code>.</p><p>TODO: Make sure we discussed the convenience properties previously?</p><p>Consider a view that displays a collection of <code class="literal">Task</code> models.  It will re-render
itself when any model in the collection is changed or removed, or when a new
model is added:</p><pre class="programlisting">var TasksIndex = Backbone.View.extend({
  template: JST['tasks/tasks_index'],
  tagName: 'section',
  id: 'tasks',

  initialize: function() {
    _.bindAll(this, "render");
    this.collection.bind("change", this.render);
    this.collection.bind("add",    this.render);
    this.collection.bind("remove", this.render);
  },

  render: function() {
    $(this.el).html(this.template({tasks: this.collection}));
  }
});</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_binding_to_custom_events"></a>Binding to custom events</h4></div></div></div><p>With sufficiently complex views, you may encounter a situation where you want
one view to change in response to another.</p><p>TODO: Expound on this situation, discuss that it’s unlikely, and you should
consider whether you should be binding to models instead.  However, sometimes
it’s useful.</p><p>Consider a simple example with a table of users and a toggle control that
filters the users to a particular gender:</p><pre class="programlisting">GenderFilter = Backbone.View.extend({
  events: {
    "click .show-male":   "showMale",
    "click .show-female": "showFemale",
    "click .show-both":   "showBoth"
  },

  showMale: function()   { this.trigger("changed", "male");   },
  showFemale: function() { this.trigger("changed", "female"); },
  showBoth: function()   { this.trigger("changed", "both");   }
});

UsersTable = Backbone.View.extend({
  initialize: function() {
    this.filterView = new UserFilter();
    this.filterView.bind("changed", this.filterByGender);
  },

  filterByGender: function(gender) {
    this.filteredCollection = this.collection.byGender(gender);
  }
});</pre><p><code class="literal">GenderFilter</code> is responsible for the filter control, and triggers an event
with <code class="literal">Backbone.Events.prototype.trigger()</code> when it changes.  <code class="literal">UsersTable</code>
observes this event, and filters its own collection in response.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_cleaning_up_unbinding"></a>Cleaning Up: Unbinding</h3></div></div></div><p>In the last section, we discussed three different kinds of event binding in
your <code class="literal">Backbone.Views</code> classes: DOM events, model/collection events, and custom
view events.  Next we’ll discuss unbinding these events: why it’s a good idea,
and how to do it.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_why_do_i_have_to_unbind_events"></a>Why do I have to unbind events?</h4></div></div></div><p>Consider two views in a Todo app: an index view which contains all the tasks
that need to be done:</p><div class="figure"><a id="id449791"></a><p class="title"><b>Figure 2. Tasks index view</b></p><div class="figure-contents"><div class="mediaobject"><img src="views_and_templates/tasks-index.png" alt="views_and_templates/tasks-index.png" /></div></div></div><br class="figure-break" /><p>and a detail view that shows detail on one task:</p><div class="figure"><a id="id449818"></a><p class="title"><b>Figure 3. Tasks detail view</b></p><div class="figure-contents"><div class="mediaobject"><img src="views_and_templates/tasks-detail.png" alt="views_and_templates/tasks-detail.png" /></div></div></div><br class="figure-break" /><p>The interface switches between the two views.</p><p>Here’s the source for the aggregate index view:</p><pre class="programlisting">var TasksIndex = Backbone.View.extend({
  template: JST['tasks/tasks_index'],
  tagName: 'section',
  id: 'tasks',

  initialize: function() {
    _.bindAll(this, "render");
    this.collection.bind("change", this.render);
    this.collection.bind("add",    this.render);
    this.collection.bind("remove", this.render);
  },

  render: function() {
    $(this.el).html(this.template({tasks: this.collection}));
  }
});</pre><p>and the source for the individual task detail view:</p><pre class="programlisting">var TaskDetail = Backbone.View.extend({
  template: JST['tasks/tasks_detail'],
  tagName: 'section',
  id: 'task',

  events: {
    "click .comments .form-inputs button": "createComment"
  },

  initialize: function() {
    _.bindAll(this, "render");

    this.model.bind("change", this.render);
    this.model.comments.bind("change", this.render);
    this.model.comments.bind("add", this.render);
  },

  render: function() {
    $(this.el).html(this.template({task: this.model}));
  },

  createComment: function() {
    var comment = new Comment({ text: this.$('.new-comment-input').val() });
    this.$('.new-comment-input').val('');
    this.model.comments.create(comment);
  }
});</pre><p>Each task on the index page links to the detail view for itself. When a user
follows one of these links and navigates from the index page to the detail
page, then interacts with the detail view to change a model, the <code class="literal">change</code> event
on the <code class="literal">TaskApp.tasks</code> collection is fired. One consequence of this is that
the index view, which is still bound and observing the <code class="literal">change</code> event, will
re-render itself.</p><p>This is both a functional bug and a memory leak: not only will the index view
re-render and disrupt the detail display momentarily, but navigating back and
forth between the views without disposing of the previous view will keep
creating more views and binding more events on the associated models or
collections.</p><p>These can be extremely tricky to track down on a production application,
especially if you are nesting child views. Sadly, there’s no "garbage
collection" for views in Backbone, so your application needs to manage this
itself.</p><p>Let’s take a look at how to unbind various kinds of events.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_unbinding_dom_events"></a>Unbinding DOM events</h4></div></div></div><p>When you call <code class="literal">this.remove()</code> in your view, it delegates to <code class="literal">jQuery.remove()</code>
by invoking <code class="literal">$(this.el).remove()</code>.  This means that jQuery takes care of
cleaning up any events bound on DOM elements within your view, regardless of
whether you bound them with the Backbone <code class="literal">events</code> hash or by hand; for
example, with <code class="literal">$.bind()</code>, <code class="literal">$.delegate()</code>, or <code class="literal">$.live()</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_unbinding_model_and_collection_events"></a>Unbinding model and collection events</h4></div></div></div><p>If your view binds to events on a model or collection, you are responsible for
unbinding these events.  You do this with a simple call to
<code class="literal">this.model.unbind()</code> or <code class="literal">this.collection.unbind()</code>; the
<a class="ulink" href="http://documentcloud.github.com/backbone/#Events-unbind" target="_top"><code class="literal">Backbone.Events.unbind()</code>
function</a> removes all callbacks on that object.</p><p>When should we unbind these handlers?  Whenever the view is going away.  This
means that any pieces of code that create new instances of this view become
responsible for cleaning up after it.  That doesn’t sound like a very cohesive
approach, so let’s include the cleanup responsibility on this view.</p><p>TODO: Consider just overriding <code class="literal">Backbone.View.prototype.remove()</code> instead of
making a new function, since <code class="literal">remove()</code> is very simple.  What are the pros/cons?</p><p>Let’s write a <code class="literal">leave()</code> function on our view that wraps <code class="literal">remove()</code> and handles
any additional event unbinding we need to do.  As a convention, when we use
this view elsewhere, we’ll call <code class="literal">leave()</code> instead of <code class="literal">remove()</code> when we’re
done:</p><pre class="programlisting">var SomeCollectionView = Backbone.View.extend({
  // snip...

  initialize: function() {
    this.collection.bind("change", this.render);
  },

  leave: function() {
    this.collection.unbind("change", this.render);
    this.remove();
  }

  // snip...
});</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_keep_track_of_literal_bind_literal_calls_to_unbind_more_easily"></a>Keep track of <code class="literal">bind()</code> calls to unbind more easily</h4></div></div></div><p>In the example above, unbinding the collection change event isn’t too much
hassle; since we’re only observing one thing, we only have to unbind one
thing.  But even the addition of one line to <code class="literal">leave()</code> is easy to forget, and
if you bind to multiple events then it only gets more verbose.</p><p>Let’s add a step of indirection in event binding so that we can automatically
clean up all the events with one call.  We’ll add and use a <code class="literal">bindTo()</code>
function that keeps track of all the event handlers we bind, and then issue a
single call to <code class="literal">unbindFromAll()</code> to unbind them:</p><pre class="programlisting">var SomeCollectionView = Backbone.View.extend({
  initialize: function() {
    this.bindTo(this.collection, "change", this.render);
  },

  leave: function() {
    this.unbindFromAll();
    this.remove();
  },

  bindTo: function(source, event, callback) {
    source.bind(event, callback, this);
    this.bindings.push({ source: source, event: event, callback: callback });
  },

  unbindFromAll: function() {
    _.each(this.bindings, function(binding) {
      binding.source.unbind(binding.event, binding.callback);
    });
    this.bindings = [];
  }
});</pre><p>These functions, <code class="literal">bindTo()</code> and <code class="literal">unbindFromAll()</code>, can be extracted into a
reusable mixin or superclass.  Then, we just have to use <code class="literal">bindTo()</code> instead of
<code class="literal">model.bind()</code> and be assured that the handlers will be cleaned up during
<code class="literal">leave()</code>.</p><p>TODO: Is it viable to use Function.caller inside Backbone.Events so this
functionality is provided by Backbone.Events?
<a class="ulink" href="https://gist.github.com/158a4172aea28876d0fc" target="_top">https://gist.github.com/158a4172aea28876d0fc</a></p><p>TODO: Wrap <code class="literal">bindTo()</code> and <code class="literal">unbindFromAll()</code> into <code class="literal">Observer</code> which gets mixed
into <code class="literal">CompositeView</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_unbinding_custom_events"></a>Unbinding custom events</h4></div></div></div><p>With the first two kinds of event binding that we discussed, DOM and
model/collection, the view is the observer.  The responsibility to clean up is
on the observer, and here the responsibility consists of unbinding the event
handler when the view is being removed.</p><p>But other times, our view classes will trigger (emit) events of their own.
In this case, other objects are the observer, and are responsible for cleaning
up the event binding when they are disposed.</p><p>However, additionally, when the view itself is disposed of with <code class="literal">leave()</code>, it
should clean up any event handlers bound on <span class="strong"><strong>itself</strong></span> for events that it
triggers.</p><p>This is handled by invoking <code class="literal">Backbone.Events.unbind()</code>:</p><pre class="programlisting">var FilteringView = Backbone.View.extend({
  // snip...

  events: {
    "click a.filter": "changeFilter"
  },

  changeFilter: function() {
    if (someLogic()) {
      this.trigger("filtered", { some: options });
    }
  },

  leave: function() {
    this.unbind(); // Clean up any event handlers bound on this view
    this.remove();
  }

  // snip...
});</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_establish_a_convention_for_consistent_and_correct_unbinding"></a>Establish a convention for consistent and correct unbinding</h4></div></div></div><p>There’s no built-in garbage collection for Backbone’s event bindings, and
forgetting to unbind can cause bugs and memory leaks. The solution is to make
sure you unbind events and remove views when you leave them. Our approach to
this is two-fold: write a set of reusable functions that manage cleaning up a
view’s bindings, and use these functions where ever views are instantiated: in
<code class="literal">Router</code> instances, and in composite views.  We’ll take a look at these
concrete, reusable approaches in the next two sections about <code class="literal">SwappingRouter</code>
and <code class="literal">CompositeView</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_swapping_router"></a>Swapping router</h3></div></div></div><p>When switching from one view to another, we should clean up the previous view.
We discussed previously a convention of writing a <code class="literal">view.leave()</code>
Let’s augment our view to include the ability to clean itself up by "leaving"
the DOM:</p><pre class="programlisting">var MyView = Backbone.View.extend({
  // ...

  leave: function() {
    this.unbind();
    this.remove();
  },

  // ...
});</pre><p>The <code class="literal">unbind()</code> and <code class="literal">remove()</code> functions are provided by <code class="literal">Backbone.Events</code> and
<code class="literal">Backbone.Events.unbind()</code> will remove all callbacks registered on the view,
and <code class="literal">remove()</code> will remove the view’s element from the DOM.</p><p>In simple cases, we replace one full page view with another full page (less any
shared layout). We introduce a convention that all actions underneath one
<code class="literal">Router</code> share the same root element, and define it as <code class="literal">el</code> on the router.</p><p>Now, a <code class="literal">SwappingRouter</code> can take advantage of the <code class="literal">leave()</code> function, and clean
up any existing views before swapping to a new one.  It swaps into a new view by
rendering that view into its own <code class="literal">el</code>:</p><pre class="programlisting">SwappingRouter = function(options) {
  Backbone.Router.apply(this, [options]);
};

_.extend(SwappingRouter.prototype, Backbone.Router.prototype, {
  swap: function(newView) {
    if (this.currentView &amp;&amp; this.currentView.leave) {
      this.currentView.leave();
    }

    this.currentView = newView;
    this.currentView.render();
    $(this.el).empty().append(this.currentView.el);
  }
});

SwappingRouter.extend = Backbone.Router.extend;</pre><p>Now all you need to do in a route function is call <code class="literal">swap()</code>, passing in the
new view that should be rendered. The <code class="literal">swap()</code> function’s job is to call
<code class="literal">leave()</code> on the current view, render the new view and append it to the
router’s <code class="literal">el</code>, and finally store who the current view is, so that next time
<code class="literal">swap()</code> is invoked, it can be properly cleaned up as well.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="swapping-internals"></a>SwappingRouter and Backbone internals</h4></div></div></div><p>If the code for <code class="literal">SwappingRouter</code> seems a little confusing, don’t fret: it is,
thanks to JavaScript’s object model! Sadly, it’s not as simple to just drop in
the <code class="literal">swap</code> method into <code class="literal">Backbone.Router</code>, or call <code class="literal">Backbone.Router.extend</code> to
mixin the function we need.</p><p>Our goal here is essentially to create a subclass of <code class="literal">Backbone.Router</code>, and to
extend it without modifying the original class. This gives us a few benefits:
first, <code class="literal">SwappingRouter</code> should work with Backbone upgrades. Second, it should be
<span class="strong"><strong>obvious</strong></span>  and <span class="strong"><strong>intention-revealing</strong></span> when a controller needs to swap views. If
we chose to just mix in a <code class="literal">swap</code> method, and called it from a direct descendant
of <code class="literal">Backbone.Router</code>, an unaware (and unlucky) programmer now needs to go on a
deep source dive in an attempt to figure out where that’s coming from. At least
with a subclass, the hunt should start at the file where it was defined.</p><p>The procedure used to create <code class="literal">SwappingRouter</code> is onerous thanks to a mix of
Backbone-isms and just how clunky inheritance is in JavaScript. First off, we
need to define the constructor, which delegates to the <code class="literal">Backbone.Router</code>
constructor with the use of <code class="literal">Function#apply</code>. The next block of code uses
Underscore’s <code class="literal">Object#extend</code> to create the set of functions and properties that
will become <code class="literal">SwappingRouter</code>. The <code class="literal">extend</code> function takes a destination, in
this case the empty prototype for <code class="literal">SwappingRouter</code>, and copies in the
properties in the <code class="literal">Backbone.Router</code> prototype along with our new custom object
that includes the <code class="literal">swap</code> function.</p><p>Finally, the subclass cake is topped off with some Backbone frosting: setting
<code class="literal">extend</code>, which is a self-propagating function that all Backbone public classes
use. Let’s take a quick look at this function, as of Backbone 0.5.3:</p><pre class="programlisting">var extend = function (protoProps, classProps) {
  var child = inherits(this, protoProps, classProps);
  child.extend = this.extend;
  return child;
};

// Helper function to correctly set up the prototype chain, for subclasses.
// Similar to `goog.inherits`, but uses a hash of prototype properties and
// class properties to be extended.
var inherits = function(parent, protoProps, staticProps) {
  // sparing our readers the internals of this function... for a deep dive
  // into the dark realms of JavaScript's prototype system, read the source!
}</pre><p>So, it’s a function that calls <code class="literal">inherits</code> to make a new subclass.  The comments
reference <code class="literal">goog.inherits</code> from Google’s Closure Library, which contains similar
utility functions to allow more class-style inheritance.</p><p>The end result here is that whenever you make a custom controller, internally
in Backbone, you’re making <span class="strong"><strong>another</strong></span> subclass. The inheritance chain for
<code class="literal">TasksRouter</code> would then look like:</p><div class="figure"><a id="id450675"></a><p class="title"><b>Figure 4. Router class inheritance</b></p><div class="figure-contents"><div class="mediaobject"><img src="views_and_templates/router-diagram.png" alt="views_and_templates/router-diagram.png" /></div></div></div><br class="figure-break" /><p>Phew! Hopefully this adventure into Backbone and JavaScript internals has
taught you that although it’s more code, it’s hopefully going to save time down
the road for those maintaining your code.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_composite_views"></a>Composite views</h3></div></div></div><p>The <code class="literal">SwappingRouter</code> above calls <code class="literal">leave()</code> on the view it currently holds.
This function is not part of Backbone itself, and is part of our extension
library to help make views more modular and maintainable. This section goes
over the Composite View pattern, the <code class="literal">CompositeView</code> class itself, and some
concerns to keep in mind while creating your views.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_refactoring_from_a_large_view"></a>Refactoring from a large view</h4></div></div></div><p>One of the first refactorings you find yourself doing in a non-trivial Backbone
app is splitting up large views into composable parts. Let’s take another look
at the <code class="literal">TaskDetail</code> source code from the beginning of this section:</p><pre class="programlisting">var TaskDetail = Backbone.View.extend({
  template: JST['tasks/tasks_detail'],
  tagName: 'section',
  id: 'task',

  events: {
    "click .comments .form-inputs button": "createComment"
  },

  initialize: function() {
    _.bindAll(this, "render");

    this.model.bind("change", this.render);
    this.model.comments.bind("change", this.render);
    this.model.comments.bind("add", this.render);
  },

  render: function() {
    $(this.el).html(this.template({task: this.model}));
  },

  createComment: function() {
    var comment = new Comment({ text: this.$('.new-comment-input').val() });
    this.$('.new-comment-input').val('');
    this.model.comments.create(comment);
  }
});</pre><p>The view class references a template, which renders out the HTML for this page:</p><pre class="programlisting">&lt;section class="task-details"&gt;
  &lt;input type="checkbox"&lt;%= task.isComplete() ? ' checked="checked"' : '' %&gt; /&gt;
  &lt;h2&gt;&lt;%= task.escape("title") %&gt;&lt;/h2&gt;
&lt;/section&gt;

&lt;section class="comments"&gt;
  &lt;ul&gt;
    &lt;% task.comments.each(function(comment) { %&gt;
      &lt;li&gt;
        &lt;h4&gt;&lt;%= comment.user.escape('name') %&gt;&lt;/h4&gt;
        &lt;p&gt;&lt;%= comment.escape('text') %&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;% } %&gt;
  &lt;/ul&gt;

  &lt;div class="form-inputs"&gt;
    &lt;label for="new-comment-input"&gt;Add comment&lt;/label&gt;
    &lt;textarea id="new-comment-input" cols="30" rows="10"&gt;&lt;/textarea&gt;
    &lt;button&gt;Add Comment&lt;/button&gt;
  &lt;/div&gt;
&lt;/section&gt;</pre><p>There are clearly several concerns going on here: rendering the task, rendering
the comments that folks have left, and rendering the form to create new
comments. Let’s separate those concerns. A first approach might be to just
break up the template files:</p><pre class="programlisting">&lt;!-- tasks/show.jst --&gt;
&lt;section class="task-details"&gt;
  &lt;%= JST['tasks/details']({ task: task }) %&gt;
&lt;/section&gt;

&lt;section class="comments"&gt;
  &lt;%= JST['comments/list']({ task: task }) %&gt;
&lt;/section&gt;</pre><pre class="programlisting">&lt;!-- tasks/details.jst --&gt;
&lt;input type="checkbox"&lt;%= task.isComplete() ? ' checked="checked"' : '' %&gt; /&gt;
&lt;h2&gt;&lt;%= task.escape("title") %&gt;&lt;/h2&gt;</pre><pre class="programlisting">&lt;!-- comments/list.jst --&gt;
&lt;ul&gt;
  &lt;% task.comments.each(function(comment) { %&gt;
    &lt;%= JST['comments/item']({ comment: comment }) %&gt;
  &lt;% } %&gt;
&lt;/ul&gt;

&lt;%= JST['comments/new']() %&gt;</pre><pre class="programlisting">&lt;!-- comments/item.jst --&gt;
&lt;h4&gt;&lt;%= comment.user.escape('name') %&gt;&lt;/h4&gt;
&lt;p&gt;&lt;%= comment.escape('text') %&gt;&lt;/p&gt;</pre><pre class="programlisting">&lt;!-- comments/new.jst --&gt;
&lt;div class="form-inputs"&gt;
  &lt;label for="new-comment-input"&gt;Add comment&lt;/label&gt;
  &lt;textarea id="new-comment-input" cols="30" rows="10"&gt;&lt;/textarea&gt;
  &lt;button&gt;Add Comment&lt;/button&gt;
&lt;/div&gt;</pre><p>But this is really only half the story. The <code class="literal">TaskDetail</code> view class still
handles multiple concerns: displaying the task, and creating comments. Let’s
split that view class up, using the <code class="literal">CompositeView</code> base class:</p><pre class="programlisting">CompositeView = function(options) {
  this.children = [];
  Backbone.View.apply(this, [options]);
};

_.extend(CompositeView.prototype, Backbone.View.prototype, {
  leave: function() {
    this._leaveChildren();
    this.unbind();
    this.remove();
    this._removeFromParent();
  },

  removeChild: function(view) {
    var index = this.children.indexOf(view);
    this.children.splice(index, 1);
  },

  renderChild: function(view) {
    view.render();
    this.children.push(view);
    view.parent = this;
  },

  appendChild: function(view) {
    this.renderChild(view);
    $(this.el).append(view.el);
  },

  renderChildInto: function(view, container) {
    this.renderChild(view);
    $(container).html('').append(view.el);
  },

  _leaveChildren: function() {
    var clonedChildren = this.children.slice(0);
    _.each(clonedChildren, function(view) {
      if (view.leave) {
        view.leave();
      }
    });
  },

  _removeFromParent: function() {
    if (this.parent) {
      this.parent.removeChild(this);
    }
  }
});

CompositeView.extend = Backbone.View.extend;</pre><p>TODO: Re-link to swapping-internals anchor once <a class="ulink" href="https://github.com/schacon/git-scribe/issues/33" target="_top">https://github.com/schacon/git-scribe/issues/33</a> is fixed</p><p>Similar to the <code class="literal">SwappingRouter</code>, the <code class="literal">CompositeView</code> base class solves common
housekeeping problems by establishing a convention. See the Swapping Router and
Backbone internals section for an in-depth analysis of how this subclassing
pattern works.</p><p>Now our <code class="literal">CompositeView</code> maintains an array of its immediate children as
<code class="literal">this.children</code>.  With this reference in place, a parent view’s <code class="literal">leave()</code> method
can invoke <code class="literal">leave()</code> on its children, ensuring that an entire tree of composed
views is cleaned up properly.</p><p>For child views that can dismiss themselves, such as dialog boxes, children
maintain a back-reference at <code class="literal">this.parent</code>. This is used to reach up and call
<code class="literal">this.parent.removeChild(this)</code> for these self-dismissing views.</p><p>Making use of <code class="literal">CompositeView</code>, we split up the <code class="literal">TaskDetail</code> view class:</p><pre class="programlisting">var TaskDetail = Backbone.View.extend({
  tagName: 'section',
  id: 'task',

  initialize: function() {
    _.bindAll(this, "renderDetails");
    this.model.bind("change", this.renderDetails);
  },

  render: function() {
    this.renderLayout();
    this.renderDetail();
    this.renderCommentsList();
  },

  renderLayout: function() {
    $(this.el).html(JST['tasks/show']());
  },

  renderDetails: function() {
    var detailsMarkup = JST['tasks/details']({ task: this.model });
    this.$('.task-details').html(detailsMarkup);
  },

  renderCommentsList: function() {
    var commentsList = new CommentsList({ model: this.model });
    var commentsContainer = this.$('comments');
    this.renderChildInto(commentsList, commentsContainer);
  }
});</pre><pre class="programlisting">var CommentsList = CompositeView.extend({
  tagName: 'ul',

  initialize: function() {
    this.model.comments.bind("add", this.renderComments);
  },

  render: function() {
    this.renderLayout();
    this.renderComments();
    this.renderCommentForm();
  },

  renderLayout: function() {
    $(this.el).html(JST['comments/list']());
  },

  renderComments: function() {
    var commentsContainer = this.$('comments-list');
    commentsContainer.html('');

    this.model.comments.each(function(comment) {
      var commentMarkup = JST['comments/item']({ comment: comment });
      commentsContainer.append(commentMarkup);
    });
  },

  renderCommentForm: function() {
    var commentForm = new CommentForm({ model: this.model });
    var commentFormContainer = this.$('.new-comment-form');
    this.renderChildInto(commentForm, commentFormContainer);
  }
});</pre><pre class="programlisting">var CommentForm = CompositeView.extend({
  events: {
    "click button": "createComment"
  },

  initialize: function() {
    this.model = this.options.model;
  },

  render: function() {
    $(this.el).html(JST['comments/new']);
  },

  createComment: function() {
    var comment = new Comment({ text: $('.new-comment-input').val() });
    this.$('.new-comment-input').val('');
    this.model.comments.create(comment);
  }
});</pre><p>Along with this, remove the <code class="literal">&lt;%= JST(…) %&gt;</code> template nestings, allowing the
view classes to assemble the templates instead. In this case, each template
contains placeholder elements that are used to wrap child views:</p><pre class="programlisting">&lt;!-- tasks/show.jst --&gt;
&lt;section class="task-details"&gt;
&lt;/section&gt;

&lt;section class="comments"&gt;
&lt;/section&gt;</pre><pre class="programlisting">&lt;!-- tasks/details.jst --&gt;
&lt;input type="checkbox"&lt;%= task.isComplete() ? ' checked="checked"' : '' %&gt; /&gt;
&lt;h2&gt;&lt;%= task.escape("title") %&gt;&lt;/h2&gt;</pre><pre class="programlisting">&lt;!-- comments/list.jst --&gt;
&lt;ul class="comments-list"&gt;
&lt;/ul&gt;

&lt;section class="new-comment-form"&gt;
&lt;/section&gt;</pre><pre class="programlisting">&lt;!-- comments/item.jst --&gt;
&lt;h4&gt;&lt;%= comment.user.escape('name') %&gt;&lt;/h4&gt;
&lt;p&gt;&lt;%= comment.escape('text') %&gt;&lt;/p&gt;</pre><pre class="programlisting">&lt;!-- comments/new.jst --&gt;
&lt;label for="new-comment-input"&gt;Add comment&lt;/label&gt;
&lt;textarea class="new-comment-input" cols="30" rows="10"&gt;&lt;/textarea&gt;
&lt;button&gt;Add Comment&lt;/button&gt;</pre><p>There are several advantages to this approach:</p><div class="itemizedlist"><ul type="disc"><li>
Each view class has a smaller and more cohesive set of responsibilities.
</li><li>
The comments view code, extracted and decoupled from the task view code, can
  now be reused on other domain objects with comments.
</li><li>
The task view performs better, since adding new comments or updating the task
  details will only re-render the pertinent section, instead of re-rendering the
  entire task + comments composite.
</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_cleaning_up_views_properly"></a>Cleaning up views properly</h4></div></div></div><p>We now have a full set of tools to clean up views properly.</p><p>TODO: Wrap up and re-state the "cleaning up, swappingrouter, compositeview" sections.  Mix <code class="literal">Observer</code> into <code class="literal">CompositeView</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_how_to_use_multiple_views_on_the_same_model_collection_chapter_unstarted"></a>How to use multiple views on the same model/collection (chapter unstarted)</h3></div></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_internationalization_chapter_unstarted"></a>Internationalization (chapter unstarted)</h3></div></div></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s05.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s07.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Rails Integration </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Models and collections</td></tr></table></div></body></html>
