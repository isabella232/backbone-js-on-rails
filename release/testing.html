<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="master.css" type="text/css" />
    <title>Testing</title>
  </head>

  <body>
    <div class="nav" id="navheader">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="models_and_collections.html">Prev</a><br/>
         Models and collections
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         <strong>Backbone.js on Rails</strong>
        
      </td><td width="33%" align="right">
        
          <a href="security_stub_.html">Next</a><br/>
          Security (stub)
        
      </td></tr>
    </table>
    </div>

    <hr/>

    <div class="content">
      <div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a id="_testing"></a>Testing</h2></div></div></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_full_stack_integration_testing_1_todo"></a>Full-stack integration testing (1 todo)</h3></div></div></div>
<p>Your application is built from a collection of loosely coupled modules,
spreading across several layers of the development stack.  To ensure the
application works correctly from the perspective of the end-user, full-stack
integration testing drives your application and verifies correct functionality
from the user interface level.  This is also referred to as acceptance testing.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_introduction_2"></a>Introduction</h4></div></div></div>
<p>TODO: No real special Backbone concerns, just integration test with a @js driver
like normal.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_capybara"></a>Capybara</h4></div></div></div>
<p>Thought there is a host of tools available to you for writing automated
integration tests, we recommend
[capybara](<a class="ulink" href="https://github.com/jnicklas/capybara" target="_top">https://github.com/jnicklas/capybara</a>).  In a hybrid Rails
application, where some portions are regular request/response and other portions
are JavaScript, it’s valuable to have a testing framework that abstracts the
difference as much as possible.</p>
<p>Capybara is a high-level library that allows you to write tests from a user’s
perspective.  Consider this example, which uses RSpec:</p>
<pre class="programlisting">describe <b class="hl-string"><i style="color:red">"the login process"</i></b>, :type =&gt; :request <b class="hl-keyword">do</b>
  it <b class="hl-string"><i style="color:red">"accepts an email and password"</i></b> <b class="hl-keyword">do</b>
    User.create(:email =&gt; <b class="hl-string"><i style="color:red">'alice@example.com'</i></b>, :password =&gt; <b class="hl-string"><i style="color:red">'password'</i></b>)
    visit <b class="hl-string"><i style="color:red">'/'</i></b>
    fill_in <b class="hl-string"><i style="color:red">'Email'</i></b>, :with =&gt; <b class="hl-string"><i style="color:red">'alice@example.com'</i></b>
    fill_in <b class="hl-string"><i style="color:red">'Password'</i></b>, :with =&gt; <b class="hl-string"><i style="color:red">'password'</i></b>
    click_button <b class="hl-string"><i style="color:red">'Log in'</i></b>
    page.should have_content(<b class="hl-string"><i style="color:red">'You are logged in as alice@example.com'</i></b>)
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre>
<p>Notice that, as you read the spec, you’re not concerned about whether the login
interface is rendered with JavaScript, or whether the authentication request is
over AJAX or not.  A high-level library like Capybara keeps you from having to
consider the back-end implementation, freeing you to focus on describing the
application’s behavior from an end-user’s perspective.  This perspective of
writing specs is often called behavior-driven development (BDD).</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_cucumber"></a>Cucumber</h4></div></div></div>
<p>You can take another step toward natural language tests, using Cucumber to
define mappings.  Cucumber is a test runner and a mapping layer.  The specs you
write in Cucumber are user stories, written in a constrained subset of English.
The individual steps in these stories are mapped to a testing library.  In our
case, and probably most cases, to Capybara.</p>
<p>This additional layer of abstraction can be helpful for a few reasons.</p>
<p>Some teams have nontechnical stakeholders writing integration specs as user
stories.  Cucumber sits at a level of abstraction that fits comfortably there:
high level enough for nontechnical stakeholders to write in, but precise enough
to be translated into automated tests.</p>
<p>On other teams, the person writing the story is the same person who implements
it.  Still, it is valuable to use a tool that reinforces the distinction between
the description phase and the implementation phase of the test.  In the
description phase, you are writing an English description of the software
interaction:</p>
<pre class="programlisting">Given there is a user account "alice@example.com" with the password "password"
When I go to the home page
And I fill in the login form with "alice@example.com" and "password"
And I click the login button
Then I should see "You are logged in as alice@example.com"</pre>
<p>In the implementation phase of the test, you define what these steps do.  In
this case, they are defined to run Capybara methods:</p>
<pre class="programlisting">Given /^there is a user account <b class="hl-string"><i style="color:red">"(.*)"</i></b> with the password <b class="hl-string"><i style="color:red">"(.*)"</i></b>$/ <b class="hl-keyword">do</b> |email, password|
  User.create(:email =&gt; email, :password =&gt; password)
<b class="hl-keyword">end</b>

When <b class="hl-string"><i style="color:red">"I go to the home page"</i></b> <b class="hl-keyword">do</b>
  visit <b class="hl-string"><i style="color:red">"/"</i></b>
<b class="hl-keyword">end</b>

When /^I fill <b class="hl-keyword">in</b> the login form with <b class="hl-string"><i style="color:red">"(.*)"</i></b> <b class="hl-keyword">and</b> <b class="hl-string"><i style="color:red">"(.*)"</i></b>$/ <b class="hl-keyword">do</b> |email, password|
  fill_in <b class="hl-string"><i style="color:red">'Email'</i></b>, :with =&gt; email
  fill_in <b class="hl-string"><i style="color:red">'Password'</i></b>, :with =&gt; password
<b class="hl-keyword">end</b>

When <b class="hl-string"><i style="color:red">"I click the login button"</i></b> <b class="hl-keyword">do</b>
  click_button <b class="hl-string"><i style="color:red">"Login"</i></b>
<b class="hl-keyword">end</b>

Then /^I should see <b class="hl-string"><i style="color:red">"(.*)"</i></b>$/ <b class="hl-keyword">do</b> |text|
  page.should have_content(text)
<b class="hl-keyword">end</b></pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_drivers"></a>Drivers</h4></div></div></div>
<div class="itemizedlist"><ul type="disc">
<li>
Integration test with:
</li>
<li>
[capybara-webkit](<a class="ulink" href="https://github.com/thoughtbot/capybara-webkit" target="_top">https://github.com/thoughtbot/capybara-webkit</a>) for fast, headless, accurate WebKit testing
</li>
<li>
Selenium for other browsers, or if capybara-webkit has issues.
</li>
</ul></div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_isolated_unit_testing_some_stubs_some_wip"></a>Isolated unit testing (some stubs, some wip)</h3></div></div></div>
<p>Integration testing your application is great for ensuring that the product
functions as intended, and works to mitigate against risk of regressions.
There are additional benefits, though, to writing tests for individual units
of your application in isolation.  Two of them are focused failures and
decoupled code.</p>
<p>When an integration test fails, it can be difficult to pin down the exact reason
why; particularly when a regression is introduced in a part of the application
seemingly far away from where you’re working.  With the finer granularity of a
unit test suite, failures are more targeted and help you get to the root of the
problem more quickly.</p>
<p>Another benefit comes from unit testing when you test-drive code; when you write
the tests before the implementation.  Since you are starting with a piece of
code which is client to your implementation modules, setup and dependency
concerns are brought to your attention at the beginning of implementation,
rather than much later during development when modules are integrated. Thinking
about these concerns earlier helps you design modules which are more loosely
coupled, have smaller interfaces, and are easier to set up.  If code is hard to
test, it will be hard to use.  Writing the test first, you have a clear and
concrete opportunity to make your implementation easier to use.</p>
<p>If you’d like to read more on test-driven development, check out Kent Beck’s
<span class="emphasis"><em>Test Driven Development: By Example</em></span> and Gerard Meszaros' <span class="emphasis"><em>xUnit Test Patterns:
Refactoring Test Code</em></span>.</p>
<p>As there is plentiful content available for testing tools and strategies in
Rails, we’ll focus on isolation testing your Backbone code.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_isolation_testing_in_javascript"></a>Isolation testing in JavaScript</h4></div></div></div>
<p>There are many JavaScript testing frameworks available.  Some run in-browser and
provide facility for setting up DOM fixtures.  Others are designed for
standalone JavaScript code and can run on browserless JavaScript runtimes.</p>
<p>We’ll use the Jasmine framework for writing our isolation specs.  It integrates
easily into a Rails application, and provides an RSpec-like syntax for writing
specs:</p>
<pre class="programlisting">describe(<b class="hl-string"><i style="color:red">"App.Models.User"</i></b>, <b class="hl-keyword">function</b>() {
  it(<b class="hl-string"><i style="color:red">"knows its full name, given a first and last name"</i></b>, <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> user = <b class="hl-keyword">new</b> App.Models.User({
      first_name: <b class="hl-string"><i style="color:red">'Alice'</i></b>,
      last_name:  <b class="hl-string"><i style="color:red">'Appleton'</i></b>
    });

    expect(user.fullName()).toEqual(<b class="hl-string"><i style="color:red">'Alice Appleton'</i></b>);
  });
});</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_what_to_test"></a>What to test?</h4></div></div></div>
<p>TODO: Discuss cost/benefit tradeoffs of isolation testing.  Discuss code
coverage, and relative value w.r.t. overlap with integration testing.  In our
experience so far, most value is in testing Backbone views and models; guided by
a general principle of valuing test coverage over complex or high-churn code
areas (which models and views generally qualify for) — routers <span class="strong"><strong>should</strong></span> be very
low on logic and just delegate to models and views (think Rails skinny
controllers).  Since isolation tests for them generally involves a fair amount
of stubbing/spying/mocking, they tend to be more brittle and less valuable.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_stubbing_mocking_spying"></a>Stubbing, mocking, spying</h4></div></div></div>
<p>TODO: Discuss sinon.js and syntax for stubs, spies, mocks.</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a id="_helpful_tools"></a>Helpful Tools</h4></div></div></div>
<p>TODO: Some of these (e.g. sinon, maybe rosie) will be introduced earlier.  Those
that remain should be explained in more detail.</p>
<div class="itemizedlist"><ul type="disc">
<li>
Spy/stub/mock, even your HTTP, with [sinon.js](<a class="ulink" href="http://sinonjs.org/" target="_top">http://sinonjs.org/</a>)
</li>
<li>
If you’re looking for factory_girl.js, it’s called [Rosie](<a class="ulink" href="https://github.com/bkeepers/rosie" target="_top">https://github.com/bkeepers/rosie</a>)
</li>
<li>
[guard-jasmine](<a class="ulink" href="https://github.com/netzpirat/guard-jasmine" target="_top">https://github.com/netzpirat/guard-jasmine</a>) autotest your Jasmine with headless webkit ([phantomjs](<a class="ulink" href="http://www.phantomjs.org/" target="_top">http://www.phantomjs.org/</a>))
</li>
<li>
Write in CoffeeScript and use the 3.1 asset pipeline with [jasminerice](<a class="ulink" href="https://github.com/bradphelan/jasminerice" target="_top">https://github.com/bradphelan/jasminerice</a>)
</li>
<li>
See other examples on James Newbery’s blog: [testing Backbone with Jasmine](<a class="ulink" href="http://tinnedfruit.com/2011/03/03/testing-backbone-apps-with-jasmine-sinon.html" target="_top">http://tinnedfruit.com/2011/03/03/testing-backbone-apps-with-jasmine-sinon.html</a>) and check out his [examples on GitHub](<a class="ulink" href="https://github.com/froots/backbone-jasmine-examples" target="_top">https://github.com/froots/backbone-jasmine-examples</a>)
</li>
</ul></div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_example_test_driving_a_task_application"></a>Example: Test-driving a Task application</h3></div></div></div>
<p>TODO: This writing is terse.  Come back and improve flow.</p>
<p>We’ll go outside in: cucumber first, then rspec or jasmine as needed.</p>
<p>TODO: Discuss setting up tools: jasminerice, cucumber, capybara-webkit/selenium</p>
<p>We have a basic application set up for testing, with the following Gemfile:</p>
<pre class="programlisting">source <b class="hl-string"><i style="color:red">'http://rubygems.org'</i></b>

gem <b class="hl-string"><i style="color:red">'rails'</i></b>, <b class="hl-string"><i style="color:red">'3.1.0'</i></b>
gem <b class="hl-string"><i style="color:red">'sqlite3'</i></b>

gem <b class="hl-string"><i style="color:red">'rails-backbone'</i></b>
gem <b class="hl-string"><i style="color:red">'jquery-rails'</i></b>
gem <b class="hl-string"><i style="color:red">'ejs'</i></b>
gem <b class="hl-string"><i style="color:red">"flutie"</i></b>, <b class="hl-string"><i style="color:red">"~&gt; 1.3.2"</i></b>
gem <b class="hl-string"><i style="color:red">"clearance"</i></b>, <b class="hl-string"><i style="color:red">"~&gt; 0.13.0"</i></b>
gem <b class="hl-string"><i style="color:red">'paperclip'</i></b>

group :assets <b class="hl-keyword">do</b>
  gem <b class="hl-string"><i style="color:red">'sass-rails'</i></b>, <b class="hl-string"><i style="color:red">"  ~&gt; 3.1.0"</i></b>
  gem <b class="hl-string"><i style="color:red">'coffee-rails'</i></b>, <b class="hl-string"><i style="color:red">"~&gt; 3.1.0"</i></b>
  gem <b class="hl-string"><i style="color:red">'uglifier'</i></b>
<b class="hl-keyword">end</b>

group :development, :test <b class="hl-keyword">do</b>
  gem <b class="hl-string"><i style="color:red">"rspec-rails"</i></b>, <b class="hl-string"><i style="color:red">"~&gt; 2.6.1"</i></b>
  gem <b class="hl-string"><i style="color:red">"ruby-debug19"</i></b>
  gem <b class="hl-string"><i style="color:red">'jasmine'</i></b>, <b class="hl-string"><i style="color:red">"= 1.1.0.rc4"</i></b>
  gem <b class="hl-string"><i style="color:red">'jasminerice'</i></b>
<b class="hl-keyword">end</b>

group :test <b class="hl-keyword">do</b>
  gem <b class="hl-string"><i style="color:red">'turn'</i></b>, :require =&gt; <b class="hl-keyword">false</b>
  gem <b class="hl-string"><i style="color:red">"capybara"</i></b>, <b class="hl-string"><i style="color:red">"~&gt; 1.0.1"</i></b>
  gem <b class="hl-string"><i style="color:red">"selenium-webdriver"</i></b>, <b class="hl-string"><i style="color:red">"~&gt; 2.5.0"</i></b>
  gem <b class="hl-string"><i style="color:red">'cucumber-rails'</i></b>, <b class="hl-string"><i style="color:red">"~&gt; 1.0.2"</i></b>
  gem <b class="hl-string"><i style="color:red">"factory_girl_rails"</i></b>
  gem <b class="hl-string"><i style="color:red">"bourne"</i></b>
  gem <b class="hl-string"><i style="color:red">"database_cleaner"</i></b>
  gem <b class="hl-string"><i style="color:red">"nokogiri"</i></b>
  gem <b class="hl-string"><i style="color:red">"shoulda"</i></b>
  gem <b class="hl-string"><i style="color:red">"launchy"</i></b>
  gem <b class="hl-string"><i style="color:red">"guard-spork"</i></b>
  gem <b class="hl-string"><i style="color:red">"spork"</i></b>, <b class="hl-string"><i style="color:red">"~&gt; 0.9.0.rc"</i></b>
<b class="hl-keyword">end</b></pre>
<p>We’d like to be able to add items to a Todo list.  We know this will involve two
parts: a list of existing tasks, and an interface for adding new items to
the list.  We’ll start with the list of items, and create fixture data with
[Factory Girl Cucumber
steps](<a class="ulink" href="https://github.com/thoughtbot/factory_girl/blob/v2.1.0/GETTING_STARTED.md" target="_top">https://github.com/thoughtbot/factory_girl/blob/v2.1.0/GETTING_STARTED.md</a>):</p>
<pre class="programlisting"></pre>
<p>Running this, we see a failure:</p>
<pre class="programlisting">Then I should see "Master backbone" within the tasks list # features/step_definitions/web_steps.rb:35
  Unable to find css "#tasks table" (Capybara::ElementNotFound)
  (eval):2:in `find'
  ./features/step_definitions/web_steps.rb:29:in `with_scope'
  ./features/step_definitions/web_steps.rb:36:in `/^(.*) within (.*[^:])$/'
  features/view_tasks.feature:13:in `Then I should see "Master backbone" within the tasks list'</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>A common gotchya when testing Backbone.js Rails apps is seeing false
positives in bootstrapped data. Consider that, if we had just written the step
<code class="literal">Then I should see "Master backbone"</code> instead of scoping it with <code class="literal">within the
tasks list</code>, then some test drivers would count the JSON that is used to
bootstrap Backbone collections as visible text on the page, and the test would
pass without us actually rendering the text to the page.</p>
</div>
<p>Since this we are doing outside-in development and testing for user interface,
we will need outline the UI first.  To do this, first we’ll need a page to host
our code.  Let’s create and route a Rails <code class="literal">TasksController</code>. We’ll bootstrap the
Backbone app on <code class="literal">tasks#index</code>.</p>
<pre class="programlisting">ExampleApp::Application.routes.draw <b class="hl-keyword">do</b>
  resources :tasks <b class="hl-keyword">do</b>
    resources :attachments, :only =&gt; [:create, :show]
  <b class="hl-keyword">end</b>

  root :to =&gt; <b class="hl-string"><i style="color:red">'tasks#index'</i></b>

  <b class="hl-keyword">if</b> [<b class="hl-string"><i style="color:red">"development"</i></b>, <b class="hl-string"><i style="color:red">"test"</i></b>].include? Rails.env
    mount Jasminerice::Engine =&gt; <b class="hl-string"><i style="color:red">"/jasmine"</i></b>
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>You can also see the route for the
[jasminerice gem](<a class="ulink" href="http://rubygems.org/gems/jasminerice" target="_top">http://rubygems.org/gems/jasminerice</a>), which makes the Rails
3.1 asset pipeline (and all of our app assets) available to the Jasmine specs.</p>
</div>
<pre class="programlisting"><b class="hl-keyword">class</b> TasksController &lt; ApplicationController
  before_filter :authorize
  respond_to :html, :json

  <b class="hl-keyword">def</b> index
    respond_with(@tasks = current_user.tasks)
  <b class="hl-keyword">end</b>

  <b class="hl-keyword">def</b> create
    respond_with(current_user.tasks.create(params[:task]))
  <b class="hl-keyword">end</b>

  <b class="hl-keyword">def</b> update
    task = current_user.tasks.find(params[:id])
    task.update_attributes(params[:task])
    respond_with(task)
  <b class="hl-keyword">end</b>
<b class="hl-keyword">end</b></pre>
<p>To render our tasks, we’ll want a TasksIndex Backbone view class.  But before we
write this class, we’ll motivate it with a Jasmine isolation spec:</p>
<pre class="programlisting">describe(<b class="hl-string"><i style="color:red">"ExampleApp.Views.TasksIndex"</i></b>, <b class="hl-keyword">function</b>() {
  it(<b class="hl-string"><i style="color:red">"renders a task table"</i></b>, <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> view = <b class="hl-keyword">new</b> ExampleApp.Views.TasksIndex();
    view.render();

    <b class="hl-keyword">var</b> $el = $(view.el);

    expect($el).toBe(<b class="hl-string"><i style="color:red">"#tasks"</i></b>);
    expect($el).toContain(<b class="hl-string"><i style="color:red">"table"</i></b>);
  });
});</pre>
<p>We use the [jasmine-jquery](<a class="ulink" href="https://github.com/velesin/jasmine-jquery" target="_top">https://github.com/velesin/jasmine-jquery</a>) library
(provided by jasminerice) to provide DOM matchers for Jasmine like
<code class="literal">toContain()</code>.</p>
<p>To run the Jasmine spec, run the Rails server and visit <a class="ulink" href="http://localhost:3000/jasmine" target="_top">http://localhost:3000/jasmine</a></p>
<p>To make this test pass, we’ll add a small template and make the <code class="literal">TasksIndex</code>
view render it:</p>
<pre class="programlisting">ExampleApp.Views.TasksIndex = Backbone.View.extend({
  tagName: <b class="hl-string"><i style="color:red">'div'</i></b>,
  id: <b class="hl-string"><i style="color:red">'tasks'</i></b>,

  initialize: function() {
  },

  render: function () {
    $(this.el).html(JST[<b class="hl-string"><i style="color:red">'tasks/index'</i></b>]({}));
    <b class="hl-keyword">return</b> this;
  }
});</pre>
<p>The <code class="literal">app/assets/templates/tasks/index.jst.ejs</code> template:</p>
<pre class="programlisting">&lt;table&gt;&lt;/table&gt;</pre>
<p>Now our Jasmine specs pass:</p>
<div class="figure">
<a id="d0e3138"></a><p class="title"><b>Figure 5. Passing Jasmine spec</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="testing/jasmine-passing.png" alt="testing/jasmine-passing.png"></div></div>
</div>
<br class="figure-break"><p>Since the Jasmine specs pass, we’ll pop back up a level and run the Cucumber
story.  Running it again, the failure is slightly different.  The <code class="literal">"#tasks
table"</code> element is present on the page, but doesn’t contain the content we want.</p>
<pre class="programlisting">@javascript
Scenario: View tasks                                          # features/view_tasks.feature:7
  Given the following tasks exist:                            # factory_girl-2.1.0/lib/factory_girl/step_definitions.rb:99
    | Title                                |
    | Purchase the backbone on rails ebook |
    | Master backbone                      |
  And I am on the home page                                   # features/step_definitions/web_steps.rb:44
  Then I should see "Master backbone" within the tasks list   # features/step_definitions/web_steps.rb:35
    expected there to be content "Master backbone" in "Title Completed" (RSpec::Expectations::ExpectationNotMetError)
    ./features/step_definitions/web_steps.rb:107:in `/^(?:|I )should see "([^"]*)"$/'
    features/view_tasks.feature:13:in `Then I should see "Master backbone" within the tasks list'</pre>
<p>Drop back down to Jasmine and write a spec motivating the TasksIndex view to
accept a collection and render it.  We’ll rewrite our existing spec, since we
are changing the TasksIndex interface to require that a collection be passed in:</p>
<pre class="programlisting"><i class="hl-comment" style="color: silver">//= require application</i>

describe(<b class="hl-string"><i style="color:red">"ExampleApp.Views.TasksIndex"</i></b>, <b class="hl-keyword">function</b>() {
  it(<b class="hl-string"><i style="color:red">"renders a collection of tasks"</i></b>, <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> tasksCollection = <b class="hl-keyword">new</b> ExampleApp.Collections.Tasks();
    tasksCollection.reset([
      { title: <b class="hl-string"><i style="color:red">"Wake up"</i></b> },
      { title: <b class="hl-string"><i style="color:red">"Brush your teeth"</i></b> }
    ]);

    <b class="hl-keyword">var</b> view = <b class="hl-keyword">new</b> ExampleApp.Views.TasksIndex({collection: tasksCollection});
    <b class="hl-keyword">var</b> $el = $(view.render().el);

    expect($el).toHaveText(/Wake up/);
    expect($el).toHaveText(/Brush your teeth/);
  });
});</pre>
<p>This spec fails:</p>
<pre class="programlisting">1 spec, 1 failure in 0.008sFinished at Thu Sep 22 2011 18:10:26 GMT-0400 (EDT)
ExampleApp.Views.TasksIndex
renders a collection of tasks
TypeError: undefined is not a function
TypeError: undefined is not a function
    at [object Object].&lt;anonymous&gt; (http://localhost:3000/assets/views/tasks_index_spec.js?body=1:4:27)</pre>
<p>It’s failing because we haven’t defined <code class="literal">ExampleApp.Collections.Tasks</code> yet.  We
need to define a Task model and Tasks collection.  We’ll define the model:</p>
<pre class="programlisting">ExampleApp.Models.Task = Backbone.Model.extend({
  schema: {
    title: { type: <b class="hl-string"><i style="color:red">"Text"</i></b> }
  },

  urlRoot: <b class="hl-string"><i style="color:red">'/tasks'</i></b>,

  isComplete: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>.get(<b class="hl-string"><i style="color:red">'complete'</i></b>);
  }
});</pre>
<p>and test-drive the collection:</p>
<pre class="programlisting">describe(<b class="hl-string"><i style="color:red">"ExampleApp.Collections.Tasks"</i></b>, <b class="hl-keyword">function</b>() {
  it(<b class="hl-string"><i style="color:red">"contains instances of ExampleApp.Models.Task"</i></b>, <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> collection = <b class="hl-keyword">new</b> ExampleApp.Collections.Tasks();
    expect(collection.model).toEqual(ExampleApp.Models.Task);
  });

  it(<b class="hl-string"><i style="color:red">"is persisted at /tasks"</i></b>, <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> collection = <b class="hl-keyword">new</b> ExampleApp.Collections.Tasks();
    expect(collection.url).toEqual(<b class="hl-string"><i style="color:red">"/tasks"</i></b>);
  });
});</pre>
<pre class="programlisting">ExampleApp.Collections.Tasks = Backbone.Collection.extend({
  model: ExampleApp.Models.Task,
  url: <b class="hl-string"><i style="color:red">'/tasks'</i></b>
});</pre>
<p>Running the Jasmine specs again, we’re making progress.  The TasksIndex view is
accepting a collection of tasks, and now we have to render it:</p>
<pre class="programlisting">Expected '&lt;div id="tasks"&gt;&lt;table&gt; &lt;tbody&gt;&lt;tr&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;Completed&lt;/th&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/table&gt; &lt;/div&gt;' to have text 'Wake up'.</pre>
<p>The simplest thing we can do to get the spec passing is to pass the <code class="literal">tasks</code>
collection into the template, and iterate over it there:</p>
<p>app/assets/javascripts/views/tasks_index.js:</p>
<pre class="programlisting">ExampleApp.Views.TasksIndex = Backbone.View.extend({
  initialize: <b class="hl-keyword">function</b>() {
    _.bindAll(<b class="hl-keyword">this</b>, <b class="hl-string"><i style="color:red">"render"</i></b>);
    <b class="hl-keyword">this</b>.collection.bind(<b class="hl-string"><i style="color:red">"add"</i></b>, <b class="hl-keyword">this</b>.render);
  },

  render: <b class="hl-keyword">function</b> () {
    <b class="hl-keyword">this</b>.renderTemplate();
    <b class="hl-keyword">this</b>.renderTasks();
    <b class="hl-keyword">return</b> <b class="hl-keyword">this</b>;
  },

  renderTemplate: <b class="hl-keyword">function</b>() {
    $(<b class="hl-keyword">this</b>.el).html(JST[<b class="hl-string"><i style="color:red">'tasks/index'</i></b>]({ tasks: <b class="hl-keyword">this</b>.collection }));
  },

  renderTasks: <b class="hl-keyword">function</b>() {
    <b class="hl-keyword">var</b> self = <b class="hl-keyword">this</b>;
    <b class="hl-keyword">this</b>.collection.each(<b class="hl-keyword">function</b>(task) {
      <b class="hl-keyword">var</b> row = <b class="hl-keyword">new</b> ExampleApp.Views.TaskItem({ model: task });
      self.$(<b class="hl-string"><i style="color:red">'tbody'</i></b>).append(row.render().el);
    });
  }
});</pre>
<p>app/assets/javascripts/templates/tasks/index.jst.ejs:</p>
<pre class="programlisting">&lt;table id="tasks-list"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Title&lt;/th&gt;
      &lt;th&gt;Completed&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;a class="create" href="#new"&gt;Add task&lt;/a&gt;</pre>
<p>Now, Jasmine passes.  But the Cucumber story is still failing: this is because
the Jasmine spec is an isolation spec, and verifies that the TasksIndex view
works in isolation.</p>
<pre class="programlisting">Then I should see "Master backbone" within the tasks list # features/step_definitions/web_steps.rb:35
Unable to find css "#tasks table" (Capybara::ElementNotFound)</pre>
<p>However, there is additional code we need to write to integrate the data present
in the Rails test database with the Backbone view.  Adding this code to
bootstrap the Backbone application should wrap up our exercise and get the tests
passing.</p>
<p>We’ll motivate writing a top-level Backbone application object with a spec.
Note the use of a <code class="literal">sinon.spy</code> for verifying the router instantiation:</p>
<p>spec/javascripts/example_app_spec.js</p>
<pre class="programlisting">describe(<b class="hl-string"><i style="color:red">"ExampleApp"</i></b>, <b class="hl-keyword">function</b>(){
  it(<b class="hl-string"><i style="color:red">"has a namespace for Models"</i></b>, <b class="hl-keyword">function</b>() {
    expect(ExampleApp.Models).toBeTruthy();
  });

  it(<b class="hl-string"><i style="color:red">"has a namespace for Collections"</i></b>, <b class="hl-keyword">function</b>() {
    expect(ExampleApp.Collections).toBeTruthy();
  });

  it(<b class="hl-string"><i style="color:red">"has a namespace for Views"</i></b>, <b class="hl-keyword">function</b>() {
    expect(ExampleApp.Views).toBeTruthy();
  });

  it(<b class="hl-string"><i style="color:red">"has a namespace for Routers"</i></b>, <b class="hl-keyword">function</b>() {
    expect(ExampleApp.Routers).toBeTruthy();
  });

  describe(<b class="hl-string"><i style="color:red">"init()"</i></b>, <b class="hl-keyword">function</b>() {
    it(<b class="hl-string"><i style="color:red">"accepts task JSON and instantiates a collection from it"</i></b>, <b class="hl-keyword">function</b>() {
      <b class="hl-keyword">var</b> tasksJSON = [{<b class="hl-string"><i style="color:red">"title"</i></b>:<b class="hl-string"><i style="color:red">"thing to do"</i></b>}, {<b class="hl-string"><i style="color:red">"title"</i></b>:<b class="hl-string"><i style="color:red">"another thing"</i></b>}];
      ExampleApp.init(tasksJSON);

      expect(ExampleApp.tasks).not.toEqual(<b class="hl-keyword">undefined</b>);
      expect(ExampleApp.tasks.length).toEqual(<span class="hl-number">2</span>);
      expect(ExampleApp.tasks.models[<span class="hl-number">0</span>].get(<b class="hl-string"><i style="color:red">'title'</i></b>)).toEqual(<b class="hl-string"><i style="color:red">"thing to do"</i></b>);
      expect(ExampleApp.tasks.models[<span class="hl-number">1</span>].get(<b class="hl-string"><i style="color:red">'title'</i></b>)).toEqual(<b class="hl-string"><i style="color:red">"another thing"</i></b>);
    });

    it(<b class="hl-string"><i style="color:red">"instantiates a Tasks router"</i></b>, <b class="hl-keyword">function</b>() {
      ExampleApp.Routers.Tasks = sinon.spy();
      ExampleApp.init();
      expect(ExampleApp.Routers.Tasks).toHaveBeenCalled();
    });

    it(<b class="hl-string"><i style="color:red">"starts Backbone.history"</i></b>, <b class="hl-keyword">function</b>() {
      Backbone.history = { start: sinon.spy() };
      ExampleApp.init();
      expect(Backbone.history.start).toHaveBeenCalled();
    });
  });
});</pre>
<p>Get it to green:</p>
<pre class="programlisting"><b class="hl-keyword">var</b> ExampleApp = {
  Models: {},
  Collections: {},
  Views: {},
  Routers: {},
  init: <b class="hl-keyword">function</b>(tasks) {
    <b class="hl-keyword">this</b>.tasks = <b class="hl-keyword">new</b> ExampleApp.Collections.Tasks(tasks);

    <b class="hl-keyword">new</b> ExampleApp.Routers.Tasks();
    <b class="hl-keyword">if</b> (!Backbone.history.started) {
      Backbone.history.start();
      Backbone.history.started = true;
    }
  }
};</pre>
<p>Then we bootstrap the app from the Rails view:</p>
<pre class="programlisting">&lt;h1&gt;Tasks&lt;/h1&gt;

&lt;div id="tasks"&gt;
&lt;/div&gt;

&lt;%= content_for :javascript do -%&gt;
  &lt;%= javascript_tag do %&gt;
    $(function() {
      ExampleApp.init(&lt;%== @tasks.to_json %&gt;);
    });
  &lt;% end %&gt;
&lt;% end -%&gt;</pre>
<p>And the integration test passes!</p>
<pre class="programlisting">Feature: Viewing Tasks
  As a user
  So that I can see what I have to do
  I want to be able to see all my tasks

  @javascript
  Scenario: View tasks
    Given the following tasks exist:
      | Title                                |
      | Purchase the backbone on rails ebook |
      | Master backbone                      |
    And I am on the home page
    Then I should see "Master backbone" within the tasks list
    And I should see "Purchase the backbone on rails ebook" within the tasks list

1 scenario (1 passed)
5 steps (5 passed)</pre>
<p>TODO: Refactoring step.  Extract a TaskView class and loop &amp; iterate.  Note
specs passing, cukes passing.</p>
<p>TODO: Possible, bind events on the child views to motivate making TasksIndex a
CompositeView to avoid leaking refs.</p>
<p>TODO: Optionally TDD through the new/create cycle, too.</p>
</div>
</div>

    </div>

    <hr/>

    <div class="nav" id="navfooter">
    <table width="100%">
      <tr><td width="33%" align="left">
        
         <a href="models_and_collections.html">Prev</a><br/>
         Models and collections
        
      </td><td width="33%" align="center">
        
         <a href="index.html">Home</a><br/>
         Backbone.js on Rails
        
      </td><td width="33%" align="right">
        
          <a href="security_stub_.html">Next</a><br/>
          Security (stub)
        
      </td></tr>
    </table>
    </div>
  </body>
</html>
